import io.cucumber.java.en.*;
import org.junit.Before;
import org.mockito.*;
import org.slf4j.Logger;
import com.jcraft.jsch.*;

import java.io.ByteArrayInputStream;
import java.util.*;

import static org.junit.Assert.fail;
import static org.mockito.Mockito.*;

public class RetrieveAndProcessFilesSteps {

    @Mock private SpaceCollector spaceCollector;
    @Mock private SSHService sshService;
    @Mock private FileUtil fileUtilMock;
    @Mock private OutputStreamCreator outputStreamCreatorMock;
    @Mock private S3Service s3ServiceMock;
    @Mock private KafkaProducerService kafkaProducerServiceMock;
    @Mock private DateUtil dateUtilMock;
    @Mock private Logger loggerMock;
    @Mock private ChannelSftp channelSftpMock;
    @Mock private ZipUtil zipUtilMock;
    @Mock private CollectorUtil collectorUtilMock;
    @Mock private ProfileCheckConfig profileCheckConfigMock;

    private RetrieveAndProcessService retrieveAndProcessService;
    private String dateReceived;
    private String auditTopic;
    private boolean result;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);

        // Mock the RetrieveAndProcessService and inject dependencies
        retrieveAndProcessService = spy(new RetrieveAndProcessService());

        // Inject mocks into retrieveAndProcessService
        doReturn(sshService).when(retrieveAndProcessService).getSSHService();
        doReturn(fileUtilMock).when(retrieveAndProcessService).getFileUtil();
        doReturn(outputStreamCreatorMock).when(retrieveAndProcessService).getOutputStreamCreator();
        doReturn(s3ServiceMock).when(retrieveAndProcessService).getS3Service();
        doReturn(kafkaProducerServiceMock).when(retrieveAndProcessService).getKafkaProducerService();
        doReturn(dateUtilMock).when(retrieveAndProcessService).getDateUtil();
        doReturn(loggerMock).when(retrieveAndProcessService).getLogger();
        doReturn(zipUtilMock).when(retrieveAndProcessService).getZipUtil();
        doReturn(collectorUtilMock).when(retrieveAndProcessService).getCollectorUtil();
        doReturn(profileCheckConfigMock).when(retrieveAndProcessService).getProfileCheckConfig();
    }

    @Given("a SpaceCollector with valid SSH credentials")
    public void aSpaceCollectorWithValidSSHCredentials() {
        when(spaceCollector.getUserName()).thenReturn("sshUsername");
        when(spaceCollector.getUrl()).thenReturn("sshHost");
        when(spaceCollector.getPassword()).thenReturn("sshPassword");
        when(spaceCollector.getPort()).thenReturn(22);
        when(spaceCollector.getInputFilePath()).thenReturn("/remote/data");
        when(spaceCollector.getOutputFilePath()).thenReturn("/local/data");
    }

    @And("a remote directory {string} containing nested files and folders including ZIP archives")
    public void aRemoteDirectoryContainingNestedFilesAndFoldersIncludingZIPArchives(String remoteDirectory) {
        try {
            List<ChannelSftp.LsEntry> files = Arrays.asList(
                mockFileEntry("file1.txt", false),
                mockFileEntry("file2.zip", false),
                mockFileEntry("folder1", true)
            );
            when(channelSftpMock.ls(remoteDirectory)).thenReturn(new Vector<>(files));
            when(channelSftpMock.get(remoteDirectory + "/file1.txt")).thenReturn(new ByteArrayInputStream("content".getBytes()));
            when(channelSftpMock.get(remoteDirectory + "/file2.zip")).thenReturn(new ByteArrayInputStream("content".getBytes()));

            doReturn(channelSftpMock).when(sshService).getChannelSftp(any(Session.class), eq(remoteDirectory));
        } catch (SftpException e) {
            e.printStackTrace();
        }
    }

    @And("some local directories do not exist")
    public void someLocalDirectoriesDoNotExist() {
        doNothing().when(fileUtilMock).createDirectoryIfNotExists(anyString());
    }

    @When("the retrieveData method is called with {string} and {string}")
    public void theRetrieveDataMethodIsCalledWithAnd(String dateReceived, String auditTopic) {
        this.dateReceived = dateReceived;
        this.auditTopic = auditTopic;
        try {
            result = retrieveAndProcessService.retrieveData(spaceCollector, dateReceived, auditTopic);
        } catch (Exception e) {
            e.printStackTrace();
            fail("Exception occurred: " + e.getMessage());
        }
    }

    @Then("the method should recursively retrieve all files and directories from the remote directory {string}")
    public void theMethodShouldRecursivelyRetrieveAllFilesAndDirectoriesFromTheRemoteDirectory(String remoteDirectory) {
        try {
            verify(channelSftpMock).ls(remoteDirectory);
        } catch (SftpException e) {
            e.printStackTrace();
        }
    }

    @And("create any missing local directories")
    public void createAnyMissingLocalDirectories() {
        verify(fileUtilMock, atLeastOnce()).createDirectoryIfNotExists(anyString());
    }

    @And("download files to the corresponding local directories")
    public void downloadFilesToTheCorrespondingLocalDirectories() {
        verify(fileUtilMock, atLeastOnce()).downloadFile(any(), any(), anyString(), anyString(), anyString());
    }

    @And("extract any ZIP files and process the extracted files")
    public void extractAnyZIPFilesAndProcessTheExtractedFiles() {
        verify(zipUtilMock, atLeastOnce()).extract(anyString(), anyString());
    }

    @And("push all files to S3 with appropriate keys")
    public void pushAllFilesToS3WithAppropriateKeys() {
        verify(s3ServiceMock, atLeastOnce()).pushToS3(anyString(), anyString());
    }

    @And("send a successful collection audit message to the Kafka audit topic for each successfully processed file")
    public void sendASuccessfulCollectionAuditMessageToTheKafkaAuditTopicForEachSuccessfullyProcessedFile() {
        verify(kafkaProducerServiceMock, atLeastOnce()).writeMessage(anyString(), anyString(), eq(auditTopic));
    }

    @And("log and handle any errors for missing or inaccessible files")
    public void logAndHandleAnyErrorsForMissingOrInaccessibleFiles() {
        verify(loggerMock, atLeastOnce()).error(anyString(), any(Exception.class));
    }

    @And("send a collection failure audit message to the Kafka audit topic for each missing or inaccessible file")
    public void sendACollectionFailureAuditMessageToTheKafkaAuditTopicForEachMissingOrInaccessibleFile() {
        verify(kafkaProducerServiceMock, atLeastOnce()).writeMessage(anyString(), anyString(), eq(auditTopic));
    }

    private ChannelSftp.LsEntry mockFileEntry(String name, boolean isDir) {
        ChannelSftp.LsEntry entry = Mockito.mock(ChannelSftp.LsEntry.class);
        SftpATTRS attrs = Mockito.mock(SftpATTRS.class);
        when(attrs.isDir()).thenReturn(isDir);
        when(entry.getAttrs()).thenReturn(attrs);
        when(entry.getFilename()).thenReturn(name);
        return entry;
    }
}
