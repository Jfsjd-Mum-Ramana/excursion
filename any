public boolean retrieveData(SpaceCollector sp, String dateReceived, String auditTopic) throws Exception {
    LOGGER.info("Entered SSH service");
    String sshUsername = sp.getUserName();
    String sshHost = sp.getUrl();
    String sshPassword = sp.getPassword();
    int port = sp.getPort().intValue();

    JSch jsch = getJsch(sshHost, sshPassword);
    Session session = getSession(sshUsername, sshHost, sshPassword, port, jsch);
    session.connect();

    ChannelSftp channelSftp = null;
    try {
        String remoteDirectory = FileUtil.getDirectory(sp.getInputFilePath());
        String localDirectory = FileUtil.getDirectory(sp.getOutputFilePath());
        LOGGER.info("Remote Directory: " + remoteDirectory + " Local Directory: " + localDirectory);

        channelSftp = getChannelSftp(session, remoteDirectory);
        traverseAndProcessFiles(channelSftp, remoteDirectory, localDirectory, sp, dateReceived, auditTopic);
    } finally {
        if (channelSftp != null) {
            channelSftp.disconnect();
        }
        if (session != null) {
            session.disconnect();
        }
    }
    return true;
}

private void traverseAndProcessFiles(ChannelSftp channelSftp, String remoteDirectory, String localDirectory, SpaceCollector sp, String dateReceived, String auditTopic) throws Exception {
    Vector<ChannelSftp.LsEntry> files = channelSftp.ls(remoteDirectory);

    for (ChannelSftp.LsEntry file : files) {
        String remoteFilePath = remoteDirectory + "/" + file.getFilename();

        if (file.getAttrs().isDir() && !file.getFilename().equals(".") && !file.getFilename().equals("..")) {
            String newLocalDirectory = localDirectory + "/" + file.getFilename();
            FileUtil.createDirectoryIfNotExists(newLocalDirectory);
            traverseAndProcessFiles(channelSftp, remoteFilePath, newLocalDirectory, sp, dateReceived, auditTopic);
        } else if (!file.getAttrs().isDir()) {
            processFile(channelSftp, remoteFilePath, localDirectory, sp, dateReceived, auditTopic);
        }
    }
}

private void processFile(ChannelSftp channelSftp, String remoteFilePath, String localDirectory, SpaceCollector sp, String dateReceived, String auditTopic) {
    try {
        String outputFile = localDirectory + "/" + FileUtil.getFileName(remoteFilePath);
        LOGGER.info("Input File Path: " + remoteFilePath + " Output File Path: " + outputFile);

        // Download file
        FileUtil.downloadFile(outputStreamCreator.create(outputFile), channelSftp.get(remoteFilePath),
                remoteFilePath, outputFile, localDirectory);

        List<String> filesList = new ArrayList<>();
        if (ZipUtil.isZipFile(outputFile)) {
            String fileNameWithoutExtn = FileUtil.getFileNameWithoutExtn(remoteFilePath);
            FileUtil.createDirectoryIfNotExists(localDirectory + "/" + fileNameWithoutExtn);
            ZipUtil.extract(outputFile, localDirectory + "/" + fileNameWithoutExtn);
            filesList.addAll(FileUtil.readFilesInDirectory(localDirectory + "/" + fileNameWithoutExtn));
        } else {
            filesList.add(outputFile);
        }

        // Process each file (including both zip contents and non-zip files)
        for (String fileName : filesList) {
            Path insideFilePath = Paths.get(fileName);
            Path folderPath = Paths.get(localDirectory).relativize(insideFilePath.getParent());
            String unixBasedPath = folderPath.toString().replace("\\", "/");
            String key = String.format("%s/%s/%s/%s/%s",
                    ProfileCheckConfig.activeProfile,
                    sp.getFileType(),
                    sshHost,
                    dateUtil.getDateInMMddyyyy(),
                    !StringUtils.isBlank(unixBasedPath)
                            ? (unixBasedPath.toString() + "/" + insideFilePath.getFileName())
                            : insideFilePath.getFileName());

            LOGGER.info("Filename: " + fileName + " Key: " + key);
            s3Service.pushToS3(fileName, key);
            CollectionAudit audit = createAuditObject(sp, key, JobStatus.COLLECTION_SUCCESSFUL.toString(), "");
            kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit), "", auditTopic);
        }
    } catch (Exception e) {
        CollectionAudit audit = createAuditObject(sp, remoteFilePath, JobStatus.COLLECTION_FAILED.toString(), e.getMessage());
        kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit), "", auditTopic);
        LOGGER.error("Error on retrieveData {}", e);
    }
}
