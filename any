public boolean retrieveData(SpaceCollector sp, String dateReceived, String auditTopic) throws Exception {
        LOGGER.info("Entered SSH service");
        String sshUsername = sp.getUserName();
        String sshHost = sp.getUrl();
        String sshPassword = sp.getPassword();
        int port = sp.getPort().intValue();
        JSch jsch = getJsch(sshHost, sshPassword);
        Session session = getSession(sshUsername, sshHost, sshPassword, port, jsch);
        session.connect();
        ChannelSftp channelSftp = null;
        try {
            String remoteDirectory = FileUtil.getDirectory(sp.getInputFilePath());
            String localDirectory = FileUtil.getDirectory(sp.getOutputFilePath());
            LOGGER.info("remoteDirectory : " + remoteDirectory + " localDirectory : " + localDirectory);
            channelSftp = getChannelSftp(session, remoteDirectory);
            // Recursively retrieve and process files and directories
            retrieveAndProcessDirectory(sp, dateReceived, auditTopic, remoteDirectory, localDirectory, channelSftp);
        } finally {
            if (channelSftp != null) {
                channelSftp.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
        return true;
    }
    private void retrieveAndProcessDirectory(SpaceCollector sp, String dateReceived, String auditTopic,
                                             String remoteDirectory, String localDirectory, ChannelSftp channelSftp) throws Exception {
        Vector<ChannelSftp.LsEntry> files = channelSftp.ls(remoteDirectory);
        LOGGER.info("Number of files/Directories found in "+remoteDirectory+ ":"+files.size());
        Map<String, String> auditStatusMap = getAuditStatusMap(files, remoteDirectory);
        for (ChannelSftp.LsEntry file : files) {
            if (!file.getAttrs().isDir()) {
                LOGGER.info("found file in LS: "+ file.getFilename());
                String filePath = remoteDirectory + "/" + file.getFilename(); // Use absolute file path
                LOGGER.info("filePath for lookup in COLLECTION_AUDIT: "+ filePath);
                String status = auditStatusMap.get(filePath);
                if (status == null || "COLLECTION_FAILED".equals(status)) {
                    try {
                        String outputFile = localDirectory + "/" + file.getFilename();
                        LOGGER.info("in filePath : " + filePath + " out filePath : " + outputFile);
                        FileUtil.downloadFile(outputStreamCreator.create(outputFile), channelSftp.get(filePath),
                                filePath, outputFile, sp.getOutputFilePath());
                        processDownloadedFile(sp, dateReceived, auditTopic, outputFile, localDirectory);
                    } catch (Exception e) {
                        CollectionAudit audit = createAuditObject(sp,
                                filePath, JobStatus.COLLECTION_FAILED.toString(), e.getMessage());
                        kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit), "",
                                auditTopic);
                        LOGGER.error("Error on retrieveData {}", e);
                    }
                }
            } else {
                if (!".".equals(file.getFilename()) && !"..".equals(file.getFilename())) {
                    LOGGER.info("DIR found : " + file.getFilename());
                    String subRemoteDirectory = remoteDirectory + "/" + file.getFilename();
                    String subLocalDirectory = localDirectory + "/" + file.getFilename();
                    FileUtil.createDirectoryIfNotExists(subLocalDirectory);
                    retrieveAndProcessDirectory(sp, dateReceived, auditTopic, subRemoteDirectory, subLocalDirectory, channelSftp);
                }
            }
        }
    }
    private void processDownloadedFile(SpaceCollector sp, String dateReceived, String auditTopic,
                                       String outputFile, String localDirectory) throws Exception {
        List<String> filesList = new ArrayList<>();
        LOGGER.info("Processing downloaded file: "+ outputFile);
        if (ZipUtil.isZipFile(outputFile)) {
            LOGGER.info("Zip file found: "+ outputFile);
            String fileNameWithoutExtn = FileUtil.getFileNameWithoutExtn(outputFile);
            FileUtil.createDirectoryIfNotExists(localDirectory + "/" + fileNameWithoutExtn);
            ZipUtil.extract(outputFile, localDirectory + "/" + fileNameWithoutExtn);
            filesList.addAll(FileUtil.readFilesInDirectory(localDirectory + "/" + fileNameWithoutExtn));
        } else {
            LOGGER.info("non Zip file found: "+ outputFile);
            filesList.add(outputFile);
        }
        for (String fileName : filesList) {
            Path insideFilePath = Paths.get(fileName);
            Path folderPath = Paths.get(sp.getOutputFilePath()).relativize(insideFilePath.getParent());
            String unixBasedPath = folderPath.toString().replace("\\", "/");
            String key = String.format("%s/%s/%s/%s/%s",
                    ProfileCheckConfig.activeProfile,
                    sp.getFileType(),
                    sp.getUrl(),
                    dateUtil.getDateInMMddyyyy(),
                    !StringUtils.isBlank(unixBasedPath)
                            ? (unixBasedPath.toString() + "/" + insideFilePath.getFileName())
                            : insideFilePath.getFileName());
            System.out.println("**************************");
            System.out.println("Filename: " + fileName);
            System.out.println("Key: " + key);
            System.out.println("folderPath: " + folderPath);
            System.out.println("Inside File Path: " + insideFilePath);
            System.out.println("**************************");
            s3Service.pushToS3(fileName, key);
            CollectionAudit audit = createAuditObject(sp,
                    key, JobStatus.COLLECTION_SUCCESSFUL.toString(), "");
            kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit),
                    "", auditTopic);
            // Check if the file is an archive and process it further
            if (ZipUtil.isZipFile(fileName)) {
                String nestedFileNameWithoutExtn = FileUtil.getFileNameWithoutExtn(fileName);
                FileUtil.createDirectoryIfNotExists(localDirectory + "/" + nestedFileNameWithoutExtn);
                ZipUtil.extract(fileName, localDirectory + "/" + nestedFileNameWithoutExtn);
                List<String> nestedFilesList = FileUtil.readFilesInDirectory(localDirectory + "/" + nestedFileNameWithoutExtn);
                for (String nestedFile : nestedFilesList) {
                    processDownloadedFile(sp, dateReceived, auditTopic, nestedFile, localDirectory);
                }
            }
        }



Collection: Enable Search for Files Placed in the Last 24 Hours in custom-ssh-collector

AC1: Given our collector is connected to a host

When it tries to find files inside it

Then it should be able to traverse through the nested directory structure

And find the individual files.



AC2: Given the collector has found an individual file in the nested directory structure

When it tries to upload the file

Then it should successfully upload the file to S3.





AC3: Given the collector has found a zipped file in the nested directory structure

When it tries to unzip the file

Then it should successfully unzip the file and reveal its contents.

And Then it should successfully upload the unzipped files to S3.
