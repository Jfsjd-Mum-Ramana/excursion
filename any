import java.io.*;
import java.util.*;
import java.util.zip.*;
import org.apache.commons.io.IOUtils;

@Service
@Slf4j
public class SSHService {
    private static final Logger LOGGER = LoggerFactory.getLogger(SSHService.class);
    
    @Autowired
    CollectorUtil collectorUtil;
    
    @Autowired
    DateUtil dateUtil;
    
    @Autowired
    private LuceneCollectionAuditRepository luceneCollectionAuditRepo;
    
    @Autowired
    private JSchFactory jschFactory;
    
    @Autowired
    private OutputStreamCreator outputStreamCreator;
    
    @Autowired
    KafkaProducerService kafkaProducerService;
    
    @Autowired
    private S3Service s3Service;

    public SSHService(LuceneCollectionAuditRepository luceneCollectionAuditRepo, JSchFactory jschFactory, OutputStreamCreator outputStreamCreator) {
        this.luceneCollectionAuditRepo = luceneCollectionAuditRepo;
        this.jschFactory = jschFactory;
        this.outputStreamCreator = outputStreamCreator;
    }

    public void retrieveData(SpaceCollector sp, String dateReceived, String auditTopic) throws Exception {
        LOGGER.info("Entered SSH service");
        JSch jsch = jschFactory.createJSch();
        String sshUsername = sp.getUserName();
        String sshHost = sp.getUrl();
        String sshPassword = sp.getPassword();
        
        if (sshPassword.equals("")) {
            jsch.addIdentity("/prod/eclapp/lib/id_rsa_decoded");
        }
        
        int port = sp.getPort().intValue();
        Session session = jsch.getSession(sshUsername, sshHost, port);
        session.setConfig("StrictHostKeyChecking", "no");
        
        if (!sshPassword.isEmpty()) {
            session.setPassword(sshPassword);
        }
        
        if (sshHost.equals("localhost")) {
            String knownHostsFile = System.getProperty("user.home") + "/.ssh/known_hosts";
            jsch.setKnownHosts(knownHostsFile);
        }
        
        session.connect();
        ChannelSftp channelSftp = (ChannelSftp) session.openChannel("sftp");
        channelSftp.connect();
        
        try {
            String remoteDirectory = getDirectory(sp.getInputFilePath());
            String localDirectory = getDirectory(sp.getOutputFilePath());
            channelSftp.cd(remoteDirectory);
            Vector<ChannelSftp.LsEntry> files = channelSftp.ls(".");
            String date = dateUtil.getDateInMMddyyyy();
            String env = ProfileCheckConfig.activeProfile;
            
            List<String> filePaths = files.stream()
                    .filter(file -> !file.getAttrs().isDir())
                    .map(file -> remoteDirectory + file.getFilename()) 
                    .collect(Collectors.toList());
            
            List<CollectionAudit> audits = luceneCollectionAuditRepo.findLatestByFilePaths(filePaths);
            Map<String, String> auditStatusMap = audits.stream()
                    .filter(audit -> audit != null)
                    .collect(Collectors.toMap(audit -> audit.getInputFilePath(), audit -> audit.getJobStatus()));
            
            for (ChannelSftp.LsEntry file : files) {
                if (!file.getAttrs().isDir()) {
                    String filePath = remoteDirectory + file.getFilename();
                    String status = auditStatusMap.get(filePath);
                    if (status == null || "COLLECTION_FAILED".equals(status)) {
                        processFile(channelSftp, filePath, localDirectory, auditTopic, sp);
                    }
                }
            }
        } finally {
            if (channelSftp != null) {
                channelSftp.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
    }

    private void processFile(ChannelSftp channelSftp, String filePath, String localDirectory, String auditTopic, SpaceCollector sp) throws IOException {
        try (InputStream inputStream = channelSftp.get(filePath)) {
            List<String> uncompressedFilePaths = unzip(inputStream, localDirectory);
            
            for (String uncompressedFilePath : uncompressedFilePaths) {
                processSingleFile(channelSftp, uncompressedFilePath, localDirectory, auditTopic, sp);
            }
            
            generateAuditMessage(filePath, uncompressedFilePaths, auditTopic);
        }
    }

    private List<String> unzip(InputStream inputStream, String outputDirectory) throws IOException {
        List<String> uncompressedFilePaths = new ArrayList<>();
        byte[] buffer = new byte[1024];
        
        try (ZipInputStream zipInputStream = new ZipInputStream(inputStream)) {
            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                String entryName = entry.getName();
                String unzippedFilePath = outputDirectory + File.separator + entryName;
                uncompressedFilePaths.add(unzippedFilePath);
                
                Files.createDirectories(Paths.get(unzippedFilePath).getParent());
                
                try (OutputStream outputStream = new FileOutputStream(unzippedFilePath)) {
                    IOUtils.copy(zipInputStream, outputStream);
                }
            }
        }
        
        return uncompressedFilePaths;
    }

    private void generateAuditMessage(String originalFilePath, List<String> unzippedFilePaths, String auditTopic) {
        StringBuilder message = new StringBuilder("OriginalFilePath --> UnzippedFilePath\n");
        for (String unzippedFilePath : unzippedFilePaths) {
            message.append(originalFilePath).append(" --> ").append(unzippedFilePath).append("\n");
        }
        LOGGER.info("Audit Message: {}", message.toString());
        // Send audit message
    }

    private String getDirectory(String sp) {
        String remoteDirectory = sp;
        if (!remoteDirectory.endsWith("/")) {
            remoteDirectory += "/";
        }
        return remoteDirectory;
    }
    
    private void pushToS3(String filePath, String s3Key) {
        try {
            s3Service.pushToS3(new FileInputStream(filePath), s3Key);
            LOGGER.info("File pushed to S3 - Key: {}", s3Key);
        } catch (FileNotFoundException e) {
            LOGGER.error("File not found: {}", filePath, e);
        }
    }
}



for the above code implement the unzip functionality in the above code means whenever the input file will be containing any file it will unzip the file the file will containing any file like .zip and .tar and .gz any file it will unzip the file write the logic accordingly 