package org.vdsi.space.collections.customsshcollector.services;

import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.Session;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.vdsi.space.collections.customsshcollector.repository.LuceneCollectionAuditRepository;
import org.vdsi.space.collections.customsshcollector.util.CollectorUtil;
import org.vdsi.space.collections.lucene.enums.JobStatus;
import org.vdsi.space.collections.lucene.enums.ProcessType;
import org.vdsi.space.collections.lucene.model.CollectionAudit;
import org.vdsi.space.collections.lucene.model.SpaceCollector;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.Vector;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

@Service
@Slf4j
public class SSHService {
    private static final Logger LOGGER = LoggerFactory.getLogger(SSHService.class);
    
    @Autowired
    CollectorUtil collectorUtil;
    
    @Autowired
    private LuceneCollectionAuditRepository luceneCollectionAuditRepo;
    
    @Autowired
    private JSchFactory jschFactory;
    
    @Autowired
    private OutputStreamCreator outputStreamCreator;
    
    @Autowired
    KafkaProducerService kafkaProducerService;
    
    @Autowired
    private S3Service s3Service;
    
    public SSHService() {
    }
    
    public boolean retrieveData(SpaceCollector sp, String dateReceived, String auditTopic) throws Exception {
        LOGGER.info("Entered SSH service");
        boolean isAllFilesTransferred = true;
        JSch jsch = jschFactory.createJSch();
        String sshUsername = sp.getUserName();
        String sshHost = sp.getUrl();
        String sshPassword = sp.getPassword();
        
        if (sshPassword.equals("")) {
            jsch.addIdentity("src/main/resources/sshkey.pem");
        }
        
        int port = sp.getPort().intValue();
        Session session = jsch.getSession(sshUsername, sshHost, port);
        session.setConfig("StrictHostKeyChecking", "no");
        
        if (!sshPassword.isEmpty()) {
            session.setPassword(sshPassword);
        }
        
        if (sshHost.equals("localhost")) {
            String knownHostsFile = System.getProperty("user.home") + "/.ssh/known_hosts";
            jsch.setKnownHosts(knownHostsFile);
        }
        
        session.connect();
        ChannelSftp channelSftp = (ChannelSftp) session.openChannel("sftp");
        channelSftp.connect();
        
        try {
            String remoteDirectory = getDirectory(sp.getInputFilePath());
            String localDirectory = getDirectory(sp.getOutputFilePath());
            channelSftp.cd(remoteDirectory);
            Vector<ChannelSftp.LsEntry> files = channelSftp.ls(".");
            List<String> filePaths = files.stream()
                    .filter(file -> !file.getAttrs().isDir())
                    .map(file -> remoteDirectory + file.getFilename())
                    .collect(Collectors.toList());
            List<CollectionAudit> audits = luceneCollectionAuditRepo.findLatestByFilePaths(filePaths);
            Map<String, String> auditStatusMap = audits.stream()
                    .filter(audit -> audit != null)
                    .collect(Collectors.toMap(audit -> audit.getInputFilePath(), audit -> audit.getJobStatus()));
            for (ChannelSftp.LsEntry file : files) {
                if (!file.getAttrs().isDir()) {
                    String filePath = remoteDirectory + file.getFilename();
                    String status = auditStatusMap.get(filePath);
                    if (status == null || "COLLECTION_FAILED".equals(status)) {
                        CollectionAudit audit = getCollectionAudit(sp);
                        try {
                            if (isZipFile(filePath)) {
                                unzipFile(channelSftp, filePath, localDirectory);
                            } else {
                                InputStream inputStream = channelSftp.get(filePath);
                                String outputFile = localDirectory + file.getFilename();
                                OutputStream outputStream = outputStreamCreator.create(outputFile);
                                transferFile(inputStream, outputStream);
                                s3Service.pushToS3(outputFile, file.getFilename());
                                audit.setInputFilePath(outputFile);
                                audit.setJobStatus(JobStatus.COLLECTION_SUCCESSFUL.toString());
                                kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit), "", auditTopic);
                            }
                        } catch (Exception e) {
                            audit.setInputFilePath(filePath);
                            audit.setJobStatus(JobStatus.COLLECTION_FAILED.toString());
                            audit.setExceptions(e.getMessage());
                            kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit), "", auditTopic);
                        }
                    }
                }
            }
        } finally {
            if (channelSftp != null) {
                channelSftp.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
        return isAllFilesTransferred;
    }
    
    private CollectionAudit getCollectionAudit(SpaceCollector sp) {
        CollectionAudit audit = new CollectionAudit();
        audit.setId(UUID.randomUUID().toString());
        audit.setDateProcessed(collectorUtil.localDateToString(LocalDateTime.now()));
        audit.setFileType(sp.getFileType());
        audit.setDelimiters(sp.getDelimiter());
        audit.setUrl(sp.getUrl());
        audit.setPort(Integer.valueOf(sp.getPort().toString()));
        audit.setCollectorId(sp.getId());
        audit.setProcessType(ProcessType.Collector);
        return audit;
    }
    
    private void unzipFile(ChannelSftp channelSftp, String zipFilePath, String outputDirectory) throws IOException {
        try (InputStream inputStream = channelSftp.get(zipFilePath);
             ZipInputStream zipInputStream = new ZipInputStream(inputStream)) {
            ZipEntry entry;
            while ((entry = zipInputStream.getNextEntry()) != null) {
                if (!entry.isDirectory()) {
                    String entryFilePath = outputDirectory + entry.getName();
                    Files.copy(zipInputStream, Paths.get(entryFilePath));
                    processExtractedFile(entryFilePath);
                }
            }
        }
    }
    
    private void processExtractedFile(String filePath) {
        // Process each extracted file independently
    }
    
    private boolean isZipFile(String filePath) {
        return filePath.toLowerCase().endsWith(".zip");
    }
    
    private static String getDirectory(String sp) {
        String remoteDirectory = sp;
        if (!remoteDirectory.endsWith("/")) {
            remoteDirectory += "/";
        }
        return remoteDirectory;
    }
    
    public void transferFile(InputStream inputStream, OutputStream outputStream) throws IOException {
        byte[] buffer = new byte[1024];
        int bytesRead;
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            outputStream.write(buffer, 0, bytesRead);
        }
        outputStream.close();
        inputStream.close();
    }
}
