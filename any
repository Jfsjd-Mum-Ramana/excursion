Feature: Retrieve and process data from a remote server with nested folder structures

  Scenario: Retrieve and process files including nested directories and zip files
    Given a SpaceCollector configuration with remote and local paths
    And the remote server contains a nested directory structure with zip files
    When the retrieveData method is called
    Then all files and directories are retrieved
    And the zip files are extracted and their contents are processed
    And all files are pushed to S3
    And audit messages are sent for successful and failed collections





import com.jcraft.jsch.*;
import io.cucumber.java.en.*;
import org.junit.Assert;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.nio.file.*;
import java.util.List;
import java.util.Properties;

public class RetrieveDataSteps {

    private SpaceCollector spaceCollector;
    private boolean result;

    @Given("a SpaceCollector configuration with remote and local paths")
    public void givenSpaceCollectorConfiguration() {
        spaceCollector = new SpaceCollector();
        spaceCollector.setUserName("user");
        spaceCollector.setUrl("example.com");
        spaceCollector.setPassword("password");
        spaceCollector.setPort(22);
        spaceCollector.setInputFilePath("/remote/input/path");
        spaceCollector.setOutputFilePath("/local/output/path");
        spaceCollector.setFileType("fileType");

        // Mocked local setup for the purpose of the test
        FileUtil.createDirectoryIfNotExists("/local/output/path");
    }

    @And("the remote server contains a nested directory structure with zip files")
    public void givenRemoteServerWithNestedZipFiles() throws Exception {
        // Setting up a test SFTP server with nested directories and zip files
        JSch jsch = new JSch();
        Session session = jsch.getSession("user", "example.com", 22);
        session.setPassword("password");

        Properties config = new Properties();
        config.put("StrictHostKeyChecking", "no");
        session.setConfig(config);
        session.connect();

        ChannelSftp channelSftp = (ChannelSftp) session.openChannel("sftp");
        channelSftp.connect();

        // Creating nested directories on the remote server
        createRemoteDirectory(channelSftp, "/remote/input/path/dir1");
        createRemoteDirectory(channelSftp, "/remote/input/path/dir2");

        // Uploading a zip file to the remote server for testing
        String localZipFilePath = createTestZipFile("/local/test.zip");
        channelSftp.put(localZipFilePath, "/remote/input/path/test.zip");

        channelSftp.disconnect();
        session.disconnect();
    }

    private void createRemoteDirectory(ChannelSftp channelSftp, String dirPath) throws SftpException {
        try {
            channelSftp.mkdir(dirPath);
        } catch (SftpException e) {
            // Ignore if directory already exists
        }
    }

    private String createTestZipFile(String zipFilePath) throws Exception {
        File zipFile = new File(zipFilePath);
        FileUtil.createDirectoryIfNotExists(zipFile.getParent());
        try (OutputStream os = new FileOutputStream(zipFile)) {
            ZipUtil.createZipWithTestFiles(zipFilePath);
        }
        return zipFilePath;
    }

    @When("the retrieveData method is called")
    public void whenRetrieveDataMethodIsCalled() throws Exception {
        SshService sshService = new SshService();
        result = sshService.retrieveData(spaceCollector, "01012021", "auditTopic");
    }

    @Then("all files and directories are retrieved")
    public void thenAllFilesAndDirectoriesAreRetrieved() {
        // Assert that the files and directories are retrieved in the local output path
        Path localOutputPath = Paths.get(spaceCollector.getOutputFilePath());
        Assert.assertTrue(Files.exists(localOutputPath));
        Assert.assertTrue(Files.exists(localOutputPath.resolve("test.zip")));

        // Additional checks for specific files and directories can be added here
    }

    @Then("the zip files are extracted and their contents are processed")
    public void thenZipFilesAreExtractedAndTheirContentsAreProcessed() {
        // Assert that zip files are extracted and their contents are processed
        Path extractedPath = Paths.get(spaceCollector.getOutputFilePath(), "test");
        Assert.assertTrue(Files.exists(extractedPath.resolve("test.txt")));
    }

    @Then("all files are pushed to S3")
    public void thenAllFilesArePushedToS3() {
        // Assert that files are pushed to S3
        // This would normally require a check with the S3 service
        // Mocking the check for testing purposes
        Assert.assertTrue(true);
    }

    @Then("audit messages are sent for successful and failed collections")
    public void thenAuditMessagesAreSentForSuccessfulAndFailedCollections() {
        // Assert that audit messages are sent
        // This would normally require a check with the Kafka service
        // Mocking the check for testing purposes
        Assert.assertTrue(true);
    }
}
