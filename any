import com.jcraft.jsch.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.TimeUnit;
import org.slf4j.*;

public class CustomSSHCollector {

    private static final Logger LOGGER = LoggerFactory.getLogger(CustomSSHCollector.class);

    public boolean retrieveData(SpaceCollector sp, String dateReceived, String auditTopic) throws Exception {
        LOGGER.info("Entered SSH service");
        String sshUsername = sp.getUserName();
        String sshHost = sp.getUrl();
        String sshPassword = sp.getPassword();
        int port = sp.getPort().intValue();
        JSch jsch = getJsch(sshHost, sshPassword);
        Session session = getSession(sshUsername, sshHost, sshPassword, port, jsch);
        session.connect();
        ChannelSftp channelSftp = null;
        try {
            String remoteDirectory = FileUtil.getDirectory(sp.getInputFilePath());
            String localDirectory = FileUtil.getDirectory(sp.getOutputFilePath());
            LOGGER.info("remoteDirectory : " + remoteDirectory + " localDirectory : " + localDirectory);
            channelSftp = getChannelSftp(session, remoteDirectory);
            // Recursively retrieve and process files and directories
            retrieveAndProcessDirectory(sp, dateReceived, auditTopic, remoteDirectory, localDirectory, channelSftp);

            // Clean up old files
            cleanUpOldFiles(localDirectory, channelSftp, remoteDirectory);

        } finally {
            if (channelSftp != null) {
                channelSftp.disconnect();
            }
            if (session != null) {
                session.disconnect();
            }
        }
        return true;
    }

    private void retrieveAndProcessDirectory(SpaceCollector sp, String dateReceived, String auditTopic,
                                             String remoteDirectory, String localDirectory, ChannelSftp channelSftp) throws Exception {
        Vector<ChannelSftp.LsEntry> files = channelSftp.ls(remoteDirectory);
        LOGGER.info("Number of files/Directories found in " + remoteDirectory + ":" + files.size());
        Map<String, String> auditStatusMap = getAuditStatusMap(files, remoteDirectory);

        for (ChannelSftp.LsEntry file : files) {
            if (!file.getAttrs().isDir()) {
                LOGGER.info("found file in LS: " + file.getFilename());
                String filePath = remoteDirectory + "/" + file.getFilename(); // Use absolute file path
                LOGGER.info("filePath for lookup in COLLECTION_AUDIT: " + filePath);
                String status = auditStatusMap.get(filePath);
                if (status == null || "COLLECTION_FAILED".equals(status)) {
                    try {
                        String outputFile = localDirectory + "/" + file.getFilename();
                        LOGGER.info("in filePath : " + filePath + " out filePath : " + outputFile);
                        FileUtil.downloadFile(outputStreamCreator.create(outputFile), channelSftp.get(filePath),
                                filePath, outputFile, sp.getOutputFilePath());
                        processDownloadedFile(sp, dateReceived, auditTopic, outputFile, localDirectory);
                    } catch (Exception e) {
                        CollectionAudit audit = createAuditObject(sp,
                                filePath, JobStatus.COLLECTION_FAILED.toString(), e.getMessage());
                        kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit), "",
                                auditTopic);
                        LOGGER.error("Error on retrieveData {}", e);
                    }
                }
            } else {
                if (!".".equals(file.getFilename()) && !"..".equals(file.getFilename())) {
                    LOGGER.info("DIR found : " + file.getFilename());
                    String subRemoteDirectory = remoteDirectory + "/" + file.getFilename();
                    String subLocalDirectory = localDirectory + "/" + file.getFilename();
                    FileUtil.createDirectoryIfNotExists(subLocalDirectory);
                    retrieveAndProcessDirectory(sp, dateReceived, auditTopic, subRemoteDirectory, subLocalDirectory, channelSftp);
                }
            }
        }
    }

    private void processDownloadedFile(SpaceCollector sp, String dateReceived, String auditTopic,
                                       String outputFile, String localDirectory) throws Exception {
        List<String> filesList = new ArrayList<>();
        LOGGER.info("Processing downloaded file: " + outputFile);
        if (ZipUtil.isZipFile(outputFile)) {
            LOGGER.info("Zip file found: " + outputFile);
            String fileNameWithoutExtn = FileUtil.getFileNameWithoutExtn(outputFile);
            FileUtil.createDirectoryIfNotExists(localDirectory + "/" + fileNameWithoutExtn);
            ZipUtil.extract(outputFile, localDirectory + "/" + fileNameWithoutExtn);
            filesList.addAll(FileUtil.readFilesInDirectory(localDirectory + "/" + fileNameWithoutExtn));
        } else {
            LOGGER.info("non Zip file found: " + outputFile);
            filesList.add(outputFile);
        }
        for (String fileName : filesList) {
            Path insideFilePath = Paths.get(fileName);
            Path folderPath = Paths.get(sp.getOutputFilePath()).relativize(insideFilePath.getParent());
            String unixBasedPath = folderPath.toString().replace("\\", "/");
            String key = String.format("%s/%s/%s/%s/%s",
                    ProfileCheckConfig.activeProfile,
                    sp.getFileType(),
                    sp.getUrl(),
                    dateUtil.getDateInMMddyyyy(),
                    !StringUtils.isBlank(unixBasedPath)
                            ? (unixBasedPath.toString() + "/" + insideFilePath.getFileName())
                            : insideFilePath.getFileName());
            System.out.println("**************************");
            System.out.println("Filename: " + fileName);
            System.out.println("Key: " + key);
            System.out.println("folderPath: " + folderPath);
            System.out.println("Inside File Path: " + insideFilePath);
            System.out.println("**************************");
            s3Service.pushToS3(fileName, key);
            CollectionAudit audit = createAuditObject(sp,
                    key, JobStatus.COLLECTION_SUCCESSFUL.toString(), "");
            kafkaProducerService.writeMessage(collectorUtil.buildAuditQueueJSON(audit),
                    "", auditTopic);
            // Check if the file is an archive and process it further
            if (ZipUtil.isZipFile(fileName)) {
                String nestedFileNameWithoutExtn = FileUtil.getFileNameWithoutExtn(fileName);
                FileUtil.createDirectoryIfNotExists(localDirectory + "/" + nestedFileNameWithoutExtn);
                ZipUtil.extract(fileName, localDirectory + "/" + nestedFileNameWithoutExtn);
                List<String> nestedFilesList = FileUtil.readFilesInDirectory(localDirectory + "/" + nestedFileNameWithoutExtn);
                for (String nestedFile : nestedFilesList) {
                    processDownloadedFile(sp, dateReceived, auditTopic, nestedFile, localDirectory);
                }
            }
        }
    }

    private void cleanUpOldFiles(String localDirectory, ChannelSftp channelSftp, String remoteDirectory) throws SftpException {
        long currentTime = System.currentTimeMillis();
        long cutoffTime = currentTime - TimeUnit.MILLISECONDS.convert(1, TimeUnit.DAYS); // 24 hours ago

        // Clean up local directory
        Files.walk(Paths.get(localDirectory))
            .filter(Files::isRegularFile)
            .forEach(path -> {
                try {
                    if (Files.getLastModifiedTime(path).toMillis() < cutoffTime) {
                        Files.delete(path);
                        LOGGER.info("Deleted local file: " + path.toString());
                    }
                } catch (Exception e) {
                    LOGGER.error("Error deleting local file: " + path.toString(), e);
                }
            });

        // Clean up remote directory
        Vector<ChannelSftp.LsEntry> files = channelSftp.ls(remoteDirectory);
        for (ChannelSftp.LsEntry file : files) {
            if (!file.getAttrs().isDir()) {
                long fileModificationTime = file.getAttrs().getMTime() * 1000L; // Convert to milliseconds
                if (fileModificationTime < cutoffTime) {
                    channelSftp.rm(remoteDirectory + "/" + file.getFilename());
                    LOGGER.info("Deleted remote file: " + remoteDirectory + "/" + file.getFilename());
                }
            } else {
                if (!".".equals(file.getFilename()) && !"..".equals(file.getFilename())) {
                    String subRemoteDirectory = remoteDirectory + "/" + file.getFilename();
                    cleanUpOldFiles(subRemoteDirectory, channelSftp, subRemoteDirectory);
                }
            }
        }
    }

    // Assuming methods like getJsch, getSession, getChannelSftp, getAuditStatusMap, createAuditObject, etc., are already implemented
}
