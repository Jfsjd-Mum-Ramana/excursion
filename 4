Here is the remaining code for implementing the GraphQL-based APIs, including the ScatterPlotDataDTO, service, repository, and other necessary components:

1. DTO (Data Transfer Object) - ScatterPlotDataDTO

The ScatterPlotDataDTO class represents the data that will be returned in the GraphQL responses for scatter plot queries.

package com.example.dto;

public class ScatterPlotDataDTO {

    private String collectionName;
    private String date;
    private Long yValue;

    // Constructor
    public ScatterPlotDataDTO(String collectionName, String date, Long yValue) {
        this.collectionName = collectionName;
        this.date = date;
        this.yValue = yValue;
    }

    // Getters and setters
    public String getCollectionName() {
        return collectionName;
    }

    public void setCollectionName(String collectionName) {
        this.collectionName = collectionName;
    }

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    public Long getyValue() {
        return yValue;
    }

    public void setyValue(Long yValue) {
        this.yValue = yValue;
    }
}

2. Service Layer

The service layer is where the business logic is handled. This is responsible for calling the repository methods and processing the data.

package com.example.service;

import com.example.dto.ScatterPlotDataDTO;
import com.example.repository.UcspRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class DataService {

    private final UcspRepository ucspRepository;

    @Autowired
    public DataService(UcspRepository ucspRepository) {
        this.ucspRepository = ucspRepository;
    }

    public List<ScatterPlotDataDTO> getScatterPlotData(String protocol, String dataType) {
        return ucspRepository.getScatterPlotData(protocol, dataType);
    }

    public List<ScatterPlotDataDTO> filterDataByProtocol(String protocol) {
        return ucspRepository.filterDataByProtocol(protocol);
    }

    public List<String> getAvailableProtocols() {
        return ucspRepository.getAvailableProtocols();
    }
}

3. Repository Layer

In the repository layer, the methods interact with the database using JPQL queries to fetch the required data.

package com.example.repository;

import com.example.dto.ScatterPlotDataDTO;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface UcspRepository extends CrudRepository<UCSPAlarmInventory, Long> {

    @Query("SELECT new com.example.dto.ScatterPlotDataDTO(c.collectionName, m.date, m.numberOfMsgs) " +
           "FROM UCSPAlarmInventory c " +
           "JOIN UCSPAlarmMetrics m ON c.collectionName = m.collectionName " +
           "WHERE c.ucgSource = :protocol AND m.dataType = :dataType")
    List<ScatterPlotDataDTO> getScatterPlotData(String protocol, String dataType);

    @Query("SELECT new com.example.dto.ScatterPlotDataDTO(c.collectionName, m.date, m.numberOfMsgs) " +
           "FROM UCSPAlarmInventory c " +
           "JOIN UCSPAlarmMetrics m ON c.collectionName = m.collectionName " +
           "WHERE c.ucgSource = :protocol")
    List<ScatterPlotDataDTO> filterDataByProtocol(String protocol);

    @Query("SELECT DISTINCT c.ucgSource FROM UCSPAlarmInventory c")
    List<String> getAvailableProtocols();
}

4. Controller Layer

The controller layer is where the GraphQL queries are mapped to resolver methods.

package com.example.controller;

import com.example.dto.ScatterPlotDataDTO;
import com.example.service.DataService;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
public class DataController {

    private final DataService dataService;

    public DataController(DataService dataService) {
        this.dataService = dataService;
    }

    @QueryMapping
    public List<ScatterPlotDataDTO> getScatterPlotData(@Argument String protocol, @Argument String dataType) {
        return dataService.getScatterPlotData(protocol, dataType);
    }

    @QueryMapping
    public List<ScatterPlotDataDTO> filterDataByProtocol(@Argument String protocol) {
        return dataService.filterDataByProtocol(protocol);
    }

    @QueryMapping
    public List<String> getAvailableProtocols() {
        return dataService.getAvailableProtocols();
    }
}

5. Application Properties (application.properties)

Ensure that your application is configured to run Spring Boot with the necessary database and GraphQL support.

# Database configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/your_database
spring.datasource.username=your_username
spring.datasource.password=your_password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# GraphQL endpoint
spring.graphql.schema.locations=classpath:graphql/schema.graphqls

6. GraphQL Schema (schema.graphqls)

This is where you define the GraphQL schema, including the queries and their return types.

type Query {
    getScatterPlotData(protocol: String, dataType: String): [ScatterPlotDataDTO]
    filterDataByProtocol(protocol: String): [ScatterPlotDataDTO]
    getAvailableProtocols: [String]
}

type ScatterPlotDataDTO {
    collectionName: String
    date: String
    yValue: Long
}

7. Test GraphQL Queries

To test the queries in your GraphQL client (such as GraphiQL, Postman, or Insomnia), you would use queries like the following:

Get Scatter Plot Data:

query {
  getScatterPlotData(protocol: "SNMP", dataType: "number_of_msgs") {
    collectionName
    date
    yValue
  }
}

Filter Data by Protocol:

query {
  filterDataByProtocol(protocol: "SNMP") {
    collectionName
    date
    yValue
  }
}

Get Available Protocols:

query {
  getAvailableProtocols
}

Summary of Files:

1. ScatterPlotDataDTO.java: The DTO class that holds the response data for GraphQL queries.


2. DataService.java: The service layer that calls the repository methods to retrieve data.


3. UcspRepository.java: The repository with JPQL queries to interact with the database.


4. DataController.java: The controller layer that maps GraphQL queries to service methods.


5. application.properties: Configuration for your Spring Boot application.


6. schema.graphqls: The GraphQL schema that defines your queries and types.



This setup should allow you to execute GraphQL queries like getScatterPlotData, filterDataByProtocol, and getAvailableProtocols, with data fetched from your database and returned as part of the response.

