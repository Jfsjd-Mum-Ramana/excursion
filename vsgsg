package com.verizon.ucs.restapi.controllers;

import com.verizon.ucs.restapi.dto.ApiRequest;
import com.verizon.ucs.restapi.dto.TrendsRequest;
import com.verizon.ucs.restapi.model.AvgNetworkCoverageDTO;
import com.verizon.ucs.restapi.model.AvgNetworkCoverageMap;
import com.verizon.ucs.restapi.model.Device;
import com.verizon.ucs.restapi.model.Trends;
import com.verizon.ucs.restapi.model.UcspProject;
import com.verizon.ucs.restapi.service.UCSPService;
import graphql.GraphQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.SchemaMapping;
import org.springframework.stereotype.Controller;

import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Controller interface for UCS Portal Application with JPA
 */
@Controller
public class UCSPController {
    private static final Logger logger = LoggerFactory.getLogger(UCSPController.class);

    @Autowired
    private UCSPService uCSPService;

    @QueryMapping(value = "searchDevices")
    public List<Device> getFilteredDevices(@Argument ApiRequest apiRequest) {
        return uCSPService.searchDevices(apiRequest);
    }

    @QueryMapping(value = "allDevices")
    public List<Device> getAllDevices() {
        return uCSPService.getAllDevices();
    }

    @SchemaMapping(typeName = "Query", value = "uniqueModels")
    public List<String> getUniqueModels() {
        return uCSPService.getUniqueValues().get("models");
    }

    @QueryMapping(value = "uniqueVendors")
    public List<String> getUniqueVendors() {
        return uCSPService.getUniqueValues().get("vendors");
    }

    @QueryMapping(value = "dailyTrends")
    public List<Trends> getTrends(@Argument TrendsRequest trendsRequest) {
        return uCSPService.getDailyTrends(trendsRequest);
    }

    @QueryMapping
    public List<String> uniqueNetworks() {
        return uCSPService.getUniqueValues().get("networks");
    }

    @QueryMapping(value = "uniqueUCSPProjects")
    public List<UcspProject> getUniqueProjects() {
        List<UcspProject> ucgProjects = uCSPService.getUniqueProjects();
        return ucgProjects;
    }

    @QueryMapping(value = "uniqueUCGSources")
    public List<String> getUniqueUCGSources() {
        List<String> ucgSources = uCSPService.getUniqueUCGSources();
        return ucgSources;
    }

    @QueryMapping(value = "uniqueUCGSourcesByProject")
    public List<UcspProject> getUniqueUCGSourcesByProject(@Argument Long projectId) {
        try {
            return uCSPService.getUniqueUCGSourcesByProject(projectId);
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching UCG Sources", e);
            throw new GraphQLException("Database error: Unable to fetch UCG Sources for project ID: " + projectId);
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }
    
    @QueryMapping
    public List<String> uniqueNetworksByProtocol() {
        return uCSPService.uniqueNetworksByProtocol().get("snmp");
    }
    
    @QueryMapping
    public List<String> uniqueDevicesByNetwork(@Argument String network) {
        return uCSPService.uniqueDevicesByNetwork(network);
    }
    
    @QueryMapping(value = "avgNetworkByCoverage")
    public List<AvgNetworkCoverageDTO> avgNetworkByCoverage(@Argument String network,
    		@Argument String fromDate,@Argument String toDate,@Argument String device) {
        try {
        	  Map<String, AvgNetworkCoverageDTO> detailedData = uCSPService.avgNetworkByCoverage(network,fromDate,toDate,device);
        	   return detailedData.values().stream()
                       .map(dto -> {
                           dto.setTotalCoverage(Double.parseDouble(dto.getFormattedTotalCoverage()));
                           return dto;
                       })
                       .sorted(Comparator.comparing(AvgNetworkCoverageDTO::getDate))
                       .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching network coverage", e);
            throw new GraphQLException("Database error: Unable to fetch network coverage for network: " + network);
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }
}




package com.verizon.ucs.restapi.service;

import com.verizon.ucs.restapi.dto.ApiRequest;
import com.verizon.ucs.restapi.dto.TrendsRequest;
import com.verizon.ucs.restapi.model.AvgNetworkCoverageDTO;
import com.verizon.ucs.restapi.model.CoverageData;
import com.verizon.ucs.restapi.model.Device;
import com.verizon.ucs.restapi.model.Trends;
import com.verizon.ucs.restapi.model.UcspProject;
import com.verizon.ucs.restapi.repository.UCSPProjectsRepository;
import com.verizon.ucs.restapi.repository.UCSPRepository;
import com.verizon.ucs.restapi.repository.UCSPTrendsRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.stereotype.Service;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class UCSPService {

	private static final Logger logger = LoggerFactory.getLogger(UCSPService.class);

	@Autowired
	private UCSPRepository uCSPRepository;

	@Autowired
	private UCSPTrendsRepository uCSPTrendsRepository;

	@Autowired
	private UCSPProjectsRepository ucspProjectsRepository;
	
	public List<UcspProject> getUniqueUCGSourcesByProject(Long projectId) {
		try {
			List<UcspProject> ucgSources = ucspProjectsRepository.findDistinctUCGSourcesByProject(projectId);
			if (ucgSources == null || ucgSources.isEmpty()) {
				throw new RuntimeException("No UCG Sources found for the given project ID: " + projectId);
			}
			return ucgSources;
		} catch (Exception e) {
			logger.error("Error in service method getUniqueUCGSourcesByProject", e);
			throw e;
		}
	}

	public List<Device> searchDevices(ApiRequest params) {
		if (params.getDeviceName() != null && !params.getDeviceName().isEmpty()) {
			return uCSPRepository.findByDeviceNameIgnoreCase(params.getDeviceName());
		}
		if (params.getLoopback() != null && !params.getLoopback().isEmpty()) {
			return uCSPRepository.findByLoopbackIgnoreCase(params.getLoopback());
		}
		if (params.getNetwork() != null && !params.getNetwork().isEmpty()) {
			return uCSPRepository.findByNetworkIgnoreCase(params.getNetwork());
		}
		if (params.getVendor() != null && !params.getVendor().isEmpty()) {
			return uCSPRepository.findByVendorIgnoreCase(params.getVendor());
		}
		if (params.getModel() != null && !params.getModel().isEmpty()) {
			return uCSPRepository.findByModelIgnoreCase(params.getModel());
		}
		return null;
	}

	public List<Trends> getDailyTrends(TrendsRequest params) {
		return uCSPTrendsRepository.findDailyTrends(params.getUcgSourceID(), params.getFromDate(), params.getToDate());
	}

	public Map<String, List<String>> getUniqueValues() {
		Map<String, List<String>> uniqueValues = new HashMap<>();
		uniqueValues.put("models", uCSPRepository.findDistinctModels());
		uniqueValues.put("vendors", uCSPRepository.findDistinctVendors());
		uniqueValues.put("networks", uCSPRepository.findDistinctNetworks());
		return uniqueValues;
	}
	public List<String> getUniqueUCGSources(){
		return uCSPRepository.findDistinctUCGSources();
	}
	public List<Device> getAllDevices() {
		return uCSPRepository.findAll();
	}

	public List<UcspProject> getUniqueProjects() {
		return ucspProjectsRepository.findUniqueProjects();
	}
	public Map<String, List<String>> uniqueNetworksByProtocol() {
		Map<String, List<String>> uniqueValues = new HashMap<>();
		uniqueValues.put("snmp", uCSPRepository.uniqueNetworksBySNMPprotocol());
		return uniqueValues;
	}
	
	public List<String> uniqueDevicesByNetwork(String network) {
		return uCSPRepository.getUniqueDevicesByNetwork(network);
	}
	
	public Map<String, AvgNetworkCoverageDTO> avgNetworkByCoverage(String networkName,String fromDate,String toDate,String device) throws ParseException {
        Map<String, AvgNetworkCoverageDTO> detailedData = new HashMap<>();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

        List<Map<String, Object>> results = uCSPRepository.avgNetworkByCoverage(networkName,dateFormat.parse(fromDate),dateFormat.parse(toDate),device);

        for (Map<String, Object> result : results) {
            String date = dateFormat.format(result.get("date"));
            String time = (String) result.get("time");
            double sumOfCoverage = ((Number) result.get("sumOfCoverage")).doubleValue();

            CoverageData coverageData = new CoverageData(time, sumOfCoverage);

            detailedData
                .computeIfAbsent(date, k -> new AvgNetworkCoverageDTO(date))
                .addCoverageData(coverageData);
            /*detaileddata
                .computeifabsent(date, k -> new avgnetworkcoveragedto(date, 0.0, new arraylist<>()))
                .getCoveragedatalist().add(coveragedata);
            detaileddata.get(date).setTotalcoverage(detaileddata.get(date).getTotalcoverage() + sumofcoverage);
            */
        }
        logger.debug("detailedData {}",detailedData);
        return detailedData;
    }

}




package com.verizon.ucs.restapi.repository;

import java.util.Date;
import java.util.List;
import java.util.Map;

import com.verizon.ucs.restapi.model.Trends;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.graphql.data.method.annotation.Argument;

import com.verizon.ucs.restapi.model.AvgNetworkCoverageDTO;
import com.verizon.ucs.restapi.model.Device;

public interface UCSPRepository extends JpaRepository<Device, String> {

	List<Device> findByDeviceNameIgnoreCase(String deviceName);

	List<Device> findByLoopbackIgnoreCase(String loopback);

	List<Device> findByNetworkIgnoreCase(String network);

	List<Device> findByVendorIgnoreCase(String vendor);

	List<Device> findByModelIgnoreCase(String model);

	@Query("SELECT DISTINCT d.model FROM Device d")
	List<String> findDistinctModels();

	@Query("SELECT DISTINCT d.vendor FROM Device d")
	List<String> findDistinctVendors();

	@Query("SELECT DISTINCT d.network FROM Device d")
	List<String> findDistinctNetworks();

	@Query(nativeQuery=true, value="SELECT DISTINCT u.ucg_source FROM ucsp_ucgsources u")
	List<String> findDistinctUCGSources();
	
	@Query(nativeQuery=true, value="SELECT DISTINCT network FROM proto_gw_ntwk")
	List<String> uniqueNetworksBySNMPprotocol();
	
    @Query(nativeQuery = true, value = "SELECT network, CAST(date_hour AS DATE) as date, TO_CHAR(date_hour, 'HH24:MI') as time, SUM(coverage) as sumOfCoverage " +
            "FROM avg_network_coverage WHERE network = :network AND CAST(date_hour AS DATE) BETWEEN :fromDate AND :toDate " +
            " and (:device is null or :device = '' or device_name=:device) "+
            "GROUP BY network, CAST(date_hour AS DATE), TO_CHAR(date_hour, 'HH24:MI') " +
            "ORDER BY network, CAST(date_hour AS DATE), TO_CHAR(date_hour, 'HH24:MI')")
    List<Map<String, Object>> avgNetworkByCoverage(@Param("network") String network,
    		@Param("fromDate") Date fromDate,@Param("toDate") Date toDate,@Param("device") String device);
    
	@Query(nativeQuery=true, value="select distinct device_name from avg_network_coverage anc where network = :network "
			//+ "and device_name IS NOT NULL AND device_name != '';")
			+ " order by device_name")
	List<String> getUniqueDevicesByNetwork(@Param("network") String network);
	
	/*List<Device> findByDeviceNameIgnoreCaseOrLoopbackIgnoreCaseOrNetworkIgnoreCaseOrVendorIgnoreCaseOrModelIgnoreCase(
			String deviceName, String loopback, String network, String vendor, String model);

	List<Device> findByDeviceNameContainingIgnoreCaseOrLoopbackContainingIgnoreCaseOrNetworkContainingIgnoreCaseOrVendorContainingIgnoreCaseOrModelContainingIgnoreCase(
			String deviceName, String loopback, String network, String vendor, String model);

	 * @Query("SELECT d FROM Device d WHERE " +
	 * "LOWER(d.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
	 * "LOWER(d.ip) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
	 * "LOWER(d.network) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
	 * "LOWER(d.vendor) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
	 * "LOWER(d.model) LIKE LOWER(CONCAT('%', :searchTerm, '%'))") List<Device>
	 * search(@Param("searchTerm") String searchTerm);
	 */
}


These are the classes for backend include all of the API's here
