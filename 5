package com.verizon.ucs.service;

import org.springframework.stereotype.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;

import com.verizon.ucs.model.DataWrapperDTO;
import com.verizon.ucs.properties.DbProperties;
import com.verizon.ucs.util.RestTemplateCustomizer;

@Component
public class TtlScheduler {
    private static final Logger logger = LoggerFactory.getLogger(TtlScheduler.class);

    @Autowired
    private RestTemplateCustomizer restTemplateCustomizer;

    @Autowired
    private DbProperties databaseConfig;

    @Scheduled(cron = "${scheduler.ttl.cron}") // Run based on cron expression from YAML
    public void scheduleCallFunction() {
        String functionName = databaseConfig.getTransactionDeleteFunctionName();
        logger.info("Starting transaction deletion using function: {}", functionName);

        try {
            DataWrapperDTO dto = new DataWrapperDTO();
            dto.setParameterList(new String[]{"value"}); // Function requires an argument
            dto.setFunctionName(functionName);

            logger.info("Sending request with DTO: {}", dto);

            // Call API and get response as String
            String responseBody = restTemplateCustomizer.callApi(dto);

            logger.info("Raw API Response Body: {}", responseBody);

            // Log response details
            parseAndLogResponse(responseBody);

        } catch (HttpClientErrorException e) {
            logger.error("HTTP Error: Status Code = {}, Response Body = {}", e.getStatusCode(), e.getResponseBodyAsString());
        } catch (HttpServerErrorException e) {
            logger.error("Server Error: Response Body = {}", e.getResponseBodyAsString());
        } catch (Exception e) {
            logger.error("Unexpected error while deleting transactions.", e);
        }
    }

    private void parseAndLogResponse(String responseBody) {
        if (responseBody == null || responseBody.isEmpty()) {
            logger.error("Empty response received from function call.");
            return;
        }

        try {
            // Log response directly
            logger.info("Function execution result: {}", responseBody);
        } catch (Exception e) {
            logger.error("Error while parsing response: {}", responseBody, e);
        }
    }
}