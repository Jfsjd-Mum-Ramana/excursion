import { Box, Button, Card, CardContent, Container, FormControl, Grid, InputLabel, MenuItem, Select, SelectChangeEvent, TextField, Typography } from '@mui/material';
import { DataGrid, GridColDef, GridToolbar } from '@mui/x-data-grid';
import axios from 'axios';
import React, { useEffect, useState } from 'react';
import { authenticate, getToken } from '../auth';
import { __UCS_GET_DEVICE_DEATIL_BY_TYPE__, __UCS_GRAPHQL_URL__ } from '../api-endpoints';
import { UNIQUE_MODELS_QUERY, UNIQUE_VENDORS_QUERY, UNIQUE_NETWORKS_QUERY, GET_DEVICE_DETAILS } from '../graphQL/graphqlQueries';

interface Device {
    id: number;
    deviceName: string;
    model: string;
    loopback: string;
    status: string;
    vendor: string;
    router_type: string;
    poller_cluster: string;
    poll_interval: string;
    network: string;
    last_update: string;
    phys_ip_address: string;
}
interface ActualApiResponse {
    status: number,
    message: string,
    data: DeviceResponse[];
    error: string | null;
}
interface DeviceResponse {
    deviceName: string,
    name: string,
    asn: string,
    subAsn: string,
    model: string,
    loopback: string,
    status: string,
    hubName: string,
    vendor: string,
    routerType: string,
    usage: string,
    snmpCommString: string,
    codeVersion: string,
    subtechnology: string,
    pollerCluster: string,
    pollInterval: string,
    network: string,
    maxOids: string,
    maxPduSize: string,
    maxRetries: string,
    maxPduPerSec: string,
    wugThreads: string,
    uptime: string,
    indxType: string,
    pollerInterval: string,
    lastUpdate: string,
    pollerclusterlov: string,
    pollerclusteralarm: string,
    physIpAddress: string,
    locationCode: string,
    physIp: string,
    functionalType: string,
    shelfType: string,
    telemMngdNetwork: string,
    domainFlag: string
}
interface ApiRequest {
    deviceName: string;
    model: string;
    loopback: string;
    vendor: string;
    network: string;
}



const DashboardGridData = () => {

    const [selectedDeviceName, setSelectedDeviceName] = useState<string>('');
    const [selectedDeviceIp, setSelectedDeviceIp] = useState<string>('');
    const [selectedDeviceModel, setSelectedDeviceModel] = useState<string>('');
    const [selectedDeviceVendor, setSelectedDeviceVendor] = useState<string>('');
    const [selectedDeviceNetwork, setSelectedDeviceNetwork] = useState<string>('');
    const [data, setData] = useState<Device[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    // const [deviceNames, setDeviceNames] = useState<string[]>([]);
    // const [deviceIps, setDeviceIps] = useState<string[]>([]);
    const [deviceModels, setDeviceModels] = useState<string[]>([]);
    const [deviceVendors, setDeviceVendors] = useState<string[]>([]);
    const [deviceNetworks, setDeviceNetworks] = useState<string[]>([]);


    useEffect(() => {
        const fetchDropDownData = async () => {
            try {
                //     const pw = __UCS_API_PW__;
                //    await authenticate("Eclipse", __UCS_API_PW__);
                //     const token = getToken();
                //     const headers = { Authorization: `Bearer ${token}` }
                const responses = await Promise.all([
                    await axios.post(__UCS_GRAPHQL_URL__, {
                        query: UNIQUE_MODELS_QUERY,
                    }),
                    await axios.post(__UCS_GRAPHQL_URL__, {
                        query: UNIQUE_VENDORS_QUERY,
                    }),
                    await axios.post(__UCS_GRAPHQL_URL__, {
                        query: UNIQUE_NETWORKS_QUERY,
                    }),

                ]);

                setDeviceModels(responses[0].data.data.uniqueModels);
                setDeviceVendors(responses[1].data.data.uniqueVendors);
                setDeviceNetworks(responses[2].data.data.uniqueNetworks);
            } catch (error) {
                console.error('Error fetching dropdown data', error);
            }
        };

        fetchDropDownData();

    }, []);

    const handleSelectChange = (setter: React.Dispatch<React.SetStateAction<string>>, resetOthers: () => void) => (
        event: SelectChangeEvent<string>) => {
        resetOthers();
        setter(event.target.value as string);
    };

    const handleTextFieldChange = (setter: React.Dispatch<React.SetStateAction<string>>, resetOthers: () => void) => (
        event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        resetOthers();
        setter(event.target.value);
    };

    const resetSelections = () => {
        setSelectedDeviceName('');
        setSelectedDeviceIp('');
        setSelectedDeviceModel('');
        setSelectedDeviceVendor('');
        setSelectedDeviceNetwork('');
    }

    const handleSubmit = async () => {
        setLoading(true);
        const apiRequest: ApiRequest = {
            deviceName: selectedDeviceName,
            model: selectedDeviceModel,
            loopback: selectedDeviceIp,
            vendor: selectedDeviceVendor,
            network: selectedDeviceNetwork,
        };
        try {
            const token = getToken();
            const headers = { Authorization: `Bearer ${token}` }
            if (selectedDeviceName || selectedDeviceIp || selectedDeviceModel || selectedDeviceVendor || selectedDeviceNetwork) {
                //const response = await axios.get<ActualApiResponse>(__UCS_GET_DEVICE_DEATIL_BY_TYPE__, {params:apiRequest});
                const query = GET_DEVICE_DETAILS(selectedDeviceName, selectedDeviceModel, selectedDeviceIp, selectedDeviceVendor, selectedDeviceNetwork);
                const response = await axios.post(__UCS_GRAPHQL_URL__, {
                    query
                });
                const selectedDevices = response.data.data.searchDevices.map((device: DeviceResponse, index: number) => ({
                    id: index,
                    deviceName: device.deviceName,
                    model: device.model,
                    loopback: device.loopback,
                    status: device.status,
                    vendor: device.vendor,
                    router_type: device.routerType,
                    poller_cluster: device.pollerCluster,
                    poll_interval: device.pollerInterval,
                    network: device.network,
                    last_update: device.lastUpdate,
                    phys_ip_address: device.physIp,
                })
                );
                setData(selectedDevices);

            }
        } catch (error) {
            console.error('Error fetching data', error);
        } finally {
            setLoading(false);
        }
    };

    const columns: GridColDef[] = [
        { field: 'deviceName', headerName: 'DeviceName', minWidth: 150, flex: 1 },
        { field: 'model', headerName: 'DeviceModel', minWidth: 150, flex: 1 },
        { field: 'loopback', headerName: 'Loopback', minWidth: 150, flex: 1 },
        { field: 'status', headerName: 'Status', minWidth: 150, flex: 1 },
        { field: 'vendor', headerName: 'Vendor', minWidth: 150, flex: 1 },
        { field: 'router_type', headerName: 'RouterType', minWidth: 150, flex: 1 },
        { field: 'poller_cluster', headerName: 'PollerCluster', minWidth: 150, flex: 1 },
        { field: 'poll_interval', headerName: 'PollInterval', minWidth: 150, flex: 1 },
        { field: 'network', headerName: 'Network', minWidth: 150, flex: 1 },
        { field: 'last_update', headerName: 'LastUpdate', minWidth: 150, flex: 1 },
        { field: 'phys_ip_address', headerName: 'PhysIpAdd', minWidth: 150, flex: 1 },

    ];

    return (
        <Container maxWidth={false}>
            {/* <Typography gutterBottom  variant="titleXL" className="header" fontWeight={"bold"} gap={"100px"} paddingTop={"15px"}>
                UCS Portal
            </Typography> */}
            <Card sx={{ boxShadow: 1, border: 1, }}>
                <CardContent>
                    <Grid container spacing={2} alignItems={'flex-end'}>
                        <Grid item xs={12} sm={6} md>
                            <TextField
                                placeholder="Enter Device Name"
                                fullWidth
                                variant="outlined"
                                value={selectedDeviceName}
                                onChange={(event) => handleTextFieldChange(setSelectedDeviceName, resetSelections)(event)}
                                label="Device Name"
                            >
                            </TextField>
                        </Grid>
                        <Grid item xs={12} sm={6} md >
                            <TextField
                                placeholder="Enter Device IP"
                                fullWidth
                                variant="outlined"
                                value={selectedDeviceIp}
                                onChange={(event) => handleTextFieldChange(setSelectedDeviceIp, resetSelections)(event)}
                                label="Device IP"
                            >
                            </TextField>
                        </Grid>
                        <Grid item xs={12} sm={6} md>
                            <FormControl variant="outlined" sx={{ width: '100%', height: '100%' }}>
                                <InputLabel id="device-model-select-label" shrink={true}>Device Model</InputLabel>
                                <Select
                                    labelId="device-model-select-label"
                                    value={selectedDeviceModel}
                                    onChange={(event) => handleSelectChange(setSelectedDeviceModel, resetSelections)(event)}
                                    label="Device Model"
                                >
                                    {deviceModels?.map((model, i) => (
                                        <MenuItem
                                            key={model}
                                            id="deviceModel"
                                            value={model}
                                        >
                                            {model}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>
                        <Grid item xs={12} sm={6} md>
                            <FormControl variant="outlined" sx={{ width: '100%', height: '100%' }}>
                                <InputLabel id="device-vendor-select-label">Device Vendor</InputLabel>
                                <Select
                                    labelId="device-vendor-select-label"
                                    value={selectedDeviceVendor}
                                    onChange={(event) => handleSelectChange(setSelectedDeviceVendor, resetSelections)(event)}
                                    label="Device Vendor"
                                >
                                    {deviceVendors?.map((vendor, i) => (
                                        <MenuItem
                                            key={vendor}
                                            id="deviceVendor"
                                            value={vendor}
                                        >
                                            {vendor}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>
                        <Grid item xs={12} sm={6} md >
                            <FormControl variant="outlined" sx={{ width: '100%', height: '100%' }}>
                                <InputLabel id="device-network-select-label">Device Network</InputLabel>
                                <Select
                                    labelId="device-network-select-label"
                                    value={selectedDeviceNetwork}
                                    onChange={(event) => handleSelectChange(setSelectedDeviceNetwork, resetSelections)(event)}
                                    label="Device Network"
                                >
                                    {deviceNetworks?.map((network, i) => (
                                        <MenuItem
                                            key={network}
                                            id="deviceNetwork"
                                            value={network}
                                        >
                                            {network}
                                        </MenuItem>
                                    ))}
                                </Select>
                            </FormControl>
                        </Grid>
                        <Grid item xs={12} sm={6} md >
                            <Button variant="contained" color="primary" onClick={handleSubmit} disabled={!selectedDeviceName && !selectedDeviceIp && !selectedDeviceModel && !selectedDeviceVendor && !selectedDeviceNetwork}>
                                Submit
                            </Button>
                        </Grid>
                    </Grid>

                </CardContent>
            </Card>
            <Box mt={4} sx={{ width: "100%" }}>
                <DataGrid rows={data} columns={columns}
                    initialState={{
                        pagination: {
                            paginationModel: {
                                pageSize: 10,
                                page: 0
                            }
                        }
                    }}
                    sx={
                        {
                            boxShadow: 1,
                            border: 1,
                        }
                    }
                    pageSizeOptions={[5, 10, 25]}
                    pagination
                    slotProps={{
                        footer: {
                            sx: {
                                justifyContent: "flex-start"
                            }
                        }
                    }}
                    slots={{
                        toolbar: GridToolbar,
                    }}
                    checkboxSelection
                    disableRowSelectionOnClick
                    loading={loading} autoHeight />
            </Box>
        </Container>
    )
}

export default DashboardGridData




import React, { useEffect, useState } from 'react';
import { Box, Container, FormControl, Grid, InputLabel, MenuItem, Select, SelectChangeEvent, TextField, Typography, Autocomplete, Button } from '@mui/material';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import dayjs, { Dayjs } from 'dayjs';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import axios from 'axios';
import { authenticate, getToken } from '../auth';
import { __UCS_GRAPHQL_URL__ } from '../api-endpoints';
import { API_ENDPOINTS } from '../api-endpoints';
import { UNIQUE_UGS_SOURCE_QUERY, UNIQUE_PROJECT_QUERY } from '../graphQL/graphqlQueries';
import LoadingButton from "@mui/lab/LoadingButton";
import { useSnackbar } from '../utils/SnackbarContext';

const S3Audit: React.FC = () => {
    const [projectList, setProjectList] = useState<any[]>([]);
    const [ucgSourceList, setUcgSourceList] = useState<{ id: number, name: string }[]>([]);

    const [selectedProject, setSelectedProject] = useState<any>(null);
    const [selectedDeviceName, setSelectedDeviceName] = useState<string>('');
    const [selectedSearchString, setSelectedSearchString] = useState<string>('');
    const [selectedUCGSource, setSelectedUCGSource] = useState<string>('');
    const [fromDate, setSelectedFromDate] = React.useState<Dayjs>(dayjs().subtract(1, 'day'));
    const [toDate, setSelectedToDate] = React.useState<Dayjs | null>(dayjs());

    const [loading, setLoading] = useState<boolean>(false);
    const [ucgsourceLoading, setUcgsourceLoading] = useState<boolean>(false);

    const [responseData, setResponseData] = useState<string>('');
    const { showSnackbar } = useSnackbar();

    useEffect(() => {
        const fetchProjectData = async () => {
            try {
                const projectResponse = await axios.post(__UCS_GRAPHQL_URL__, {
                    query: UNIQUE_PROJECT_QUERY,
                });
                //console.log("projectResponse",projectResponse);
                if (projectResponse.data?.data?.uniqueUCSPProjects && projectResponse.data.data.uniqueUCSPProjects.length > 0) {
                    setProjectList(projectResponse.data.data.uniqueUCSPProjects);
                }
            } catch (error) {
                showSnackbar('Error fetching project data!');
                console.error('Error fetching project data', error);
            }
        };
        fetchProjectData();

    }, []);

    const handleProjectChange = async (options: any) => {
        //console.log("options ",options.id);
        setSelectedProject(options);
        setUcgsourceLoading(true);
        setSelectedUCGSource('');
        setUcgSourceList([]);
        if (options && options.id) {
            try {
                const ucgSourcesResponse = await axios.post(__UCS_GRAPHQL_URL__, {
                    query: UNIQUE_UGS_SOURCE_QUERY,
                    variables: { projectId: options.id },
                });

                //console.log("ucgSourcesResponse",ucgSourcesResponse);
                if (ucgSourcesResponse.data?.data?.uniqueUCGSourcesByProject && ucgSourcesResponse.data.data.uniqueUCGSourcesByProject.length > 0) {
                    setUcgSourceList(ucgSourcesResponse.data.data.uniqueUCGSourcesByProject);
                } else {
                    showSnackbar('No UCGsource exists for this Project!');
                }
            } catch (error) {
                showSnackbar('Error fetching UCGsource data!');
                console.error('Error fetching UCG source:', error);
            } finally {
                setUcgsourceLoading(false);
            }
        }
    }

    const handleSelectChange = (setter: React.Dispatch<React.SetStateAction<string>>, resetOthers: () => void) => (
        event: SelectChangeEvent<string>) => {
        setter(event.target.value as string);
    };
    const handleTextFieldChange = (setter: React.Dispatch<React.SetStateAction<string>>, resetOthers: () => void) => (
        event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        setter(event.target.value);
    };

    const handleFetchClick = () => {
        setResponseData('');
        const trimmedSearchString = selectedSearchString.trim();
        if (trimmedSearchString.startsWith('{') && trimmedSearchString.endsWith('}')) {
            try {
                const parsedInput = JSON.parse(trimmedSearchString);
                if (parsedInput && typeof parsedInput === 'object') {
                    handleSubmit('json');
                } else {
                    showSnackbar('Invalid input. Please enter a valid JSON string.');
                }
            } catch (error) {
                showSnackbar('Invalid input. Please enter a valid JSON string.');
            }
        } else {
            handleSubmit('text');
        }
    };

    //const dummyData = [{"ucgMessageId":"10.139.126.180_1029","ucgTimestamp":"TC:1723729156855:10.194.236.247/9977;","ucgSource":"HPOVTRAP","ucgRawData":{"pdu":"TRAP[requestID=1208871447, errorStatus=Success(0), errorIndex=0, VBS[1.3.6.1.2.1.1.3.0 = 13 days, 12:30:37.18; 1.3.6.1.6.3.1.1.4.1.0 = 1.3.6.1.4.1.750.501.0.1; 1.3.6.1.4.1.750.501.1.1.1 = 21084251; 1.3.6.1.4.1.750.501.1.1.2 = 07:e8:08:0f:0d:27:0f:07:2b:00:00; 1.3.6.1.4.1.750.501.1.1.3 = IPI; 1.3.6.1.4.1.750.501.1.1.5 = 1; 1.3.6.1.4.1.750.501.1.1.6 = ACTIVE; 1.3.6.1.4.1.750.501.1.1.4 = NOCC VOLTE Day Alerts - PST Time; 1.3.6.1.4.1.750.501.1.1.7.1.1.1 = 1; 1.3.6.1.4.1.750.501.1.1.7.1.2.1 = 20; 1.3.6.1.4.1.750.501.1.1.7.1.3.1 = SGW: Azusa_Vista_SAEGW11(ID: 92676); 1.3.6.1.4.1.750.501.1.1.8 = VOLTE Day Alerts to the NOCC - Maintenance window excluded (6am - 11:55pm PST); 1.3.6.1.4.1.750.501.1.1.13 = 1.27; 1.3.6.1.4.1.750.501.1.1.15 = 1.00; 1.3.6.1.4.1.750.501.1.1.9 = NOCC SNMP Day - PST Time; 1.3.6.1.4.1.750.501.1.1.10 = Public; 1.3.6.1.4.1.750.501.1.1.11 = Gm(S1-U) RTP eNB Gap Duration Ratio Avg (%); 1.3.6.1.4.1.750.501.1.1.12 = 2; 1.3.6.1.4.1.750.501.1.1.14 = >; 1.3.6.1.4.1.750.501.1.1.16 = Absolute; 1.3.6.1.4.1.750.501.1.1.17 = N/A; 1.3.6.1.4.1.750.501.1.1.18 = 22393053; 1.3.6.1.4.1.750.501.1.1.19 = 85000; 1.3.6.1.4.1.750.501.1.1.20 = N/A; 1.3.6.1.4.1.750.501.1.1.21 = N/A; 1.3.6.1.4.1.750.501.1.1.22 = N/A; 1.3.6.1.4.1.750.501.1.1.23 = N/A; 1.3.6.1.4.1.750.501.1.1.24 = N/A; 1.3.6.1.4.1.750.501.1.1.25 = N/A; 1.3.6.1.4.1.750.501.1.1.26 = https://caroirvisap01v.nss.vzwnet.com:443/VoLTE-SIP-RTP-ipi/dynamicDash?drill=%7B%22minSamples%22:%220%22,%22interfaceType%22:%2249%22,%22interfaceBundle%22:%22-1%22,%22fromTime%22:%221723726800000%22,%22toTime%22:%221723729156835%22,%22resolution%22:%22ENTRY%22,%22kpiProtocol%22:%221007%22,%22category%22:%223%22,%22dynamic-ea-dimensionType-1%22:%2220_node%22,%22dynamic-dimension-1%22:%22Azusa_Vista_SAEGW11%22,%22templateName%22:%22ea-trendVolume-kpi%22,%22dashboardName%22:%22ea-element%22,%22trendKpi%22:%228341072%22%7D; 1.3.6.1.4.1.750.501.1.1.27 = N/A]]","sourcePort":54835,"sourceAddress":"10.139.126.180","receiveAddress":"10.194.236.247","receivePort":9977,"community":"public","version":"2","network":"EDN","timestamp":1723729156855},"ucgId":"HPOVTRAP-10.139.126.180-1723729157512","ucgDeviceName":"10.139.126.180","ucgType":"LIVE","ucgTopic":"persistent://enmv/hpov-alarm/hpov-snmp-trap"}]
    const handleSubmit = async (json: string) => {
        setLoading(true);
        try {
            const formattedFromDate = dayjs(fromDate).format('YYYY-MM-DD-HH:mm');
            const formattedToDate = dayjs(toDate).format('YYYY-MM-DD-HH:mm');

            let searchString;
            if (json === 'text') {
                searchString = {
                    globalsearch: selectedSearchString,
                };
            } else {
                searchString = JSON.parse(selectedSearchString.trim());
            }
            const data = {
                deviceName: selectedDeviceName,
                rootBucketKey: selectedProject.name,
                ucgSource: selectedUCGSource,
                fromDate: formattedFromDate,
                toDate: formattedToDate,
                searchContent: searchString,
            };

            // console.log(data);
            const response = await axios.post(API_ENDPOINTS.S3_DATA_SEARCH, data, {
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            // console.log(response);
            if (response && response.data && Object.keys(response.data).length > 0) {
                setResponseData(JSON.stringify(response, null, 2));
            } else {
                showSnackbar("No Match Found!");
            }
        } catch (error) {
            showSnackbar("Error While fetching the Data from the Server");
            console.error('Error fetching data', error);
            setResponseData('Error fetching data');
        } finally {
            setLoading(false);
        }

    };

    const resetSelections = () => {
        setSelectedDeviceName('');
        setSelectedSearchString('');
    }

    const isButtonDisabled = () => {
        return !selectedProject || !selectedDeviceName || !selectedSearchString || !selectedUCGSource;
    };

    const handleReset = () => {
        setSelectedProject(null);
        setSelectedDeviceName('');
        setSelectedSearchString('');
        setSelectedUCGSource('');
        setSelectedFromDate(dayjs().subtract(1, 'day'));
        setSelectedToDate(dayjs());
        setResponseData('');
    };

    const popperSxConfig = {
        popper: {
            sx: {
                "& .MuiMultiSectionDigitalClockSection-root:first-of-type": {
                    width: '55px !important',
                    scrollbarWidth: 'thin',
                },
                "& .MuiMultiSectionDigitalClockSection-root:not(:first-of-type):not(:last-of-type)": {
                    width: '63px !important',
                    scrollbarWidth: 'thin',
                },
            },
        },
    };

    const fullWidthHeight = { width: '100%', height: '100%' };

    return (

        <Box sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            //overflow: 'auto',
            //padding: '1%',
            boxSizing: 'border-box',

        }}>

            <Grid container spacing={4} alignItems="flex-end">
                <Grid item xs={12} sm={6} md={2}>
                    <Autocomplete
                        value={selectedProject}
                        onChange={(e, options) => handleProjectChange(options)}
                        loading
                        disablePortal
                        options={projectList}
                        getOptionLabel={(option) => option.name}
                        renderInput={(params: any) => <TextField {...params} label="Project" placeholder="Project Name" />}
                    />
                </Grid>
                <Grid item xs={12} sm={6} md={2}>
                    <TextField
                        variant="outlined"
                        placeholder='Device Name'
                        label="Device"
                        sx={fullWidthHeight}
                        value={selectedDeviceName}
                        onChange={(event) => handleTextFieldChange(setSelectedDeviceName, resetSelections)(event)}

                    />
                </Grid>
                <Grid item xs={12} sm={6} md={2}>
                    <FormControl variant="outlined" sx={fullWidthHeight}>
                        <InputLabel id="select-outlined-label">UCG Source</InputLabel>
                        <Select
                            labelId="select-outlined-label"
                            id="select-outlined"
                            label="UCG Source"
                            value={selectedUCGSource}
                            onChange={(event) => handleSelectChange(setSelectedUCGSource, resetSelections)(event)}

                        >
                            {ucgsourceLoading ? (
                                <MenuItem disabled>
                                    Loading…
                                </MenuItem>
                            ) : (
                                ucgSourceList?.map((source, i) => (
                                    <MenuItem
                                        key={source.name}
                                        id="dropDown"
                                        value={source.name}
                                    >
                                        {source.name}
                                    </MenuItem>
                                ))
                            )}
                        </Select>
                    </FormControl>
                </Grid>
                <Grid item xs={12} sm={6} md={2}>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DateTimePicker
                            slotProps={popperSxConfig}
                            label="Start DateTime"
                            sx={fullWidthHeight}
                            value={fromDate} onChange={(newValue: Dayjs | null) => {
                                setSelectedFromDate(newValue || dayjs());
                                // If newValue is after toDate, reset toDate
                                if (newValue && toDate && newValue.isAfter(toDate)) {
                                    setSelectedToDate(null);
                                }
                            }}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6} md={2}>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DateTimePicker
                            label="End DateTime"
                            slotProps={popperSxConfig}
                            sx={fullWidthHeight}
                            value={toDate}
                            minDate={fromDate}
                            onChange={(newValue) => setSelectedToDate(newValue)}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6} md={2}>
                    <TextField
                        variant="outlined"
                        label="Search String"
                        sx={fullWidthHeight}
                        value={selectedSearchString}
                        onChange={(event) => handleTextFieldChange(setSelectedSearchString, resetSelections)(event)}

                    />
                </Grid>

                <Grid item xs={12} sm={6} md={12} sx={{ textAlign: 'right' }} >
                    <Button variant="contained" onClick={handleReset} color="primary" sx={{ marginRight: 2 }}>Reset</Button>
                    <LoadingButton onClick={handleFetchClick} loading={loading} loadingIndicator="Fetching…" variant="contained"
                        disabled={isButtonDisabled()}>
                        <span>Fetch</span>
                    </LoadingButton>

                </Grid>
            </Grid>
            <Box mt={2} sx={{ width: '100%' }}>
                <TextField
                    variant="outlined"
                    multiline
                    rows={15}
                    fullWidth
                    value={responseData}
                />
            </Box>
        </Box>

    );
}

export default S3Audit;



import React, { useEffect, useState } from 'react';
import axios from 'axios';
import { __UCS_GRAPHQL_URL__ } from '../../api-endpoints';
import { UNIQUE_UGS_SOURCE_QUERY, UNIQUE_PROJECT_QUERY, GET_DAILY_TRENDS_DATA } from '../../graphQL/graphqlQueries';
import LoadingButton from "@mui/lab/LoadingButton";
import { LineChart } from '@mui/x-charts/LineChart';
import { AxisConfig, ChartsXAxisProps } from '@mui/x-charts';
import { Box, FormControl, Grid, InputLabel, MenuItem, Select, SelectChangeEvent, TextField, Autocomplete, Button } from '@mui/material';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import dayjs, { Dayjs } from 'dayjs';
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { useTheme } from "@mui/material/styles";
import { useSnackbar } from '../../utils/SnackbarContext';

const generateLast10Dates = () => {
    const dates = [];
    for (let i = 0; i < 10; i++) {
        dates.push(dayjs().subtract(i, 'day').format('YYYY-MM-DD'));
    }
    //console.log(dates,"dates");
    //return dates.reverse(); 
    return dates;
};


const DailyTrend: React.FC = () => {
    const theme = useTheme()
    const [projectList, setProjectList] = useState<any[]>([]);
    const [ucgSourceList, setUcgSourceList] = useState<{ id: number, name: string }[]>([]);

    const [selectedProject, setSelectedProject] = useState<any>(null);
    const [selectedUCGSource, setSelectedUCGSource] = useState<number>(0);
    const [fromDate, setSelectedFromDate] = useState<Dayjs>(dayjs().subtract(1, 'month'));
    const [toDate, setSelectedToDate] = useState<Dayjs | null>(dayjs());
    const [loading, setLoading] = useState<boolean>(false);
    const [ucgsourceLoading, setUcgsourceLoading] = useState<boolean>(false);

    const [isFetched, setIsFetched] = useState(false);
    const [responseData, setResponseData] = useState<any[]>([]);
    const { showSnackbar } = useSnackbar();
    const last10Dates = generateLast10Dates();

    //const data = [ { "collectionDate": "2024-08-16", "sizeOfFilesKB": 340, "numberOfFiles": 45 }, { "collectionDate": "2024-08-17", "sizeOfFilesKB": 340, "numberOfFiles": 45 }, { "collectionDate": "2024-08-18", "sizeOfFilesKB": 251, "numberOfFiles": 10 }, { "collectionDate": "2024-08-19", "sizeOfFilesKB": 456, "numberOfFiles": 78 }, { "collectionDate": "2024-08-20", "sizeOfFilesKB": 310, "numberOfFiles": 46 }, { "collectionDate": "2024-08-21", "sizeOfFilesKB": 234, "numberOfFiles": 56 }, { "collectionDate": "2024-08-22", "sizeOfFilesKB": 453, "numberOfFiles": 67 }, { "collectionDate": "2024-08-23", "sizeOfFilesKB": 300, "numberOfFiles": 41 }, { "collectionDate": "2024-08-24", "sizeOfFilesKB": 980, "numberOfFiles": 30 }, { "collectionDate": "2024-08-25", "sizeOfFilesKB": 340, "numberOfFiles": 45 }, { "collectionDate": "2024-08-26", "sizeOfFilesKB": 251, "numberOfFiles": 10 }, { "collectionDate": "2024-08-27", "sizeOfFilesKB": 251, "numberOfFiles": 10 }, { "collectionDate": "2024-08-28", "sizeOfFilesKB": 251, "numberOfFiles": 10 }, { "collectionDate": "2024-08-29", "sizeOfFilesKB": 175, "numberOfFiles": 62 }, { "collectionDate": "2024-09-01", "sizeOfFilesKB": 1101, "numberOfFiles": 42 }, { "collectionDate": "2024-09-02", "sizeOfFilesKB": 150, "numberOfFiles": 21 }, { "collectionDate": "2024-09-03", "sizeOfFilesKB": 232, "numberOfFiles": 12 } ];
    useEffect(() => {
        //setResponseData(data);
        const fetchProjectData = async () => {
            try {
                const projectResponse = await axios.post(__UCS_GRAPHQL_URL__, {
                    query: UNIQUE_PROJECT_QUERY,
                });
                if (projectResponse.data?.data?.uniqueUCSPProjects && projectResponse.data.data.uniqueUCSPProjects.length > 0) {
                    setProjectList(projectResponse.data.data.uniqueUCSPProjects);
                }
            } catch (error) {
                showSnackbar('Error fetching project data!');
                console.error('Error fetching project data', error);
            }
        };
        fetchProjectData();
    }, []);

    const handleProjectChange = async (options: any) => {
        setSelectedProject(options);
        setUcgsourceLoading(true);
        setSelectedUCGSource(0);
        setUcgSourceList([]);
        if (options && options.id) {
            try {
                const ucgSourcesResponse = await axios.post(__UCS_GRAPHQL_URL__, {
                    query: UNIQUE_UGS_SOURCE_QUERY,
                    variables: { projectId: options.id },
                });
                if (ucgSourcesResponse.data?.data?.uniqueUCGSourcesByProject && ucgSourcesResponse.data.data.uniqueUCGSourcesByProject.length > 0) {
                    setUcgSourceList(ucgSourcesResponse.data.data.uniqueUCGSourcesByProject);
                } else {
                    showSnackbar('No UCGsource exists for this Project!');
                }
            } catch (error) {
                showSnackbar('Error fetching UCGsource data!');
                console.error('Error fetching UCG source:', error);
            } finally {
                setUcgsourceLoading(false);
            }
        }
    };

    const handleSelectChange = (setter: React.Dispatch<React.SetStateAction<number>>) => (
        event: SelectChangeEvent<number>) => {
        setter(event.target.value as number);
    };

    const handleReset = () => {
        setSelectedProject(null);
        setSelectedUCGSource(0);
        setSelectedFromDate(dayjs().subtract(1, 'month'));
        setSelectedToDate(dayjs());
        setResponseData([]);
    };
    const handleFetchClick = async () => {
        setLoading(true);
        setIsFetched(false);
        setResponseData([]);
        const formattedFromDate = dayjs(fromDate).format('YYYY-MM-DD');
        const formattedToDate = dayjs(toDate).format('YYYY-MM-DD');

        const data = {
            ucgSourceID: selectedUCGSource,
            fromDate: formattedFromDate,
            toDate: formattedToDate
        };
        //console.log(data);
        try {
            const response = await axios.post(__UCS_GRAPHQL_URL__, {
                query: GET_DAILY_TRENDS_DATA,
                variables: data,
            });

            if (response.data?.data?.dailyTrends && response.data.data.dailyTrends.length > 0) {
                let data = response.data.data.dailyTrends || [];
                console.log(data);
                setResponseData(data);
            } else {
                showSnackbar("No Data Found!");
            }
            //console.log(response);
        } catch (error) {
            showSnackbar("Error While fetching the Data from the Server");
            console.error('Error fetching data', error);
        } finally {
            setLoading(false);
            setIsFetched(true);
        }
    };

    const series = [
        {
            dataKey: 'sizeOfFilesKB',
            label: 'Size of Files (KB)',
        },
        {
            dataKey: 'numberOfFiles',
            label: 'Number of Files',
        },
    ];
    const isButtonDisabled = () => {
        return !selectedProject || !selectedUCGSource || !fromDate || !toDate;
    };

    //const theme = useTheme();

    return (

        <Box sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            //overflow: 'auto',
            //padding: '1%',
            boxSizing: 'border-box',

        }}>
            <Grid container spacing={4} alignItems="flex-end">
                <Grid item xs={12} sm={6} md>
                    <Autocomplete
                        value={selectedProject}
                        onChange={(e, options) => handleProjectChange(options)}
                        loading={loading}
                        disablePortal
                        options={projectList}
                        getOptionLabel={(option) => option.name}
                        renderInput={(params: any) => <TextField {...params} label="Project" placeholder="Project Name" />}
                    />
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <FormControl variant="outlined" sx={{ width: '100%', height: '100%' }}>
                        <InputLabel id="select-outlined-label">UCG Source</InputLabel>
                        <Select
                            labelId="select-outlined-label"
                            id="select-outlined"
                            label="UCG Source"
                            value={selectedUCGSource}
                            onChange={(event) => handleSelectChange(setSelectedUCGSource)(event)}
                        >
                            {ucgsourceLoading ? (
                                <MenuItem disabled>
                                    Loading…
                                </MenuItem>
                            ) : (
                                ucgSourceList?.map((source, i) => (
                                    <MenuItem
                                        key={source.id}
                                        id="dropDown"
                                        value={source.id}
                                    >
                                        {source.name}
                                    </MenuItem>
                                ))
                            )}
                        </Select>
                    </FormControl>
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="Start Date"
                            sx={{ width: '100%', height: '100%' }}
                            value={fromDate}
                            onChange={(newValue: Dayjs | null) => {
                                setSelectedFromDate(newValue || dayjs());
                                // If newValue is after toDate, reset toDate
                                if (newValue && toDate && newValue.isAfter(toDate)) {
                                    setSelectedToDate(null);
                                }
                            }}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="End Date"
                            sx={{ width: '100%', height: '100%' }}
                            value={toDate}
                            minDate={fromDate} // Disable dates before fromDate
                            onChange={(newValue) => setSelectedToDate(newValue)}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={2} sm={2} md={2} sx={{ display: 'flex' }}>
                    <Button variant="contained" onClick={handleReset} color="primary" sx={{ marginRight: 2 }}>Reset</Button>
                    <LoadingButton onClick={handleFetchClick} loading={loading} loadingIndicator="Fetching…" variant="contained"
                        disabled={isButtonDisabled()}>
                        <span>Fetch</span>
                    </LoadingButton>
                </Grid>
            </Grid>


            {responseData.length > 0 ? (
                <Box sx={{ marginTop: 6, height: 450, width: '100%', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <LineChart
                        // loading
                        dataset={responseData}
                        //width={760}
                        series={series}
                        xAxis={[
                            {
                                dataKey: 'collectionDate',
                                scaleType: "point",
                                label: "Collected Date",
                                tickLabelStyle: {
                                    angle: -25,
                                    textAnchor: 'end',
                                    fontSize: 10,
                                },
                                labelStyle: { transform: "translateY(30px)" },
                                tickPlacement: 'middle', tickLabelPlacement: 'middle'
                            } as AxisConfig<'point', string, ChartsXAxisProps>,
                        ]}
                        margin={{
                            left: 80,
                            right: 5,
                            top: 50,
                            bottom: 80,
                        }}
                        colors={theme.palette.distinctLightPalette}
                    />
                </Box>
            ) : isFetched && (
                <Box sx={{ marginTop: 6, height: 450, width: '100%', display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <LineChart
                        xAxis={[{ data: last10Dates, scaleType: 'point', }]}
                        yAxis={[{ min: 0, max: 10 }]}
                        series={[]}
                    />
                </Box>
            )}

        </Box>
    );
}

export default DailyTrend;



import React, { useState, useEffect } from 'react';
import { LineChart } from '@mui/x-charts/LineChart';
import { Autocomplete, Box, Button, Breadcrumbs, FormControlLabel, Grid, IconButton, Link, Switch, TextField, Typography } from '@mui/material';
import axios from 'axios';
import { AxisConfig, ChartsXAxisProps } from '@mui/x-charts';
import { __UCS_GRAPHQL_URL__ } from '../../api-endpoints';
import { UNIQUE_NETWORKS_BY_PROTOCOL_QUERY, AVG_NETWORK_BY_COVERAGE_QUERY, UNIQUE_DEVICES_BY_NETWORK_SNMP } from '../../graphQL/graphqlQueries';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import dayjs, { Dayjs } from 'dayjs';
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import LoadingButton from "@mui/lab/LoadingButton";
import NavigateNextIcon from '@mui/icons-material/NavigateNext';
import HomeIcon from '@mui/icons-material/Home';
import { useSnackbar } from '../../utils/SnackbarContext';
import { useTheme } from '@mui/material/styles';

interface DataPoint {
    date: string;
    totalCoverage: number;
    coverageDataList: DetailedDataPoint[];
}

interface DetailedDataPoint {
    time: string;
    coverage: number;
}
const chartHeight = 450;
const childChartHeight = 410;
const ParentChart = ({ data, onDrillDown, setIsChildChartDisplayed }: { data: DataPoint[], onDrillDown: (date: string) => void, setIsChildChartDisplayed: (value: boolean) => void }) => {
    //console.log('ParentChart received data:', data); 
    const theme = useTheme();

    const transformedData = data.map(item => ({
        collectionDate: item.date,
        totalCoverage: item.totalCoverage,
    }));

    //console.log('Transformed Data for ParentChart:', transformedData); // Log transformed data

    const lineChartParams = {
        series: [
            {
                id: 'totalCoverage',
                datakey: 'totalCoverage',
                label: 'Coverage',
                data: transformedData.map(item => item.totalCoverage),
            }
        ],
        xAxis: [{
            data: transformedData.map(item => item.collectionDate),
            id: 'axis1',
            dataKey: 'collectionDate',
            scaleType: "point",
            label: "Collected Date",
            tickLabelStyle: {
                angle: -25,
                textAnchor: 'end',
                fontSize: 10,
            },
            labelStyle: { transform: "translateY(30px)" },
            tickPlacement: 'middle', tickLabelPlacement: 'middle',
        } as AxisConfig<'point', string, ChartsXAxisProps>],
        height: chartHeight,
        margin: {
            left: 60,
            right: 10,
            top: 20,
            bottom: 80,
        },
        colors: theme.palette.distinctLightPalette
    };

    return (
        <Box width="100%">
            <LineChart
                {...lineChartParams}
                onAxisClick={(event, d) => {
                    if (d && d.axisValue) {
                        setIsChildChartDisplayed(true);
                        onDrillDown(String(d.axisValue));
                    } else {
                        console.error('collectionDate not found in data point');
                    }
                }}

            />
        </Box>
    );
};

const ChildChart = ({ date, data }: { date: string, data: DetailedDataPoint[] }) => {
    const theme = useTheme();
    const detailedLineChartsParams = {
        series: [
            {
                id: 'networkcoverage',
                datakey: 'networkcoverage',
                label: 'Coverage',
                data: data.map(item => item.coverage)
            }
        ],
        xAxis: [{
            data: data.map(item => item.time),
            id: 'axis2',
            dataKey: 'time',
            scaleType: "point",
            label: "Collected Time on " + date,
        } as AxisConfig<'point', string, ChartsXAxisProps>],
        height: childChartHeight,
        colors: theme.palette.distinctLightPalette
    };

    return (
        <Box width="100%">
            <LineChart {...detailedLineChartsParams} />
        </Box>
    );
};
const generateLast10Dates = () => {
    const dates = [];
    for (let i = 0; i < 10; i++) {
        dates.push(dayjs().subtract(i, 'day').format('YYYY-MM-DD'));
    }
    //console.log(dates,"dates");
    //return dates.reverse(); 
    return dates;
};

const DrillDownChart = () => {
    const theme = useTheme();
    const [viewStack, setViewStack] = useState<string[]>([]);
    const [parentData, setParentData] = useState<DataPoint[]>([]);

    const [networkList, setNetworkList] = useState<any[]>([]);
    const [selectedNetwork, setSelectedNetwork] = useState<any>(null);
    const [deviceList, setDeviceList] = useState<any[]>([]);
    const [selectedDevice, setSelectedDevice] = useState<any>(null);
    const [fromDate, setSelectedFromDate] = useState<Dayjs>(dayjs().subtract(2, 'week'));
    const [toDate, setSelectedToDate] = useState<Dayjs | null>(dayjs());

    const [loading, setLoading] = useState<boolean>(false);
    const [dataFetched, setDataFetched] = useState<boolean>(false);
    const [isChildChartDisplayed, setIsChildChartDisplayed] = useState(false);
    const [isDeviceFieldEnabled, setIsDeviceFieldEnabled] = useState(false);
    const { showSnackbar } = useSnackbar();
    const last10Dates = generateLast10Dates();

    useEffect(() => {
        const fetchNetworkData = async () => {
            try {
                const response = await axios.post(__UCS_GRAPHQL_URL__, {
                    query: UNIQUE_NETWORKS_BY_PROTOCOL_QUERY
                });
                setNetworkList(response.data?.data?.uniqueNetworksByProtocol);
            } catch (error) {
                showSnackbar('Error fetching network data!');
                console.error('Error fetching network data', error);
            }
        };
        fetchNetworkData();
    }, []);

    const isButtonDisabled = () => {
        if (isDeviceFieldEnabled) {
            return !selectedNetwork || !fromDate || !toDate || !selectedDevice;
        }
        return !selectedNetwork || !fromDate || !toDate;
    };

    const handleReset = () => {
        setSelectedNetwork('');
        setSelectedFromDate(dayjs().subtract(2, 'week'));
        setSelectedToDate(dayjs());
        setParentData([]);
        setDataFetched(false);
        if (isDeviceFieldEnabled) {
            setSelectedDevice('');
        }
    };
    const handleNetworkChange = async (newValue: any) => {
        setSelectedNetwork(newValue);
        if (isDeviceFieldEnabled) {
            fetchDeviceData(newValue);
        }
    }
    const fetchDeviceData = async (network: any) => {
        setDeviceList([]);
        try {
            const response = await axios.post(__UCS_GRAPHQL_URL__, {
                query: UNIQUE_DEVICES_BY_NETWORK_SNMP,
                variables: { network: network },
            });

            if (response.data?.data?.uniqueDevicesByNetwork && response.data.data.uniqueDevicesByNetwork.length > 0) {
                let data = response.data.data.uniqueDevicesByNetwork || [];
                console.log('Fetched device Data:', data);
                setDeviceList(data);
            }
            console.log('Fetched device Data:', response);
        } catch (error) {
            showSnackbar('Error fetching device data!');
            console.error('Error fetching device data', error);
        }
    };
    const handleFetchClick = async () => {
        setLoading(true);
        setParentData([]);

        try {
            const formattedFromDate = dayjs(fromDate).format('YYYY-MM-DD');
            const formattedToDate = dayjs(toDate).format('YYYY-MM-DD');

            const data: { [key: string]: any } = {
                network: selectedNetwork,
                fromDate: formattedFromDate,
                toDate: formattedToDate
            };
            if (isDeviceFieldEnabled) {
                data.device = selectedDevice;
            }
            //console.log("Data:", data);
            const response = await axios.post(__UCS_GRAPHQL_URL__, {
                query: AVG_NETWORK_BY_COVERAGE_QUERY,
                variables: data,
            });

            if (response.data?.data?.avgNetworkByCoverage && response.data.data.avgNetworkByCoverage.length > 0) {
                let data = response.data.data.avgNetworkByCoverage || [];
                console.log('Fetched Parent Data:', data);
                setParentData(data);
            } else {
                console.warn('No Data Found!');
                showSnackbar("No Data Found!");
            }
            setDataFetched(true);
        } catch (error) {
            console.error('Error fetching data', error);
            showSnackbar("Error While fetching the Data from the Server");
        } finally {
            setIsChildChartDisplayed(false);
            setViewStack([]);
            setLoading(false);
        }
    };

    const handleToggleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setIsDeviceFieldEnabled(event.target.checked);
    };
    const handleDrillDown = (date: string) => {
        setViewStack([...viewStack, date]);
    };

    const handleBreadcrumbClick = (index: number) => {
        setViewStack(viewStack.slice(0, index + 1));
    };

    const currentView = viewStack[viewStack.length - 1];
    const currentData = parentData.find(item => item.date === currentView)?.coverageDataList || [];

    //console.log('Current View:', currentView); 
    //console.log('Current Data:', currentData); 
    // console.log('Parent Data:', parentData);

    return (

        <Box
            sx={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                //height: '100vh',
                //overflow: 'auto',
                //padding: '1%',
                boxSizing: 'border-box',

            }}
        >
            {/* Avg Coverage by Network {isDeviceFieldEnabled ? 'and Device' : ''}*/}
            <Grid container spacing={2} alignItems="flex-end">
                <Grid item xs={12} sm={6} md="auto">
                    <FormControlLabel
                        control={<Switch color="primary" checked={isDeviceFieldEnabled} onChange={handleToggleChange} />}
                        label={<Typography variant="bodySM">Enable Device Field</Typography>}
                        //label="Enable Device"
                        labelPlacement="top"
                        value="top"
                        //sx={{ width: '100%', height: '100%' }} 
                        />
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <Autocomplete
                        options={networkList}
                        getOptionLabel={(option) => option}
                        value={selectedNetwork}
                        onChange={(event, newValue) => handleNetworkChange(newValue)}
                        renderInput={(params) => <TextField {...params} label="Network" variant="outlined" />}
                        sx={{ width: '100%', height: '100%' }}
                    />
                </Grid>
                {isDeviceFieldEnabled && (
                    <Grid item xs={12} sm={6} md>
                        <Autocomplete
                            options={deviceList}
                            getOptionLabel={(option) => option}
                            value={selectedDevice}
                            onChange={(event, newValue) => setSelectedDevice(newValue)}
                            renderInput={(params) => <TextField {...params} label="Device" variant="outlined" />}
                            sx={{ width: '100%', height: '100%' }}
                        />
                    </Grid>
                )}
                <Grid item xs={12} sm={6} md>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="Start Date"
                            sx={{ width: '100%', height: '100%' }}
                            value={fromDate}
                            onChange={(newValue: Dayjs | null) => {
                                setSelectedFromDate(newValue || dayjs());
                                // If newValue is after toDate, reset toDate
                                if (newValue && toDate && newValue.isAfter(toDate)) {
                                    setSelectedToDate(null);
                                }
                            }}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="End Date"
                            sx={{ width: '100%', height: '100%' }}
                            value={toDate}
                            minDate={fromDate} // Disable dates before fromDate
                            onChange={(newValue) => setSelectedToDate(newValue)}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={2} sm={2} md={2} sx={{ display: 'flex' }}>
                    <Button variant="contained" onClick={handleReset} color="primary" sx={{ marginRight: 2 }}>Reset</Button>
                    <LoadingButton onClick={handleFetchClick} loading={loading} loadingIndicator="Fetching…" variant="contained"
                        disabled={isButtonDisabled()}>
                        <span>Fetch</span>
                    </LoadingButton>
                </Grid>
            </Grid>


            {dataFetched && !loading && (
                <Box sx={{ mt: 4, width: '100%', borderRadius: 2, border: '1px solid #e0e0e0', bgcolor: 'white' }}>
                    {isChildChartDisplayed && parentData.length > 0 && (

                        <Breadcrumbs aria-label="breadcrumb" separator={<NavigateNextIcon fontSize="small" />} sx={{ padding: '1%' }}>
                            <Link underline="hover" sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer', '&:hover': { textDecoration: 'underline !important', color: '#1976d2 !important' } }} color="primary" onClick={() => { setViewStack([]); setIsChildChartDisplayed(false); }} >
                                <HomeIcon sx={{ mr: 0.4 }} fontSize="inherit" />
                                Home
                            </Link>
                            {viewStack.map((view, index) => (
                                <Link
                                    key={view}
                                    color="inherit"
                                    sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
                                    underline="none"
                                    onClick={() => handleBreadcrumbClick(index)}
                                >
                                    {view}
                                </Link>
                            ))}
                        </Breadcrumbs>
                    )}

                    <Box mt={1} sx={{ width: '100%' }}>
                        {parentData.length > 0 ? (
                            <>
                                {currentView ? (
                                    <ChildChart date={currentView} data={currentData} />
                                ) : (
                                    <ParentChart data={parentData} onDrillDown={handleDrillDown} setIsChildChartDisplayed={setIsChildChartDisplayed} />
                                )}
                            </>
                        ) : (
                            <LineChart
                                height={chartHeight}
                                xAxis={[{ data: last10Dates, scaleType: 'point', }]}
                                yAxis={[{ min: 0, max: 10 }]}
                                series={[]}
                            />
                        )
                        }
                    </Box>
                </Box>
            )}
        </Box>
    );
};

export default DrillDownChart;


As a developer,

I need to analyze the requirements for the MCP and Trap trends graph in the Overall Health Metrics dashboard.

This includes understanding the UI implementations, database structure, data sources, and API requirements for visualizing a scatter plot that dynamically updates based on the selected data type and protocol.

Additionally, I need to create the necessary database tables and populate them with dummy data to proceed with the development.

Technical Details
UI Components: Scatter plot visualization, color coding for different protocols, dynamic updates based on data type selection.
Database Structure: Tables and relationships to store data for different protocols and data types.
Data Sources: Identification and integration of data sources for SNMP perf, WSS, gRPC, TL1, syslog, etc.
API Requirements: Endpoints to fetch data for the scatter plot, handle different data types, and support dynamic updates.
Tasks
Analyze UI Implementations: Identify and document the necessary UI components and interactions for the scatter plot.
Analyze Database Structure: Identify and document the necessary tables and relationships to support the new data types and protocols.
Analyze Data Sources: Identify and document the sources of data for each protocol and how the data will be collected, processed, and stored.
Analyze API Requirements: Identify and document the necessary endpoints and request/response formats to support the dynamic updates of the scatter plot.
Create Database Tables: Define and create the necessary database tables to store protocol data and collection types.
Populate Tables with Dummy Data: Insert sample data into the database tables for different protocols and data types.
Compile Findings: Compile all findings into a detailed implementation plan.
Example Documentation Outline
UI Implementations:
Scatter plot visualization
Color coding for different protocols
Dynamic updates based on data type selection
Database Structure:
Tables and relationships
Schema changes required
Data Sources:
Identification of data sources for each protocol
Data collection, processing, and storage
API Requirements:
Endpoints
Request/response formats
Database Tables:
Schema definition
Table creation scripts
Dummy Data:
Sample data for different protocols and data types
Data insertion scripts
