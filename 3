package com.verizon.ucs.vmbc.service.s3;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.vmbc.exception.S3SaveException;
import com.verizon.ucs.vmbc.s3.grpc.proto.DataWrapperDTO;
import com.verizon.ucs.vmbc.s3.grpc.proto.LoadToS3ApiResponse;
import com.verizon.ucs.vmbc.util.Constants;
import com.verizon.ucs.vmbc.yaml.VMBProperties;
import org.apache.commons.collections.CollectionUtils;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.Messages;
import org.json.simple.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.Iterator;
import java.util.List;

@Service
@Scope("prototype")
public class S3MessageService {

    private static Logger logger = LoggerFactory.getLogger(S3MessageService.class);


    private final String newRelicEvents = "enmvVCPVMBConsumer:events";

    @Autowired
    private VMBProperties vmbProperties;

    @Autowired
    private S3GrpcClient s3GrpcClient;

    @Autowired
    private ObjectMapper objectMapper;


    public void saveMessagesToS3(final Messages<byte[]> messages,
                                 final boolean persistenceTimestampFlag) {

        if (messages != null) {

            try {
                logger.debug("saveMessagesToS3 - Messages list size {}", messages.size());
                messages.forEach(message -> {
                    saveMsgToS3(message, persistenceTimestampFlag);
                });
            } catch (Exception e) {
                logger.error("saveMessagesToS3 failed:", e);
            }

        }

    }

    public void saveMessagesListToS3(final List<Message<byte[]>> messages, final boolean persistenceTimestampFlag) {

        if (CollectionUtils.isNotEmpty(messages)) {

            try {
                logger.debug("saveMessagesListToS3 - Messages list size {}", messages.size());
                messages.forEach(message -> {
                    saveMsgToS3(message, persistenceTimestampFlag);
                });
            } catch (Exception e) {
                logger.error("saveMessagesListToS3 failed:", e);
            }

        }

    }

    public void saveMsgToS3(final Message<byte[]> message,
                            final boolean persistenceTimestampFlag) {

        try {
        	logger.debug("saveMsgToS3 - Message");
            String json = new String(message.getValue());
            JSONObject s3RequestPayload = objectMapper.readValue(json, JSONObject.class);
            logger.debug("publishToS3 s3RequestPayload === {}", s3RequestPayload.toString());
            s3RequestPayload.put("_pulsarId", message.getMessageId().toString());
            if (persistenceTimestampFlag) {
                s3RequestPayload.put("persistenceTimestamp", getUtcTimeStamp());
                logger.debug("publishToS3 persistenceTimestamp set is {}", s3RequestPayload.get("persistenceTimestamp"));
            }
            logger.debug("Save vmb-consumer message to s3 initiated ");
            if (s3RequestPayload != null) {
                publishToS3(s3RequestPayload, vmbProperties.getS3BucketKey());
                logger.debug("Save vmb-consumer message to s3 success ");
            }

        } catch (Exception e) {
            throw new S3SaveException("saveMsgToS3 failed", e);
        }
    }


    public void publishToS3(JSONObject dataObject, String s3BucketKey) {
        try {
            logger.debug("publishToS3 s3BucketKey === {}", s3BucketKey);
            logger.debug("publishToS3 dataObject.toJSONString() {}", dataObject.toString());
            JSONObject s3reqObject = new JSONObject();
            s3reqObject.put(Constants.S3_BUCKET_KEY, s3BucketKey);
            s3reqObject.put(Constants.PAYLOAD, dataObject.toString());
            DataWrapperDTO dataWrapperDTO = DataWrapperDTO.newBuilder().setPayload(s3reqObject.toString()).build();
            Iterator<LoadToS3ApiResponse> s3Response = s3GrpcClient.getStub().saveToS3(dataWrapperDTO);
            while (s3Response.hasNext()) {
                LoadToS3ApiResponse response = s3Response.next();
                logger.debug("Response: " + response.getResMessage());
            }
        } catch (Throwable t) {
            logger.error("publishToS3 failed", t);
        }
    }


    /**
     * Setting 24 hour utc timestamp
     */
    private String getUtcTimeStamp() {
        ZonedDateTime now = ZonedDateTime.now(ZoneId.of("UTC"));
        DateTimeFormatter dateTimeFormatter = new DateTimeFormatterBuilder().appendPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").appendOffset("+HH:MM", "+00:00").toFormatter();
        return now.format(dateTimeFormatter);
    }

    public void saveMsgToS3(JSONObject s3RequestPayload) {
    	try{
    		logger.debug("saveMsgToS3 with ucgId: " + s3RequestPayload.toJSONString());
    		logger.debug("saveMsgToS3 with vmbProperties.getS3BucketKey() : " + vmbProperties.getS3BucketKey());
    		publishToS3(s3RequestPayload,vmbProperties.getS3BucketKey());
    	}
    	catch (Exception ex){
    		logger.error("Exception while calling s3 api. Error: " + ex.getMessage());
    		ex.printStackTrace();
    	}
    }

}


Getting the error as publishing to s3 failed please resolve
