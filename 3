package com.verizon.ucs.scheduler;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.service.DBService;
import com.verizon.ucs.service.NexusService;
import com.verizon.ucs.service.VmbProducerService;
import com.verizon.ucs.service.VmbConsumerService;
import com.verizon.ucs.service.VmbEclipsePublisherService;

import jakarta.annotation.PostConstruct;

@Component
public class NexusScheduler {
    private static final Logger logger = LoggerFactory.getLogger(NexusScheduler.class);

    @Value("${scheduler.threadPoolSize}")
    private int threadPoolSize;

    @Autowired
    private DBService dBService;

    @Autowired
    private VmbConsumerService vmbConsumerService;
    
    //@Autowired
   // private VmbEclipsePublisherService vmbPublisherService;

    @Autowired
    private VmbProducerService pulsarProducerService;

    @Autowired
    private NexusService nexusService;

    private ExecutorService executorService;

    @PostConstruct
    public void init() {
        logger.info("Starting @PostConstruct" );
        try {
        	this.executorService = Executors.newFixedThreadPool(threadPoolSize);
            //vmbConsumerService.init();
            //pulsarProducerService.init();
        	//vmbPublisherService.init();
        } catch (Exception e) {
            logger.error("Error in @PostConstruct", e);
        }
    }

    @Scheduled(fixedRateString = "${scheduler.fixedRate}")
    //@Scheduled(fixedRate = 900000)
    public void scheduleTask() {
        List<DeviceInfo> devices;
        logger.info("Starting Scheduler");
        try {
            // Fetch device details from the database
            devices = dBService.fetchDeviceDetails();
            logger.info("Devices from DB: {}", devices);

            // Process each device separately
            for (DeviceInfo device : devices) {
                executorService.submit(() -> {
                    try {
                        nexusService.processDevice(device);
                    } catch (Exception e) {
                        logger.error("Exception while processing device: {}", device, e);
                    }
                });
            }
        } catch (Exception e) {
            logger.error("Exception while processing devices", e);
        }
    }
}

package com.verizon.ucs.service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.function.Function;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.config.VMBConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.model.NexusData1250;
import com.verizon.ucs.model.NexusData1450;
import com.verizon.ucs.model.NexusData1500;
import com.verizon.ucs.model.RecoveryResponse;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.Nexus1500Parser;
import com.verizon.ucs.util.Validation;

@Service
public class NexusService {
	private static final Logger logger = LoggerFactory.getLogger(NexusService.class);

	@Autowired
	private NexusConfig config;

	@Autowired
	private VMBConfig vMBConfig;
	
	@Autowired
	private Validation validation;

	@Autowired
	private RestTemplate restTemplate;

	@Autowired
	private RetryTemplate retryTemplate;
	
//	@Autowired
//	private VmbProducerService vmbProducerService;
	@Autowired
	private VmbEclipsePublisherService vmbEclipsePublisherService;
	
	public Object processDevice(DeviceInfo devInfo) throws Exception {
		devInfo.setModelNo(devInfo.getModel().replace("Nexus ", ""));

		Function<String, ?> parser = getParser(devInfo.getModelNo());
		if (parser != null) {
			return getNexusData(devInfo, parser);
		} else {
			logger.info("Unsupported device type: {}", devInfo.getModelNo());
			return null;
		}
	}

	private Function<String, ?> getParser(String deviceType) {
		switch (deviceType) {
		case Constants.DEVICE_TYPE_1250:
			return response -> {
				try {
					return new Nexus1250Parser().parse(response);
				} catch (Exception e) {
					throw new RuntimeException(e);
				}
			};
		case Constants.DEVICE_TYPE_1450:
			return response -> new Nexus1450Parser().parse(response);
		case Constants.DEVICE_TYPE_1500:
			return response -> {
				try {
					return new Nexus1500Parser().parse(response);
				} catch (Exception e) {
					throw new RuntimeException(e);
				}
			};
		default:
			return null;
		}
	}

	public <T> T getNexusData(DeviceInfo devInfo, Function<String, T> parser) throws Exception {
		String response;

		if (config.isUseSampleData()) {
			response = new String(Files.readAllBytes(Paths.get(config.getSampleDataPaths().get(devInfo.getModelNo()))));
		} else {
			response = fetchDataFromDevice(devInfo);
		}

		T data = parser.apply(response);
		logger.info("NexusData::  {}", data);

		validation.validateData(devInfo, data);
		
		ObjectMapper objectMapper = new ObjectMapper();
		String jsonData = objectMapper.writeValueAsString(data);
        JSONObject ucgData = constructUcgData(devInfo, jsonData);
        
        //vmbProducerService.sendMessage(vMBConfig.getVmbTopic(), ucgData.toString());
        vmbEclipsePublisherService.publishAsync(vMBConfig.getVmbTopic(),ucgData.toString(),devInfo.getDeviceIP());
		return data;
	}
	
	private JSONObject constructUcgData(DeviceInfo devInfo,String data) {
		JSONObject obj = new JSONObject();
		obj.put("ucgTimestamp", Instant.now().toEpochMilli());
		obj.put("ucgDeviceName", devInfo.getDeviceName());
		obj.put("ucgSource", devInfo.getDeviceIP());
		obj.put("ucgType", "LIVE");
		obj.put("ucgRawData", data);
		obj.put("ucgTopic", vMBConfig.getVmbTopic());
		logger.info("UCG obj::  {}", obj);
		return obj;
	}

	private String fetchDataFromDevice(DeviceInfo devInfo) throws Exception {
		return retryTemplate.execute(context -> {
			String url = config.getApiEndpoints().get(devInfo.getModelNo()).replace("{siteIP}", devInfo.getDeviceIP());

			switch (devInfo.getModelNo()) {
			case Constants.DEVICE_TYPE_1250:
				return restTemplate.getForObject(url, String.class);
			case Constants.DEVICE_TYPE_1450:
				return restTemplate.postForObject(url, getHttpEntity(), String.class);
			case Constants.DEVICE_TYPE_1500:
				return restTemplate.getForObject(url, String.class);
			default:
				throw new IllegalArgumentException("Unsupported device type: " + devInfo.getModelNo());
			}
		}, context -> {
			// Recovery logic
			Throwable lastThrowable = context.getLastThrowable();
			String errorMessage = lastThrowable != null ? lastThrowable.getMessage() : "Unknown error";
			logger.info("All retry attempts failed. Executing recovery logic. Error: {}", errorMessage);
			String lovMsg = validation.generateLOVResponse(devInfo, errorMessage);
			//vmbProducerService.sendMessage(vMBConfig.getLovTopic(), lovMsg);
			vmbEclipsePublisherService.publishAsync(vMBConfig.getLovTopic(),lovMsg,devInfo.getDeviceIP());
			
			return "Recovery response: " + errorMessage;
		});
	}

		
	private HttpEntity<String> getHttpEntity() {
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		return new HttpEntity<>(createRequestPayload(Constants.REQUEST_BODY_1450), headers);
	}

	private String createRequestPayload(String[] chans) {
		ObjectMapper mapper = new ObjectMapper();
		Map<String, Object> payloadMap = Map.of("chans", chans);
		try {
			return mapper.writeValueAsString(payloadMap);
		} catch (JsonProcessingException e) {
			logger.error("Error creating JSON request payload", e);
			return null;
		}
	}
}

package com.verizon.ucs.service;

//import org.apache.pulsar.client.api.Producer;
import org.apache.pulsar.client.api.ProducerBuilder;
//import org.apache.pulsar.client.api.PulsarClient;
import org.apache.pulsar.client.api.Schema;
import org.apache.pulsar.shade.client.api.v2.Producer;
import org.apache.pulsar.shade.client.api.v2.PulsarClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.verizon.ucs.config.VMBConfig;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;

import java.util.HashMap;
import java.util.Map;

@Service
public class VmbProducerService {
    private static final Logger logger = LoggerFactory.getLogger(VmbProducerService.class);

    @Autowired
    private VMBConfig vmbConfig;

    @Autowired
    private PulsarClient pulsarClient;

    private Map<String, Producer<String>> producers = new HashMap<>();

    //@PostConstruct
    public void init() throws Exception {
        logger.info("Initializing Pulsar producers");

        // Initialize producers for different topics
        //initializeProducer(vmbConfig.getLovTopic());
        initializeProducer(vmbConfig.getVmbTopic());
    }

    private void initializeProducer(String topic) throws Exception {
        ProducerBuilder<String> producerBuilder = pulsarClient.newProducer(Schema.STRING)
                .topic(topic)
                .enableBatching(true)
                .batchingMaxMessages(1000)
                .batchingMaxPublishDelay(10, java.util.concurrent.TimeUnit.MILLISECONDS);

        Producer<String> producer = producerBuilder.create();
        producers.put(topic, producer);
        logger.info("Initialized producer for topic: {}", topic);
    }

    @PreDestroy
    public void shutDown() {
        try {
            logger.info("Shutting down Pulsar producers and client");
            for (Producer<String> producer : producers.values()) {
                if (producer != null) {
                    producer.close();
                }
            }
            if (pulsarClient != null) {
                pulsarClient.close();
            }
        } catch (Exception e) {
            logger.error("Exception while shutting down Pulsar producers and client", e);
        }
    }

    public void sendMessage(String topic, String message) throws Exception {
        Producer<String> producer = producers.get(topic);
        if (producer != null) {
            producer.send(message);
            logger.info("Message sent to topic {}: {}", topic, message);
        } else {
            logger.error("Producer for topic {} not found", topic);
        }
    }
}

package com.verizon.ucs.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.verizon.eclipse.pulsar.producer.EclipsePulsarProducerNr;
import com.verizon.ucs.config.VMBConfig;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;

import java.util.HashMap;
import java.util.Map;

@Service
public class VmbEclipsePublisherService {
    private static final Logger logger = LoggerFactory.getLogger(VmbEclipsePublisherService.class);

    private Map<String, EclipsePulsarProducerNr> producers = new HashMap<>();

    @Autowired
    private VMBConfig vmbConfig;

    @PostConstruct
    public void init() throws Exception {
        logger.info("Initializing Pulsar producers");

        // Initialize producers for different topics
        initializeProducer(vmbConfig.getVmbTopic());
        //initializeProducer(vmbConfig.getLovTopic());
    }

    private void initializeProducer(String topic) throws Exception {
        EclipsePulsarProducerNr producer = new EclipsePulsarProducerNr(true,
                vmbConfig.getServiceUrl(),
                vmbConfig.getTlsTrustCertsFile(),
                vmbConfig.getTlsKeyFile(),
                vmbConfig.getTlsCertFile(),
                topic
        );
        producers.put(topic, producer);
        logger.info("Initialized producer for topic: {}", topic);
    }

    @PreDestroy
    public void shutDown() {
        try {
            logger.info("Shutting down Pulsar producers");
            for (EclipsePulsarProducerNr producer : producers.values()) {
                if (producer != null) {
                    producer.shutDown();
                }
            }
        } catch (Throwable e) {
            logger.error("Exception while shutting down Pulsar producers", e);
        }
    }

    public void publish(String topic, String message) throws Exception {
        EclipsePulsarProducerNr producer = producers.get(topic);
        if (producer != null) {
            producer.publish(message);
            logger.info("Message sent to topic {}: {}", topic, message);
        } else {
            logger.error("Producer for topic {} not found", topic);
        }
    }

    public void publishAsync(String topic, String message, String partitionKey) {
        EclipsePulsarProducerNr producer = producers.get(topic);
        if (producer != null) {
            producer.publishAsyncWithNr(message, partitionKey);
            logger.info("Async message sent to topic {}: {}", topic, message);
        } else {
            logger.error("Producer for topic {} not found", topic);
        }
    }
}


package com.verizon.ucs.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.verizon.ucs.config.VMBProperties;
import com.verizon.ucs.model.NexusData1500;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;

@Service
public class NormaliseReactorService {

    private static final Logger logger = LoggerFactory.getLogger(NormaliseReactorService.class);

    @Autowired
    private VmbEclipsePublisherService pulsarPublisherService;

    @Autowired
    private VMBProperties vmbProperties;

    @Autowired
    private RetryTemplate retryTemplate;

    public void handleAndPublishData(NexusData1500 data, String deviceIp) throws Exception {
        long startTime = System.currentTimeMillis();

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
        String timestamp = dateFormat.format(new Date());

        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode ucgRawDataNode = (ObjectNode) objectMapper.valueToTree(data);
        Iterator<Map.Entry<String, JsonNode>> fields = ucgRawDataNode.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            if (field.getValue().isTextual()) {
                ucgRawDataNode.put(field.getKey(), field.getValue().asText().trim());
            }
        }

        String ucgRawData = objectMapper.writeValueAsString(ucgRawDataNode);
        Map<String, Object> ucgData = Map.of(
                "ucgTimestamp", timestamp,
                "ucgSource", deviceIp,
                "ucgRawData", ucgRawData,
                "ucgDeviceName", data.getDeviceType().trim(),
                "ucgType", "LIVE",
                "ucgTopic", vmbProperties.getTopicName()
        );

        String ucgDataJsonString = objectMapper.writeValueAsString(ucgData);

        long elapsedTime = System.currentTimeMillis() - startTime;
        if (elapsedTime > 15000) {
            logger.warn("Publishing time exceeded 15 seconds for device: {}", deviceIp);
            return;
        }

        retryTemplate.execute(context -> {
            try {
                pulsarPublisherService.publish("persistent://enmv/pub-snmp-perf-east/ECLIPSE-pub-snmp-perf-east-ms", "Publish successfully");
                logger.info("Data successfully published to VMB");
            } catch (Exception e) {
                logger.error("Publishing failed, retrying... Attempt {}", context.getRetryCount(), e);
                throw e;
            }
            return null;
        });
    }
}

package com.verizon.ucs.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.verizon.ucs.config.VMBProperties;
import com.verizon.ucs.model.NexusData1500;
import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;

@Service
public class NormaliseReactorService {

    private static final Logger logger = LoggerFactory.getLogger(NormaliseReactorService.class);

    @Autowired
    private PulsarPublisherService pulsarPublisherService;

    @Autowired
    private VMBProperties vmbProperties;

    @Autowired
    private RetryTemplate retryTemplate;

    public void handleAndPublishData(NexusData1500 data, String deviceIp) throws Exception {
        long startTime = System.currentTimeMillis();

        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
        String timestamp = dateFormat.format(new Date());

        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode ucgRawDataNode = (ObjectNode) objectMapper.valueToTree(data);
        Iterator<Map.Entry<String, JsonNode>> fields = ucgRawDataNode.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            if (field.getValue().isTextual()) {
                ucgRawDataNode.put(field.getKey(), field.getValue().asText().trim());
            }
        }

        String ucgRawData = objectMapper.writeValueAsString(ucgRawDataNode);
        Map<String, Object> ucgData = Map.of(
                "ucgTimestamp", timestamp,
                "ucgSource", deviceIp,
                "ucgRawData", ucgRawData,
                "ucgDeviceName", data.getDeviceType().trim(),
                "ucgType", "LIVE",
                "ucgTopic", vmbProperties.getTopicName()
        );

        String ucgDataJsonString = objectMapper.writeValueAsString(ucgData);

        long elapsedTime = System.currentTimeMillis() - startTime;
        if (elapsedTime > 15000) {
            logger.warn("Publishing time exceeded 15 seconds for device: {}", deviceIp);
            return;
        }

        retryTemplate.execute(context -> {
            try {
                pulsarPublisherService.publishMessage(ucgDataJsonString);
                logger.info("Data successfully published to VMB");
            } catch (Exception e) {
                logger.error("Publishing failed, retrying... Attempt {}", context.getRetryCount(), e);
                throw e;
            }
            return null;
        });
    }
}

For the above class please do implementation for this requirements and plss do not remove anything inside the classes methods the pulsar classes already there here the requirements and also please validate ucgdata

As a UCS developer, I want to normalize the power data retrieved from the Nexus 15xx model and publish it to the VMB so that 1PSC can consume the data in a consistent format.
RK-1: VMB instability may affect data publishing.
AS-1: VMB topic is configured and available.
*Technical Specifications*:

{"apiEndPoints":"\"UCS internal API endpoint for VMB publishing.\"","requestPayloadStructure":"\"Normalized power data (kW, kWh, etc.), timestamp.\"","responsePayloadStructure":"\"Success/failure status. HTTP status codes (200, 500).\"","authentication":"\"Secure communication between UCS and VMB.\"","errorHandling":"\"Error codes for publishing failures. Retry mechanism.\"","versioningInformation":"\"v1.0\"","performanceRequirementCriteria":"\"Publishing within 15 seconds\"","backwardCompatibility":"\"Yes\"","businessRules":"\"Data normalization rules.\"","loggingAndMonitoring":"\"Logs for successful/failed publishing attempts.\"","securityConsiderations":"\"Secure communication channel.\"","complianceRegulations":"\"N/A\"","documentationImpact":"\"Update documentation on VMB topic and data format.\""}

Given a Nexus 1450 device is unreachable, when UCS requests data, send an lov notification to vmb topic

while running the above showing this error plss resolve and do the implementation and correct the code

[2025-02-04 16:03:51,517 UTC] [WARN ] pulsar-client-io-1-9 org.apache.pulsar.client.impl.ConnectionPool - Failed to open connection to vmb-aws-us-east-1-nonprod.verizon.com/<unresolved>:6651 : java.net.UnknownHostException: Failed to resolve 'vmb-aws-us-east-1-nonprod.verizon.com' [A(1)] after 2 queries 
[2025-02-04 16:06:23,012 UTC] [INFO ] main com.verizon.ucs.UCSApplication - Starting UCSApplication using Java 17.0.6 with PID 23452 (C:\prod\ms-psc-polling\target\classes started by MARGARA in C:\prod\ms-psc-polling)
[2025-02-04 16:06:23,013 UTC] [INFO ] main com.verizon.ucs.UCSApplication - No active profile set, falling back to 1 default profile: "default"
[2025-02-04 16:06:24,280 UTC] [INFO ] main org.springframework.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port 8080 (http)
[2025-02-04 16:06:24,287 UTC] [INFO ] main org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8080"]
[2025-02-04 16:06:24,290 UTC] [INFO ] main org.apache.catalina.core.StandardService - Starting service [Tomcat]
[2025-02-04 16:06:24,290 UTC] [INFO ] main org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.28]
[2025-02-04 16:06:24,376 UTC] [INFO ] main org.apache.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
[2025-02-04 16:06:24,378 UTC] [INFO ] main org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1305 ms
[2025-02-04 16:06:24,695 UTC] [INFO ] main com.verizon.ucs.config.PulsarConfig - appConfig.getServiceUrl()pulsar+ssl://vmb-aws-us-east-1-nonprod.verizon.com:6651
[2025-02-04 16:06:25,182 UTC] [WARN ] main org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext - Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'nexusScheduler': Unsatisfied dependency expressed through field 'vmbConsumerService': Error creating bean with name 'vmbConsumerService': Unsatisfied dependency expressed through field 'pulsarClient': Error creating bean with name 'pulsarClient' defined in class path resource [com/verizon/ucs/config/PulsarConfig.class]: Failed to instantiate [org.apache.pulsar.client.api.PulsarClient]: Factory method 'pulsarClient' threw exception with message: class org.apache.pulsar.client.impl.PulsarClientImpl cannot be cast to class org.apache.pulsar.client.api.PulsarClient (org.apache.pulsar.client.impl.PulsarClientImpl and org.apache.pulsar.client.api.PulsarClient are in unnamed module of loader 'app')
[2025-02-04 16:06:25,185 UTC] [INFO ] main org.apache.catalina.core.StandardService - Stopping service [Tomcat]
[2025-02-04 16:06:25,201 UTC] [INFO ] main org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLogger - 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
[2025-02-04 16:06:25,224 UTC] [ERROR] main org.springframework.boot.SpringApplication - Application run failed
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'nexusScheduler': Unsatisfied dependency expressed through field 'vmbConsumerService': Error creating bean with name 'vmbConsumerService': Unsatisfied dependency expressed through field 'pulsarClient': Error creating bean with name 'pulsarClient' defined in class path resource [com/verizon/ucs/config/PulsarConfig.class]: Failed to instantiate [org.apache.pulsar.client.api.PulsarClient]: Factory method 'pulsarClient' threw exception with message: class org.apache.pulsar.client.impl.PulsarClientImpl cannot be cast to class org.apache.pulsar.client.api.PulsarClient (org.apache.pulsar.client.impl.PulsarClientImpl and org.apache.pulsar.client.api.PulsarClient are in unnamed module of loader 'app')
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:788)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:768)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:509)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1439)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:599)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)
	at com.verizon.ucs.UCSApplication.main(UCSApplication.java:13)
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'vmbConsumerService': Unsatisfied dependency expressed through field 'pulsarClient': Error creating bean with name 'pulsarClient' defined in class path resource [com/verizon/ucs/config/PulsarConfig.class]: Failed to instantiate [org.apache.pulsar.client.api.PulsarClient]: Factory method 'pulsarClient' threw exception with message: class org.apache.pulsar.client.impl.PulsarClientImpl cannot be cast to class org.apache.pulsar.client.api.PulsarClient (org.apache.pulsar.client.impl.PulsarClientImpl and org.apache.pulsar.client.api.PulsarClient are in unnamed module of loader 'app')
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:788)
	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:768)
	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:145)

