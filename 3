To implement the Health Metrics Dashboard using the given APIs and backend GraphQL schema, we can adapt the provided React code for the "Daily Trends" chart to align with your backend data structure and APIs.

Hereâ€™s how we can implement it step by step:


---

Frontend Implementation

1. Parent Chart (Aggregate View)

This will fetch and display daily alarm metrics (e.g., totalSizeOfFilesBytes, totalNumberOfFiles).

2. Child Chart (Drill-Down View)

This will show hourly metrics (sizeOfFilesBytes, numberOfFiles) for a specific date when a user clicks on a point in the parent chart.

3. API Integration

Use the alarmMetrics API to fetch data for both the parent and child charts.


---

Updated Code

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import { LineChart } from '@mui/x-charts/LineChart';
import { Box, Grid, TextField, Autocomplete, Button, Breadcrumbs, Link, Typography } from '@mui/material';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import dayjs, { Dayjs } from 'dayjs';
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import NavigateNextIcon from '@mui/icons-material/NavigateNext';
import LoadingButton from "@mui/lab/LoadingButton";

interface ParentData {
  date: string;
  totalSizeOfFilesBytes: number;
  totalNumberOfFiles: number;
  alarmMetricsDrillDownList: ChildData[];
}

interface ChildData {
  time: string;
  sizeOfFilesBytes: number;
  numberOfFiles: number;
}

const chartHeight = 450;

const ParentChart = ({ data, onDrillDown }: { data: ParentData[], onDrillDown: (date: string) => void }) => {
  const transformedData = data.map(item => ({
    collectionDate: item.date,
    totalSize: item.totalSizeOfFilesBytes,
    totalFiles: item.totalNumberOfFiles,
  }));

  const lineChartParams = {
    series: [
      {
        id: 'totalSize',
        datakey: 'totalSize',
        label: 'Total Size (Bytes)',
        data: transformedData.map(item => item.totalSize),
      },
      {
        id: 'totalFiles',
        datakey: 'totalFiles',
        label: 'Total Files',
        data: transformedData.map(item => item.totalFiles),
      },
    ],
    xAxis: [
      {
        data: transformedData.map(item => item.collectionDate),
        scaleType: "point",
        label: "Date",
      },
    ],
    height: chartHeight,
  };

  return (
    <Box width="100%">
      <LineChart
        {...lineChartParams}
        onAxisClick={(event, d) => {
          if (d && d.axisValue) onDrillDown(String(d.axisValue));
        }}
      />
    </Box>
  );
};

const ChildChart = ({ data }: { data: ChildData[] }) => {
  const detailedChartParams = {
    series: [
      {
        id: 'size',
        datakey: 'size',
        label: 'File Size (Bytes)',
        data: data.map(item => item.sizeOfFilesBytes),
      },
      {
        id: 'files',
        datakey: 'files',
        label: 'Number of Files',
        data: data.map(item => item.numberOfFiles),
      },
    ],
    xAxis: [
      {
        data: data.map(item => item.time),
        scaleType: "point",
        label: "Time",
      },
    ],
    height: chartHeight,
  };

  return <LineChart {...detailedChartParams} />;
};

const HealthMetricsDashboard: React.FC = () => {
  const [collectionTypes, setCollectionTypes] = useState<any[]>([]);
  const [selectedType, setSelectedType] = useState<any>(null);
  const [fromDate, setFromDate] = useState<Dayjs>(dayjs().subtract(7, 'days'));
  const [toDate, setToDate] = useState<Dayjs>(dayjs());
  const [loading, setLoading] = useState(false);
  const [parentData, setParentData] = useState<ParentData[]>([]);
  const [childData, setChildData] = useState<ChildData[]>([]);
  const [drillDownDate, setDrillDownDate] = useState<string | null>(null);

  useEffect(() => {
    // Fetch collection types
    axios.post('/graphql', {
      query: `
        query {
          availableAlarmCollectionTypes {
            typeId
            type
          }
        }
      `,
    }).then((response) => {
      setCollectionTypes(response.data.data.availableAlarmCollectionTypes);
    });
  }, []);

  const fetchParentData = async () => {
    setLoading(true);
    const formattedFromDate = fromDate.format('YYYY-MM-DD');
    const formattedToDate = toDate.format('YYYY-MM-DD');

    const response = await axios.post('/graphql', {
      query: `
        query {
          alarmMetrics(alarmMetricsRequest: {
            collectionType: "${selectedType?.type}",
            fromDate: "${formattedFromDate}",
            toDate: "${formattedToDate}"
          }) {
            date
            totalSizeOfFilesBytes
            totalNumberOfFiles
            alarmMetricsDrillDownList {
              time
              sizeOfFilesBytes
              numberOfFiles
            }
          }
        }
      `,
    });

    setParentData(response.data.data.alarmMetrics);
    setLoading(false);
  };

  const handleDrillDown = (date: string) => {
    const dataForDate = parentData.find(item => item.date === date)?.alarmMetricsDrillDownList || [];
    setChildData(dataForDate);
    setDrillDownDate(date);
  };

  return (
    <Box>
      <Grid container spacing={4}>
        <Grid item xs={12} sm={4}>
          <Autocomplete
            options={collectionTypes}
            getOptionLabel={(option) => option.type}
            onChange={(e, value) => setSelectedType(value)}
            renderInput={(params) => <TextField {...params} label="Collection Type" />}
          />
        </Grid>
        <Grid item xs={12} sm={4}>
          <LocalizationProvider dateAdapter={AdapterDayjs}>
            <DatePicker value={fromDate} onChange={setFromDate} label="From Date" />
          </LocalizationProvider>
        </Grid>
        <Grid item xs={12} sm={4}>
          <LocalizationProvider dateAdapter={AdapterDayjs}>
            <DatePicker value={toDate} onChange={setToDate} label="To Date" />
          </LocalizationProvider>
        </Grid>
        <Grid item xs={12}>
          <LoadingButton
            loading={loading}
            onClick={fetchParentData}
            variant="contained"
            disabled={!selectedType}
          >
            Fetch Data
          </LoadingButton>
        </Grid>
      </Grid>

      {drillDownDate ? (
        <ChildChart data={childData} />
      ) : (
        <ParentChart data={parentData} onDrillDown={handleDrillDown} />
      )}
    </Box>
  );
};

export default HealthMetricsDashboard;


---

Backend API Integration

This code queries the availableAlarmCollectionTypes and alarmMetrics APIs using GraphQL. Replace /graphql with your actual GraphQL endpoint.


---

Features

1. Parent chart shows daily trends (totalSizeOfFilesBytes, totalNumberOfFiles).


2. Clicking on a date drills down into hourly metrics.


3. Date pickers and dropdown allow filtering by date and collection type.



Let me know if further enhancements are needed!




Yes, you need to add or modify a file (e.g., graphqlQueries.ts) to include the necessary GraphQL queries and mutations required for your application. This will help streamline the GraphQL requests in your React components. Here's how you can organize and modify your graphqlQueries.ts file:


---

graphqlQueries.ts

import { gql } from '@apollo/client';

// Fetch available alarm collection types
export const GET_AVAILABLE_ALARM_COLLECTION_TYPES = gql`
  query GetAvailableAlarmCollectionTypes {
    availableAlarmCollectionTypes {
      typeId
      type
    }
  }
`;

// Fetch unique alarm vendors
export const GET_UNIQUE_ALARM_VENDORS = gql`
  query GetUniqueAlarmVendors {
    uniqueAlarmVendors
  }
`;

// Fetch unique alarm models
export const GET_UNIQUE_ALARM_MODELS = gql`
  query GetUniqueAlarmModels {
    uniqueAlarmModels
  }
`;

// Search alarm inventory by collection type
export const SEARCH_ALARM_INVENTORY = gql`
  query SearchAlarmInventory($collectionType: String!) {
    searchAlarmInventory(alarmInventorySearchRequest: { collectionType: $collectionType }) {
      id
      collectionType
      deviceIp
      deviceName
      model
      vendor
      loopback
      network
      pollerCluster
      pollerInterval
      lastUpdate
      physIp
    }
  }
`;

// Fetch alarm metrics (for parent and drill-down charts)
export const GET_ALARM_METRICS = gql`
  query GetAlarmMetrics($collectionType: String!, $fromDate: String!, $toDate: String!) {
    alarmMetrics(alarmMetricsRequest: { collectionType: $collectionType, fromDate: $fromDate, toDate: $toDate }) {
      date
      totalSizeOfFilesBytes
      totalNumberOfFiles
      alarmMetricsDrillDownList {
        time
        sizeOfFilesBytes
        numberOfFiles
      }
    }
  }
`;

// Example query for daily trends (if needed)
export const GET_DAILY_TRENDS = gql`
  query GetDailyTrends($ucgSourceID: Int, $fromDate: String!, $toDate: String!) {
    dailyTrends(trendsRequest: { ucgSourceID: $ucgSourceID, fromDate: $fromDate, toDate: $toDate }) {
      date
      totalSizeOfFilesBytes
      totalNumberOfFiles
      trendsDrillDownList {
        time
        sizeOfFilesBytes
        numberOfFiles
      }
    }
  }
`;


---

Changes to the Main File

Integrating the Queries

1. Install the @apollo/client library if not already done:

npm install @apollo/client graphql


2. Update your main file (OverallHealthMetrics.tsx) to import and use the queries:

import { useQuery } from '@apollo/client';
import { GET_AVAILABLE_ALARM_COLLECTION_TYPES, GET_ALARM_METRICS } from './graphqlQueries';



Fetching Data with Apollo Client

Replace the axios calls in your useEffect and event handlers with useQuery or useLazyQuery hooks from Apollo.

Example for Fetching Collection Types:

const { data: collectionTypesData, loading: collectionTypesLoading, error: collectionTypesError } = useQuery(GET_AVAILABLE_ALARM_COLLECTION_TYPES);

useEffect(() => {
  if (collectionTypesData) {
    setCollectionTypeList(collectionTypesData.availableAlarmCollectionTypes);
  }
  if (collectionTypesError) {
    showSnackbar('Error fetching collection types!');
    console.error('Error fetching collection types', collectionTypesError);
  }
}, [collectionTypesData, collectionTypesError]);

Example for Fetching Alarm Metrics:

const [fetchAlarmMetrics, { data: alarmMetricsData, loading: alarmMetricsLoading, error: alarmMetricsError }] = useLazyQuery(GET_ALARM_METRICS);

const handleFetchClick = async () => {
  fetchAlarmMetrics({
    variables: {
      collectionType: selectedCollectionType?.type,
      fromDate: dayjs(fromDate).format('YYYY-MM-DD'),
      toDate: dayjs(toDate).format('YYYY-MM-DD'),
    },
  });

  if (alarmMetricsData) {
    setResponseData(alarmMetricsData.alarmMetrics);
    setDataFetched(true);
  }
  if (alarmMetricsError) {
    showSnackbar("Error while fetching the data from the server");
    console.error('Error fetching data', alarmMetricsError);
  }
};


---

File Structure

Organize your files as follows:

src/
  components/
    OverallHealthMetrics.tsx
  graphql/
    graphqlQueries.ts
  utils/
    SnackbarContext.tsx


---

Advantages of Using graphqlQueries.ts

Reusability: Centralizes all your GraphQL queries/mutations, making them reusable across components.

Maintainability: Easier to update and manage query changes.

Readability: Keeps your main component clean and focused on UI and logic.


Let me know if you need further assistance!

