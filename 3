It seems like you're asking about the three APIs required to handle GraphQL queries that match your initial request, such as retrieving alarm data for scatter plots, filtering by protocol, and getting available protocols. Here's how to implement them with GraphQL using Spring Boot:

1. Get Scatter Plot Data API

Endpoint: GET /api/alarms/scatter-plot-data

This will query the data for scatter plot visualizations based on protocol and data type (e.g., number_of_msgs, size_of_msgs).


GraphQL Implementation:

You can implement this API as a GraphQL query. Here's how the controller method could look:

@QueryMapping
public List<ScatterPlotDataDTO> getScatterPlotData(@Argument String protocol, @Argument String dataType) {
    // Call the service method to fetch the data based on the protocol and dataType
    return dataService.getScatterPlotData(protocol, dataType);
}

This would match a query like:

query {
  getScatterPlotData(protocol: "SNMP", dataType: "number_of_msgs") {
    collectionName
    date
    yValue
  }
}

Service Layer Method:

public List<ScatterPlotDataDTO> getScatterPlotData(String protocol, String dataType) {
    // Fetch data based on protocol and data type
    return ucspRepository.getScatterPlotData(protocol, dataType);
}

Repository Method:

@Query("SELECT new com.example.dto.ScatterPlotDataDTO(c.collectionName, m.date, m.numberOfMsgs) " +
       "FROM UCSPAlarmInventory c " +
       "JOIN UCSPAlarmMetrics m ON c.collectionName = m.collectionName " +
       "WHERE c.ucgSource = :protocol AND m.dataType = :dataType")
List<ScatterPlotDataDTO> getScatterPlotData(String protocol, String dataType);


---

2. Filter Data by Protocol API

Endpoint: GET /api/alarms/scatter-plot-data/{protocol}

This would return the filtered data based on the protocol (e.g., SNMP, WSS).


GraphQL Implementation:

@QueryMapping
public List<ScatterPlotDataDTO> filterDataByProtocol(@Argument String protocol) {
    // Call the service to get filtered data based on protocol
    return dataService.filterDataByProtocol(protocol);
}

This would match a query like:

query {
  filterDataByProtocol(protocol: "SNMP") {
    collectionName
    date
    yValue
  }
}

Service Layer Method:

public List<ScatterPlotDataDTO> filterDataByProtocol(String protocol) {
    // Call repository to fetch data for the specific protocol
    return ucspRepository.filterDataByProtocol(protocol);
}

Repository Method:

@Query("SELECT new com.example.dto.ScatterPlotDataDTO(c.collectionName, m.date, m.numberOfMsgs) " +
       "FROM UCSPAlarmInventory c " +
       "JOIN UCSPAlarmMetrics m ON c.collectionName = m.collectionName " +
       "WHERE c.ucgSource = :protocol")
List<ScatterPlotDataDTO> filterDataByProtocol(String protocol);


---

3. Get Available Protocols API

Endpoint: GET /api/alarms/protocols

This API would return the list of available protocols (e.g., SNMP, WSS, etc.).


GraphQL Implementation:

@QueryMapping
public List<String> getAvailableProtocols() {
    // Call the service to get available protocols
    return dataService.getAvailableProtocols();
}

This would match a query like:

query {
  getAvailableProtocols {
    protocols
  }
}

Service Layer Method:

public List<String> getAvailableProtocols() {
    // Fetch available protocols from the repository
    return ucspRepository.getAvailableProtocols();
}

Repository Method:

@Query("SELECT DISTINCT c.ucgSource FROM UCSPAlarmInventory c")
List<String> getAvailableProtocols();


---

Summary

To summarize, here are the GraphQL-based APIs:

1. Get Scatter Plot Data:

GraphQL Query: getScatterPlotData(protocol: String, dataType: String)

Service: getScatterPlotData(protocol, dataType)

Repository: A custom query to fetch the data.



2. Filter Data by Protocol:

GraphQL Query: filterDataByProtocol(protocol: String)

Service: filterDataByProtocol(protocol)

Repository: A query to filter based on protocol.



3. Get Available Protocols:

GraphQL Query: getAvailableProtocols

Service: getAvailableProtocols

Repository: A query to fetch all distinct protocols.




Each query corresponds to a GraphQL resolver that connects to the service, which in turn uses the repository to fetch the data. The results are then returned in the required format for GraphQL to respond with.

