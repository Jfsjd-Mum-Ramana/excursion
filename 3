spring:
  application:
    name: ${APP_NAME:ms-vmb-consumer}

logging:
  vsad: ${VSAD_ID:ENMV}
  level.root: ${LOG_LEVEL:INFO}
  appenderref: ${LOG_APPENDER:STDOUT_JSON_PATTERN}
  logtruncate: ${LOG_TRUNCATE:false}

vmb:
  serviceUrl: ${VMB_SERVICE_URL:pulsar+ssl://vmb-aws-us-east-1-nonprod.verizon.com:6651}
  partitionCount: ${VMB_PARTITION_COUNT:3}
  topicName: ${TOPIC_NAME:NA}
  topicUrl: ${TOPIC_URL:persistent://enmv/gnmi-perf-ciena/grpc-proto-ut-ts}
  ucgSource: ${VMB_SOURCE:vcp-vmb-consumer}
  tlsCertFile: ${VMB_TLS_CERT_FILE:/Users/illasu/ucs/vmb/enmv.cert.pem}
  tlsKeyFile: ${VMB_TLS_KEY_FILE:/Users/illasu/ucs/vmb/enmv.key-pk8.pem}
  tlsTrustCertsFile: ${VMB_TRUST_CERTS_FILE:/Users/illasu/ucs/vmb/ca.cert.pem}
  topicspercontainer: ${TOPICSPERCONTAINER:1}
  subscriptionName: ${SUBSCRIPTION_NAME:SILLA-TEST-0}
  loggingRequired: ${LOGGING_REQUIRED:Y}
  appName: ${APP_NAME:ms-vmb-consumer}
  nrEnvStr: ${APPENV:NP}
  regionStr: ${REGION:kub84-np}
  podNamespace: ${POD_NAMESPACE:bbtpnj33vzbcucs-y-vz-npapp-enmv}
  podName: ${POD_NAME:NA}
  appNameSuffix: ${APP_NAME_SUFFIX:NA}
  s3Json: ${S3_JSON:{"mode":"I","s3Logging":"false","persistenceTimestampFlag":"true","batchProcessing":"true"}}
  s3ApiUrl: ${S3API_SERVICE_URL:ms-sthreeapi-idnipv4-service.twbgohaavzbcucs-y-vz-npapp-enmv.svc.cluster.local:9998}
  s3OverrideAuth: ${S3OVERRIDEAUTH:ucs-tunnel-np.enmv.ebiz.verizon.com}
  s3BucketKey: ${S3BUCKETKEY:BACNET-POLLER-CONSUMER}
  s3fullmessage: ${S3FULLMESSAGE:true}
  isGrpcPCSR: ${IS_GRPC_PCSR:FALSE}
  topicType: ${TOPIC_TYPE:NA}
  grpcDialType: ${DIAL_TYPE:NA}
  grpcStreamType: ${STREAMING_TYPE:NA}
  grpcUcgType: ${UCG_TYPE:NA}
  grpcNrAppName: ${NRAPPNAME:NA}

server:
  port: -1
  shutdown: graceful


package com.verizon.ucs.vmbc.service.s3;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.vmbc.exception.S3SaveException;
import com.verizon.ucs.vmbc.s3.grpc.proto.DataWrapperDTO;
import com.verizon.ucs.vmbc.s3.grpc.proto.LoadToS3ApiResponse;
import com.verizon.ucs.vmbc.util.Constants;
import com.verizon.ucs.vmbc.yaml.VMBProperties;
import org.apache.commons.collections.CollectionUtils;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.Messages;
import org.json.simple.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.Iterator;
import java.util.List;

@Service
@Scope("prototype")
public class S3MessageService {

    private static Logger logger = LoggerFactory.getLogger(S3MessageService.class);


    private final String newRelicEvents = "enmvVCPVMBConsumer:events";

    @Autowired
    private VMBProperties vmbProperties;

    @Autowired
    private S3GrpcClient s3GrpcClient;

    @Autowired
    private ObjectMapper objectMapper;


    public void saveMessagesToS3(final Messages<byte[]> messages,
                                 final boolean persistenceTimestampFlag) {

        if (messages != null) {

            try {
                logger.debug("saveMessagesToS3 - Messages list size {}", messages.size());
                messages.forEach(message -> {
                    saveMsgToS3(message, persistenceTimestampFlag);
                });
            } catch (Exception e) {
                logger.error("saveMessagesToS3 failed:", e);
            }

        }

    }

    public void saveMessagesListToS3(final List<Message<byte[]>> messages, final boolean persistenceTimestampFlag) {

        if (CollectionUtils.isNotEmpty(messages)) {

            try {
                logger.debug("saveMessagesListToS3 - Messages list size {}", messages.size());
                messages.forEach(message -> {
                    saveMsgToS3(message, persistenceTimestampFlag);
                });
            } catch (Exception e) {
                logger.error("saveMessagesListToS3 failed:", e);
            }

        }

    }

    public void saveMsgToS3(final Message<byte[]> message,
                            final boolean persistenceTimestampFlag) {

        try {
        	logger.debug("saveMsgToS3 - Message");
            String json = new String(message.getValue());
            JSONObject s3RequestPayload = objectMapper.readValue(json, JSONObject.class);
            logger.debug("publishToS3 s3RequestPayload === {}", s3RequestPayload.toString());
            s3RequestPayload.put("_pulsarId", message.getMessageId().toString());
            if (persistenceTimestampFlag) {
                s3RequestPayload.put("persistenceTimestamp", getUtcTimeStamp());
                logger.debug("publishToS3 persistenceTimestamp set is {}", s3RequestPayload.get("persistenceTimestamp"));
            }
            logger.debug("Save vmb-consumer message to s3 initiated ");
            if (s3RequestPayload != null) {
                publishToS3(s3RequestPayload, vmbProperties.getS3BucketKey());
                logger.debug("Save vmb-consumer message to s3 success ");
            }

        } catch (Exception e) {
            throw new S3SaveException("saveMsgToS3 failed", e);
        }
    }


    public void publishToS3(JSONObject dataObject, String s3BucketKey) {
        try {
            logger.debug("publishToS3 s3BucketKey === {}", s3BucketKey);
            logger.debug("publishToS3 dataObject.toJSONString() {}", dataObject.toString());
            JSONObject s3reqObject = new JSONObject();
            s3reqObject.put(Constants.S3_BUCKET_KEY, s3BucketKey);
            s3reqObject.put(Constants.PAYLOAD, dataObject.toString());
            DataWrapperDTO dataWrapperDTO = DataWrapperDTO.newBuilder().setPayload(s3reqObject.toString()).build();
            Iterator<LoadToS3ApiResponse> s3Response = s3GrpcClient.getStub().saveToS3(dataWrapperDTO);
            while (s3Response.hasNext()) {
                LoadToS3ApiResponse response = s3Response.next();
                logger.debug("Response: " + response.getResMessage());
            }
        } catch (Throwable t) {
            logger.error("publishToS3 failed", t);
        }
    }


    /**
     * Setting 24 hour utc timestamp
     */
    private String getUtcTimeStamp() {
        ZonedDateTime now = ZonedDateTime.now(ZoneId.of("UTC"));
        DateTimeFormatter dateTimeFormatter = new DateTimeFormatterBuilder().appendPattern("yyyy-MM-dd'T'HH:mm:ss.SSS").appendOffset("+HH:MM", "+00:00").toFormatter();
        return now.format(dateTimeFormatter);
    }

    public void saveMsgToS3(JSONObject s3RequestPayload) {
    	try{
    		logger.debug("saveMsgToS3 with ucgId: " + s3RequestPayload.toJSONString());
    		logger.debug("saveMsgToS3 with vmbProperties.getS3BucketKey() : " + vmbProperties.getS3BucketKey());
    		publishToS3(s3RequestPayload,vmbProperties.getS3BucketKey());
    	}
    	catch (Exception ex){
    		logger.error("Exception while calling s3 api. Error: " + ex.getMessage());
    		ex.printStackTrace();
    	}
    }

}


package com.verizon.ucs.vmbc.pulsar;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.newrelic.api.agent.NewRelic;
import com.verizon.ucs.vmbc.ordertest.*;
import com.verizon.ucs.vmbc.service.s3.S3MessageService;
import com.verizon.ucs.vmbc.yaml.VMBProperties;
import org.apache.commons.lang.StringUtils;
import org.apache.pulsar.client.api.*;
import org.apache.pulsar.client.impl.MessageImpl;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.io.IOException;
import java.time.Instant;
import java.util.*;

class VmbPulsarMessageProcessor implements Runnable {

	private final Logger logger = LoggerFactory.getLogger(VmbPulsarMessageProcessor.class);
	JSONParser parser = new JSONParser();

	private String serviceURL;
	private String topicURL;
	private String subscriptionName;
	private Long countMessages = 0L;
	private Long countDBMessages = 0L;
	private boolean isConsumerRunning=false;
	private boolean isShutdown=false;

	private PulsarClient client ;
	private Consumer<byte[]> consumer =null;
	private long startTime = System.currentTimeMillis();
	private Map<String, Object> basicAttributes = new HashMap<>();
	private boolean isLoggingRequired;
	private VMBCiscogrpctest vmbTest;
	private VMBCalixgrpctest calixTest;
	private VMBJgrpcordertest jgrParse;
	private VMBEPNMCCSParser parse;
	private VMBVnftrapordertest vnftrap;
	private VMBPonnmsordertest ponnms;
	private VMBMcpordertest mcptest;
	private VMBs4vzbtrapordertest s4vzbtrap;
	private VMBensetrapordertest ensetrap;
	private VMBTL1AOrdertest tl1Alarms;
	private S3MessageService s3MessageService;
	private final ObjectMapper mapper = new ObjectMapper();
	private String s3Flag;
	private String topicNameFromDB;
	private boolean s3LoggingRequired = false;
	private boolean persistenceTimestampFlag = false;
	private boolean dailyTableFlag = false;
	private boolean batchProcessing = false;
	private List<Message<byte[]>> messagesList = new ArrayList<Message<byte[]>>();
	private String collectionTimeString = "yyyyMMdd";
	private String retentionType = "";
	private int retentionValue = 0;
	private int consumerReceiverQueueSize = 0;
	private int s3BatchSize = 1000;
	private boolean orderTestingRequired = true;
	private boolean consumerLogging = false;
	String newRelicEvents = "enmvVMBConsumer:events";
	private VMBProperties vmbProperties;
	@Value("${vmb.s3fullmessage:true}")
	private boolean s3FullMessageFlag;

	private static ObjectMapper objectMapper = new ObjectMapper(); // Initialize ObjectMapper

	VmbPulsarMessageProcessor(VMBProperties vmbProperties, String topicURL, String subscriptionName, PulsarClient client,
			boolean isLoggingRequired, S3MessageService s3MessageService,
			String topicNameFromDB, ThreadPoolTaskExecutor s3ThreadPoolTaskExecutor) {
		this.serviceURL = vmbProperties.getServiceUrl();
		this.topicURL = topicURL;
		this.subscriptionName = subscriptionName;
		this.client = client;
		this.isLoggingRequired = isLoggingRequired;
		String region = vmbProperties.getRegionStr();
		this.vmbTest = new VMBCiscogrpctest(region);
		this.calixTest = new VMBCalixgrpctest(region);
		this.parse = new VMBEPNMCCSParser(region);
		this.jgrParse = new VMBJgrpcordertest(region);
		this.vnftrap = new VMBVnftrapordertest(region);
		this.ponnms = new VMBPonnmsordertest(region);
		this.mcptest=new VMBMcpordertest(region);
		this.s4vzbtrap=new VMBs4vzbtrapordertest(region);
		this.ensetrap=new VMBensetrapordertest(region);
		this.tl1Alarms=new VMBTL1AOrdertest(region);
		this.s3MessageService = s3MessageService;
		this.s3Flag = vmbProperties.s3Json;
		this.topicNameFromDB = topicNameFromDB;
		this.vmbProperties = vmbProperties;


		//Check if s3 flag contains json or not
		//if json set s3LoggingRequired,persistenceTimestampFlag,dailyTableFlag
		logger.debug("s3Flag Value {}", s3Flag);
		if(!s3Flag.isEmpty() && null != s3Flag && !"".equalsIgnoreCase(s3Flag) && !"null".equalsIgnoreCase(s3Flag)  && !"I".equalsIgnoreCase(s3Flag) && !"U".equalsIgnoreCase(s3Flag)) {
			String jsonString = s3Flag;
			JSONParser parser = new JSONParser();
			JSONObject jsonObj;
			try {


				jsonObj = (JSONObject) parser.parse(jsonString);
				int corePoolSize = Integer.parseInt(jsonObj.get("corePoolSize") !=null ? (String) jsonObj.get("corePoolSize") :"0" );
				int maxPoolSize = Integer.parseInt(jsonObj.get("maxPoolSize") !=null ? (String) jsonObj.get("maxPoolSize") :"0" );
				s3LoggingRequired =  Boolean.parseBoolean((String) jsonObj.get("s3Logging"));
				dailyTableFlag =  Boolean.parseBoolean((String) jsonObj.get("dailyTable"));
				persistenceTimestampFlag =  Boolean.parseBoolean((String) jsonObj.get("persistenceTimestampFlag"));
				batchProcessing  =Boolean.parseBoolean(jsonObj.get("batchProcessing")!= null ? (String)jsonObj.get("batchProcessing"):"true");

				retentionType = (String) jsonObj.get("retentionType");

				if(retentionType != null || retentionType != "") {
					if("DAILY".equalsIgnoreCase(retentionType)) {
						collectionTimeString = "yyyyMMdd";
					}

					if("HOURLY".equalsIgnoreCase(retentionType)) {
						collectionTimeString = "yyyyMMdd-HH";
					}

					if("MINUTELY".equalsIgnoreCase(retentionType)) {
						collectionTimeString = "yyyyMMdd-HHmm";
					}
				}

				retentionValue = Integer.parseInt(jsonObj.get("retentionValue") !=null ? (String) jsonObj.get("retentionValue") :"0" );

		        if(corePoolSize !=0)
		        	s3ThreadPoolTaskExecutor.setCorePoolSize(corePoolSize);
		        if(maxPoolSize !=0)
		        s3ThreadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);
		        consumerReceiverQueueSize = Integer.parseInt(jsonObj.get("consumerReceiverQueueSize") !=null ? (String) jsonObj.get("consumerReceiverQueueSize") :"0" );
				s3BatchSize = Integer.parseInt(jsonObj.get("s3BatchSize") !=null ? (String) jsonObj.get("s3BatchSize") :"1000" );
				orderTestingRequired =  Boolean.parseBoolean(jsonObj.get("orderTestingRequired")!= null ? (String)jsonObj.get("orderTestingRequired"):"true");
				consumerLogging =  Boolean.parseBoolean(jsonObj.get("consumerLogging")!= null ? (String)jsonObj.get("consumerLogging"):"false");

			} catch (ParseException e) {
				logger.error("Error occurred while parsing json data from S3 flag inside ConsumerThread constructor",topicURL,subscriptionName,e);
			}
		}
	}

	/**
	 * Shutdown both consumer and client .
	 */
	void shutdown(boolean isFromShutDown) {
		try {
			if(Objects.nonNull(consumer)) {

				//called unsubscribe method to avoid "Exclusive consumer is already connected"
				//consumer.unsubscribe();
				consumer.close();

				logger.info("Consumer closed for topic : {} and subscription name : {}",topicURL,subscriptionName);
			}
		}catch(Exception e) {
			logger.error("Error occurred while closing Consumer for topic : {} and subscription name : {}",topicURL,subscriptionName);
		}
		try {
			if(Objects.nonNull(client)) {
				client.shutdown();
				logger.info("Pulsar Client closed for topic : {} and subscription name : {}",topicURL,subscriptionName);
			}
		}catch(Exception e) {
			logger.error("Error occurred while closing Pulsar Client for topic : {} and subscription name : {}",topicURL,subscriptionName,e);
		}
		consumer=null;
		client=null;
		if(isFromShutDown)
			isShutdown=true;
		isConsumerRunning=false;
	}

	/**
	 * Healthcheck
	 */
	void healthCheck() {
		if(!isConsumerRunning) {
			init();
		}
	}

	/**
	 * This method is used to create client and consumer.
	 *
	 * @throws PulsarClientException
	 */
	private void init()  {
		try {
			//Setting the thread priority to the highest as consumer should not be impacted
			Thread.currentThread().setPriority(10);
			if(client != null){
				logger.info("client obj is :{}",client);

				//Added below if condition to close any existing subscription. Other wise will encounter 'Exclusive consumer already exists'
				if(consumer != null) {
					consumer.close();
				}
				https://medium.com/@ankushkhanna1988/apache-pulsar-key-shared-mode-sticky-consistent-hashing-a4ee7133930a

				//TODO: Paratameterize receiverqueue in CFT or Read from DB

				if(consumerReceiverQueueSize >0) {
					logger.info("Consumer Queue size from DB:"+consumerReceiverQueueSize);
					consumer = client.newConsumer()
							.topic(topicURL)
							.subscriptionName(subscriptionName)
							.subscriptionType(SubscriptionType.Key_Shared)
							.keySharedPolicy(KeySharedPolicy.autoSplitHashRange())
							.receiverQueueSize(consumerReceiverQueueSize)
							/*
							 * .batchReceivePolicy(BatchReceivePolicy.builder() .maxNumMessages(1000)
							 * .maxNumBytes(10*1024*1024) .timeout(500, TimeUnit.MILLISECONDS) .build() )
							 */.subscribe();
				}else {
					//Default Consumer Settings
					consumer = client.newConsumer()
							.topic(topicURL)
							.subscriptionName(subscriptionName)
							.subscriptionType(SubscriptionType.Key_Shared)
							.keySharedPolicy(KeySharedPolicy.autoSplitHashRange())
							//.receiverQueueSize(consumerReceiverQueueSize)
							/*
							 * .batchReceivePolicy(BatchReceivePolicy.builder() .maxNumMessages(1000)
							 * .maxNumBytes(10*1024*1024) .timeout(500, TimeUnit.MILLISECONDS) .build() )
							 */.subscribe();
				}

				isConsumerRunning=true;
			}
		} catch (PulsarClientException e) {
			isConsumerRunning=false;
			logger.error("Error in init for topic : {} and subscription name : {}",topicURL,subscriptionName,e);

		}
	}

	//@Trace(dispatcher=true)
	@SuppressWarnings("unchecked")
	@Override
	public void run() {
		Map<String, Object> attributes = new HashMap<>();
		basicAttributes.put("clusterID", System.getenv("POD_NAMESPACE"));
		basicAttributes.put("containerID", System.getenv("POD_NAME"));

		boolean isGrpcPCSR = false;

		if (this.vmbProperties != null) {

			String grpcpcsr = this.vmbProperties.getIsGrpcPCSR();

			if (grpcpcsr != null && !grpcpcsr.isEmpty()) {
				isGrpcPCSR = Boolean.parseBoolean(grpcpcsr);
			}

			if (isGrpcPCSR)

			{

				String topicType = this.vmbProperties.getTopicType();
				String dialType = this.vmbProperties.getGrpcDialType();
				String streamType = this.vmbProperties.getGrpcStreamType();
				String ucgType = this.vmbProperties.getGrpcUcgType();
				String nrAppName = this.vmbProperties.getGrpcNrAppName();

				basicAttributes.put("topicType", topicType);
				basicAttributes.put("dialType", dialType);
				basicAttributes.put("streamType", streamType);
				basicAttributes.put("ucgType", ucgType);
				basicAttributes.put("pcsrClientName", nrAppName);
			}

			logger.info("is gRPC pcsr :{}  ", isGrpcPCSR);

		}

		try {
			if(!isConsumerRunning) {
				init();
				logger.info("CONSUME FROM PULSAR - Start consuming from Service URL: {} , Topic Name: {}", serviceURL, topicURL);
			}
		} catch(Exception e) {
			logger.error("Exception while initializing consumer thread {}",e.getMessage());
		}
		while (true) {
			long threadStartTime = System.currentTimeMillis();
			long asyncTimerStart = 0;
			long asyncTimerEnd = 0;
			try {

				logger.debug("ConsumerThread inside run method, isShutdown:: {}", isShutdown);
				if (isShutdown)
					break;
				logger.debug("isConsumerRunning Inside ConsumerThread:: {}  {}", isConsumerRunning,Thread.currentThread().getName());
				if (consumer!=null && isConsumerRunning) {
					logger.debug("ConsumerThread inside run method, countMessages outside 30secs check:: {}", countMessages);

					if(batchProcessing) {
						//TODO: Implement batch processing
						logger.debug("isLoggingRequired batchProcessing true");
						Messages<byte[]> messages = consumer.batchReceive();

						logger.debug("isLoggingRequired Inside ConsumerThread:: {}", isLoggingRequired);
						logger.debug("isLoggingRequired Inside s3Flag:: {}", s3Flag);
						//logger.debug("isLoggingRequired - Messages list size {}", messages.size());

						if(StringUtils.contains(s3Flag, "I"))	{
							//Added this module to take care of the ucgId pushing to S3
							if(StringUtils.contains(s3Flag, "ucgIdEnabled")) {
								asyncTimerStart = System.currentTimeMillis();
								logger.debug("isLoggingRequired - ucgIdEnabled");
								try {
									logger.debug("isLoggingRequired Inside messages.size :: {}", messages.size());
									if(messages != null && messages.size() > 0) {

										messages.forEach(message -> {
											logger.debug("isLoggingRequired - Messages message {}", message);
											String json = new String(message.getValue());
											logger.debug("isLoggingRequired - Messages json {}", json);

											JSONObject s3RequestPayload = null;
											try {
												logger.debug("Parsing JSON: {}", json);
												if (json != null && !json.trim().isEmpty()) {
													JsonNode jsonNode = objectMapper.readTree(json);

													if (s3FullMessageFlag) {
														// Store the full JSON message
														try {
															String formattedJson = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonNode);
															logger.info("Full JSON Message:\n{}", formattedJson);
															logger.info("s3FullMessageFlag is true. Storing the full JSON to S3.");

															// Convert the formatted JSON string to a JSONObject
															JSONObject jsonObject = (JSONObject) parser.parse(formattedJson);

															// Pass the JSONObject to saveMsgToS3
															s3MessageService.saveMsgToS3(jsonObject);
														} catch (ParseException e) {
															logger.error("Error parsing formatted JSON to JSONObject: {}", e.getMessage());
														}
													} else {
														// Existing logic for extracting and storing specific fields
														if (jsonNode.has("ucgId")) {
															String ucgId = jsonNode.get("ucgId").asText();
															logger.debug("Extracted ucgId: {}", ucgId);
															JSONObject s3JsonData = new JSONObject();
															s3JsonData.put("ucgId", ucgId);
															s3MessageService.saveMsgToS3(s3JsonData);
														} else {
															logger.debug("ucgId not found in JSON - checking for SNMP LOV or PERF");
															if (jsonNode.has("ucgTopic")) {
																String ucgTopic = jsonNode.get("ucgTopic").asText();
																logger.debug("Extracted ucgTopic: {}", ucgTopic);
																//Handling LOV-ALARM
																if (ucgTopic.contains("hpov-snmp-alarm")) {
																	String ucgSource = jsonNode.get("ucgSource").asText();
																	String ucgType = jsonNode.get("ucgType").asText();
																	String ucgDeviceName = jsonNode.get("ucgDeviceName").asText();
																	String ucgTimestamp = jsonNode.get("ucgTimestamp").asText();
																	String ucgId = ucgSource+"-"+ucgType+"-"+ucgDeviceName+"-"+ucgTimestamp;
																	logger.debug("Extracted hpov-snmp-alarm-ucgId: {}", ucgId);
																	JSONObject s3JsonData = new JSONObject();
																	s3JsonData.put("ucgId", ucgId);
																	s3MessageService.saveMsgToS3(s3JsonData);
																}
																//Handling LOV
																if (ucgTopic.contains("hpov-lov")) {
																	String ucgSource = jsonNode.get("ucgSource").asText();
																	String ucgType = jsonNode.get("ucgType").asText();
																	String ucgDeviceName = jsonNode.get("ucgDeviceName").asText();
																	String ucgTimestamp = jsonNode.get("ucgTimestamp").asText();
																	String ucgId = ucgSource+"-"+ucgType+"-"+ucgDeviceName+"-"+ucgTimestamp;
																	logger.debug("Extracted hpov-lov-ucgId: {}", ucgId);
																	JSONObject s3JsonData = new JSONObject();
																	s3JsonData.put("ucgId", ucgId);
																	s3MessageService.saveMsgToS3(s3JsonData);
																}
															}
															//Handling PERF
															if (jsonNode.has("internalTopic")) {
																String internalTopic = jsonNode.get("internalTopic").asText();
																logger.debug("Extracted internalTopic: {}", internalTopic);
																if (internalTopic.contains("ENMV.HPOV.IP")) {
																	String deviceName = jsonNode.get("deviceName").asText();
																	String ifDescr = jsonNode.get("ifDescr").asText();
																	String loopback = jsonNode.get("loopback").asText();
																	String ifAlias = jsonNode.get("ifAlias").asText();
																	String dataType = jsonNode.get("dataType").asText();
																	String pollingInterval = jsonNode.get("pollingInterval").asText();
																	String intervalTime = jsonNode.get("intervalTime").asText();

																	if (ifDescr == null || ifDescr.isEmpty()) {
																		ifDescr = "ifDescr";
																	}
																	if (ifAlias == null || ifAlias.isEmpty()) {
																		ifDescr = "ifAlias";
																	}
																	String ucgId = deviceName.trim()+"-"+ifDescr.trim()+"-"+loopback.trim()+"-"+ifAlias.trim()+"-"+dataType.trim()+"-"+pollingInterval.trim()+"-"+internalTopic.trim()+"-"+intervalTime.trim();
																	logger.debug("Extracted ENMV.HPOV.IP-ucgId: {}", ucgId);
																	JSONObject s3JsonData = new JSONObject();
																	s3JsonData.put("ucgId", ucgId);
																	s3MessageService.saveMsgToS3(s3JsonData);
																}
															}
														}
													}
												} else {
													logger.error("JSON string is null or empty");
												}
											} catch (JsonMappingException e) {
												logger.error("Error in 1 {} ", e);
												e.printStackTrace();
											} catch (JsonProcessingException e) {
												logger.error("Error in 2 {} ", e);
												e.printStackTrace();
											}

										});
									}
								}catch (Exception e) {
									logger.error("Error from consumer thread while pushing ucgId to s3 service: "+e.getMessage());

									//TODO: POST error to New Relic
									attributes.put("mngMsgsRejected", messages.size());
									NewRelic.getAgent().getInsights().recordCustomEvent(newRelicEvents, attributes);
									NewRelic.addCustomParameter("VMBConsumer", topicURL);
									NewRelic.noticeError(e, attributes);
								}
								asyncTimerEnd = System.currentTimeMillis();

							} else {
								asyncTimerStart = System.currentTimeMillis();
								logger.debug("info - persist messages batch");
								//@Aysnc - Asynchronously hand over messages to thread pool for s3 persistence
								try {
									if(messages != null && messages.size() > 0) {
										logger.debug("debug - persist messages batch 1");
										s3MessageService.saveMessagesToS3(messages, persistenceTimestampFlag);
									}

								}catch (Exception e) {
									logger.error("Error from consumer thread while pushing to s3 service"+e.getMessage());
									//TODO: POST error to New Relic
									attributes.put("mngMsgsRejected", messages.size());
									NewRelic.getAgent().getInsights().recordCustomEvent(newRelicEvents, attributes);
									NewRelic.addCustomParameter("VMBConsumer", topicURL);
									NewRelic.noticeError(e, attributes);
								}
								asyncTimerEnd = System.currentTimeMillis();
							}
						}

						if (messages != null) {
							countMessages = countMessages + (long) messages.size();
							if (isLoggingRequired) {
								messages.forEach(message -> {
									if (message.getValue().length > 0) {
										String json = new String(message.getValue());
										logger.debug(new Date() + "," + json + "," + message.getKey() + "," + topicURL);
									}
								});
							}

							//TODO: Parameterize Order testing based on a flag in DB
							if(orderTestingRequired) {
								orderTesting(messages,null);
							}

						}

						// publish VMB consumer Data to NewRelic to analyze the data. topic has all data every 30 seconds.
						if (System.currentTimeMillis() - startTime >= 60000) {
							logger.debug("Received  {}  messages to VMB consumer.", countMessages);
							basicAttributes.forEach((k, v) -> attributes.put(k, v));
							attributes.put("messagesReceived", countMessages);
							attributes.put("eventName", "receive");
							attributes.put("topic", topicURL);
						    //TODO Comment below for running in local
							//attributes.put("awsRegion", "us-east-1");

						//	attributes.put("awsRegion", Regions.getCurrentRegion().getName());
							//String newRelicEvents = "enmvVCPVMBConsumer:events";
							NewRelic.getAgent().getInsights().recordCustomEvent(newRelicEvents, attributes);
							NewRelic.addCustomParameter("VMBConsumer", topicURL);
							countMessages = 0L;
							startTime = System.currentTimeMillis();
						}
						if (messages != null && consumer != null)
							consumer.acknowledge(messages);

						Thread.sleep(10);


					}else {

						logger.info("isLoggingRequired batchProcessing false");

					Message<byte[]> message =  consumer.receive();
//					applicationConfig.totalMsgCountAtomicInteger.incrementAndGet();

						logger.debug("isLoggingRequired Inside ConsumerThread:: {}", isLoggingRequired);
						if (message != null) {

							countMessages = countMessages + 1;
							if (isLoggingRequired) {
								if (message.getValue().length > 0) {
									String json = new String(message.getValue());
									logger.debug("Consumer:"+json);
								}
							}
//							s3Flag = "I";
							if(StringUtils.contains(s3Flag, "I"))	{
								asyncTimerStart = System.currentTimeMillis();
								messagesList.add(message);
								//TODO: Parameterize Batch size in DB entry
								if(messagesList.size() > s3BatchSize || System.currentTimeMillis() - startTime >= 30000) {

									//@Aysnc - Asynchronously hand over messages to thread pool for s3 persistence
									try {
										s3MessageService.saveMessagesListToS3(messagesList, persistenceTimestampFlag);
									}catch (Exception e) {
										logger.error("Error from consumer thread while pushing to s3 service"+e.getMessage());
										//TODO: POST error to New Relic
									}
									countDBMessages = countDBMessages + messagesList.size();
									messagesList = new ArrayList<Message<byte[]>>();
								}
								asyncTimerEnd = System.currentTimeMillis();
							}

							/*
							(StringUtils.contains(s3Flag, "I"))	{

								//Add messages to a list for batching to 3


								//TODO: Parameterize Batch size in DB entry


									//@Aysnc - Asynchronously hand over messages to thread pool for s3 persistence
									try {
									s3MessageService.saveMessagesToS3((Messages<byte[]>) message, persistenceTimestampFlag);
									}catch (Exception e) {
										logger.error("Error from consumer thread while pushing to s3 service"+e.getMessage());
										//TODO: POST error to New Relic
									}

									countDBMessages = countDBMessages + 1;

								}
							}*/



						}

						//TODO: Parameterize Order testing based on a flag in DB
						if(orderTestingRequired) {
							orderTesting(null,message);
						}


						if (System.currentTimeMillis() - startTime >= 30000) {


							ConsumerStats cStats = consumer.getStats();

							/*
							logger.info("MsgNumInReceiverQueue:"+cStats.getMsgNumInReceiverQueue());
							logger.info("getRateBytesReceived:"+cStats.getRateBytesReceived());
							logger.info("getNumReceiveFailed:"+cStats.getNumReceiveFailed());
							logger.info("getNumMsgsReceived:"+cStats.getNumMsgsReceived());
							logger.info("getRateMsgsReceived:"+cStats.getRateMsgsReceived());
							logger.info("getTotalMsgsReceived:"+cStats.getTotalMsgsReceived());
							logger.info("getMsgNumInSubReceiverQueue:"+cStats.getMsgNumInSubReceiverQueue());

							*/

							basicAttributes.forEach((k, v) -> attributes.put(k, v));
							logger.debug("Received  {}  messages to VMB consumer.", countMessages);
							logger.debug("Sent  {}  messages to s3.", countDBMessages);
							//Consumer Stats

							attributes.put("MsgNumInReceiverQueue",cStats.getMsgNumInReceiverQueue());
							attributes.put("getRateBytesReceived",cStats.getRateBytesReceived());
							attributes.put("getNumReceiveFailed",cStats.getNumReceiveFailed());
							attributes.put("getNumMsgsReceived",cStats.getNumMsgsReceived());
							attributes.put("getRateMsgsReceived",cStats.getRateMsgsReceived());
							attributes.put("getTotalMsgsReceived",cStats.getTotalMsgsReceived());
							attributes.put("getMsgNumInSubReceiverQueue",cStats.getMsgNumInSubReceiverQueue());



							attributes.put("messagesReceived", countMessages);
							attributes.put("eventName", "receive");
							attributes.put("topic", topicURL);
							if (!isGrpcPCSR) {
							attributes.put("pcsrClientName", topicNameFromDB);
							}
						    //TODO Comment below for running in local
							//attributes.put("awsRegion", "us-east-1");


							//attributes.put("awsRegion", Regions.getCurrentRegion().getName());
//							attributes.put("awsRegion", ApplicationConfig.awsRegionString);

							NewRelic.getAgent().getInsights().recordCustomEvent(newRelicEvents, attributes);
							NewRelic.addCustomParameter("VMBConsumer", topicURL);
							countMessages = 0L;
							countDBMessages = 0L;
							startTime = System.currentTimeMillis();

						}
						if (message != null && consumer != null)
							consumer.acknowledge(message);

				}
				}
			} catch (NullPointerException npe) {
				logger.error("Null Pointer exception while consuming from VMB pulsar", npe);
				//below is missing originally and is needed to re initialized during VMBConsumer.consumerHealthCheck()
				isConsumerRunning = false;
				throw npe;
			} catch (Exception ex) {
				isConsumerRunning = false;
				NewRelic.noticeError(ex, attributes);
				logger.error("exception while consuming from VMB pulsar", ex);
				ex.printStackTrace();
			}

			//TODO: Parameterize logger based on a flag in DB
			if(consumerLogging) {
				long threadEndTime = System.currentTimeMillis();
				long threadTimeElapsed = threadEndTime - threadStartTime;
				if(threadTimeElapsed>10) {
					logger.debug("Consumer processing time :{}",threadTimeElapsed);
//					applicationConfig.totalLargeMsgCountAtomicInteger.incrementAndGet();


					logger.debug("Async processing time :{}",asyncTimerEnd-asyncTimerStart);
				}

			}
		}
		logger.debug("ConsumerThread run method end");
	}





    /*
     * Modified Ordertesting method to support both batch processing and single message processing
     */
	private void orderTesting(Messages<byte[]> messages, Message<byte[]> singleMessage){
		JSONParser parser = new JSONParser();
		if (messages != null) {
			messages.forEach(message -> {
				validateOrdering(message);
			});
		}else if(singleMessage  != null) {
			validateOrdering(singleMessage);
		}
	}

	private void validateOrdering(Message<byte[]> message) {
		try {

//			logger.info("validateOrdering - meesage : {}", message.getValue());
			JSONObject jsonObject = (JSONObject) parser.parse(new String(message.getValue()));
			String ucgSource = getKeyFromJsonObject(jsonObject, "ucgSource");
			String ucgType = getKeyFromJsonObject(jsonObject, "ucgType");
			String metaData = getKeyFromJsonObject(jsonObject, "metaData");
			String json = new String(message.getValue());

			logger.debug("jsonObject for order test is" + jsonObject);
			if (topicURL.contains("epnmccs-yang")&& ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for CCS Difference");
				parse.setVmbTopic(topicURL);
				parse.checkDiff(json);
			}

			if (ucgSource.contentEquals("MCPDATA") && topicURL.contains("Eclipse-MCP-ALARM") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for MCPDATA Difference");
				mcptest.setVmbTopic(topicURL);
				mcptest.checkDiff(json);

			}
			if (ucgSource.contentEquals("CAGRPC2") && topicURL.contains("yangjson") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for CAGRPC2 Difference");
				vmbTest.setVmbTopic(topicURL);
				vmbTest.parseJson(json);
			}

			if(StringUtils.isNotBlank(metaData)) {
				JSONObject metadatJson = (JSONObject) parser.parse(metaData);
				String ucgSrc = getKeyFromJsonObject(metadatJson, "ucgSource");
				String ucgTyp = getKeyFromJsonObject(metadatJson, "ucgType");
				if (ucgSrc.contentEquals("CLGRPC")  && ucgTyp.contentEquals("PERF")) {
					logger.debug("Checking for CLGRPC Difference");
					calixTest.setVmbTopic(topicURL);
					calixTest.parseJson(json);
				}
			}

			if (ucgSource.contentEquals("JAGRPC2") && topicURL.contains("yangjson") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for JAGRPC2 Difference");
				jgrParse.setVmbTopic(topicURL);
				jgrParse.parseJson(json);
			}

			if (ucgSource.contentEquals("VNFTRAP") && topicURL.contains("Eclipse-vcp-traps-alarm") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for VNFTRAP Difference");
				vnftrap.setVmbTopic(topicURL);
				vnftrap.parseJson(json);
			}

			if (ucgSource.contentEquals("PONNMS") && topicURL.contains("PON-NMS-ALARM") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for PONNMS Difference");
				ponnms.setVmbTopic(topicURL);
				ponnms.parseJson(json);
			}

			if (ucgSource.contentEquals("S4VZBTRAP") && topicURL.contains("s4vzb-snmp-trap") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for S4VZBTRAP Difference");
				s4vzbtrap.setVmbTopic(topicURL);
				s4vzbtrap.parseJson(json);
			}
			if (ucgSource.contentEquals("") && topicURL.contains("eNSE-snmp-trap") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for ENSETRAP Difference");
				ensetrap.setVmbTopic(topicURL);
				ensetrap.parseJson(json);
			}
			if (ucgSource.contentEquals("TL1A") && ucgType.contentEquals("LIVE")) {
				logger.debug("Checking for TL1A Difference");
				tl1Alarms.setVmbTopic(topicURL);
				tl1Alarms.parseJson(json);
			}
		} catch (ParseException | IOException e) {
			logger.error(e.getMessage());
			//e.printStackTrace();
		}

	}

	public void setLoggingRequired(boolean loggingRequired) {
		isLoggingRequired = loggingRequired;
	}

	public void setS3Flag(String s3Flag) {
		this.s3Flag = s3Flag;
	}

	public void setS3LoggingRequired(boolean s3LoggingRequired) {
		this.s3LoggingRequired = s3LoggingRequired;
	}

	public void setPersistenceTimestampFlag(boolean persistenceTimestampFlag) {
		this.persistenceTimestampFlag = persistenceTimestampFlag;
	}

	public void setDailyTableFlag(boolean dailyTableFlag) {
		this.dailyTableFlag = dailyTableFlag;
	}

	public boolean isBatchProcessing() {
		return batchProcessing;
	}

	public void setBatchProcessing(boolean batchProcessing) {
		this.batchProcessing = batchProcessing;
	}

	public boolean isConsumerRunning() {
		return isConsumerRunning;
	}

	public String getKeyFromJsonObject(JSONObject jsonObj, String pattern) {
		String datakey = "";
		for (Object key : jsonObj.keySet()) {
			try {
				Object keyJsonObj = jsonObj.get(key.toString());
				if (key.toString().contains(pattern)) {
					datakey = keyJsonObj.toString();
					break;
				} else if (keyJsonObj instanceof JSONObject) {
					datakey = getKeyFromJsonObject((JSONObject) keyJsonObj, pattern);
				} else if (keyJsonObj instanceof String && keyJsonObj.toString().contains("{")) {
					JSONParser jp = new JSONParser();
					JSONObject json = (JSONObject) jp.parse(keyJsonObj.toString());
					datakey = getKeyFromJsonObject(json, pattern);
				}
			} catch (Exception e) {
				// e.printStackTrace();
			}
		}
		return datakey;
	}

	public String getRetentionType() {
		return retentionType;
	}

	public void setRetentionType(String retentionType) {
		this.retentionType = retentionType;
	}

	public int getRetentionValue() {
		return retentionValue;
	}

	public void setRetentionValue(int retentionValue) {
		this.retentionValue = retentionValue;

		if("DAILY".equalsIgnoreCase(retentionType)) {
			collectionTimeString = "yyyyMMdd";
		}

		if("HOURLY".equalsIgnoreCase(retentionType)) {
			collectionTimeString = "yyyyMMdd-HH";
		}

		if("MINUTELY".equalsIgnoreCase(retentionType)) {
			collectionTimeString = "yyyyMMdd-HHmm";
		}
	}

	public int getConsumerReceiverQueueSize() {
		return consumerReceiverQueueSize;
	}

	public void setConsumerReceiverQueueSize(int consumerReceiverQueueSize) {
		this.consumerReceiverQueueSize = consumerReceiverQueueSize;
	}

	public int getS3BatchSize() {
		return s3BatchSize;
	}

	public void setS3BatchSize(int s3BatchSize) {
		this.s3BatchSize = s3BatchSize;
	}

	public boolean isOrderTestingRequired() {
		return orderTestingRequired;
	}

	public void setOrderTestingRequired(boolean orderTestingRequired) {
		this.orderTestingRequired = orderTestingRequired;
	}

	public boolean isConsumerLogging() {
		return consumerLogging;
	}

	public void setConsumerLogging(boolean consumerLogging) {
		this.consumerLogging = consumerLogging;
	}

}
For the above it is set the values to publish the full message to JSOn but here unable to see the JSOn full message which is defined as s3jsonflag can you please resolve the issue and it will print the value when it is set to true or otherwise it will print extracted ucgId value give me the full classes updated with each and every step included
