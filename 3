Here’s the graphqlQueries.ts file containing the GraphQL queries for your use case. This file defines the queries for fetching protocols, scatter plot data, and detailed data for a specific date.


---

graphqlQueries.ts

import { gql } from '@apollo/client';

// Query to fetch available protocols
export const GET_PROTOCOLS = gql`
  query GetProtocols {
    protocols {
      id
      name
    }
  }
`;

// Query to fetch scatter plot data based on protocol and date range
export const GET_SCATTER_PLOT_DATA = gql`
  query GetScatterPlotData($protocol: String!, $fromDate: String!, $toDate: String!) {
    scatterPlotData(protocol: $protocol, fromDate: $fromDate, toDate: $toDate) {
      date
      totalUsage
      totalVolume
      detailedData {
        time
        usage
        volume
      }
    }
  }
`;

// Query to fetch detailed data for a specific date
export const GET_DETAILED_DATA = gql`
  query GetDetailedData($protocol: String!, $date: String!) {
    detailedData(protocol: $protocol, date: $date) {
      time
      usage
      volume
    }
  }
`;


---

Explanation of Queries:

1. GET_PROTOCOLS:

Fetches a list of protocols (e.g., SNMP, WSS) for filtering.

Returns the id and name of each protocol.



2. GET_SCATTER_PLOT_DATA:

Fetches scatter plot data based on the selected protocol and date range.

Returns:

date: The collection date.

totalUsage and totalVolume for each date.

detailedData: An array containing the time, usage, and volume for each drill-down data point.




3. GET_DETAILED_DATA:

Fetches detailed data for a specific date.

Returns an array of time, usage, and volume values for the selected date.





---

Example Usage in a Component:

import { useQuery } from '@apollo/client';
import { GET_SCATTER_PLOT_DATA, GET_PROTOCOLS } from './graphqlQueries';

const ExampleComponent = () => {
  const { data: protocolsData, loading: loadingProtocols } = useQuery(GET_PROTOCOLS);
  const { data: scatterPlotData, loading: loadingScatterPlot } = useQuery(GET_SCATTER_PLOT_DATA, {
    variables: { protocol: "SNMP", fromDate: "2024-11-01", toDate: "2024-12-01" },
  });

  if (loadingProtocols || loadingScatterPlot) return <div>Loading...</div>;

  console.log('Protocols:', protocolsData?.protocols);
  console.log('Scatter Plot Data:', scatterPlotData?.scatterPlotData);

  return <div>Data Loaded</div>;
};

This should help you seamlessly integrate GraphQL queries into your React application. Let me know if you need help setting up the Apollo Client!



Here's the complete code with the APIs integrated for data fetching, filtering, and fetching protocols. The existing frontend grid layout has been preserved, and only the logic for fetching data has been added.

Complete Code:

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import { LineChart } from '@mui/x-charts/LineChart';
import { AxisConfig, ChartsXAxisProps } from '@mui/x-charts';
import { Box, Grid, TextField, Autocomplete, Button, Breadcrumbs, Link, Typography } from '@mui/material';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import dayjs, { Dayjs } from 'dayjs';
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { useTheme } from "@mui/material/styles";
import { useSnackbar } from '../../utils/SnackbarContext';
import NavigateNextIcon from '@mui/icons-material/NavigateNext';
import HomeIcon from '@mui/icons-material/Home';
import LoadingButton from "@mui/lab/LoadingButton";

interface DataPoint {
    date: string;
    totalUsage: number;
    totalVolume: number;
    drillDownList: DetailedDataPoint[];
}

interface DetailedDataPoint {
    time: string;
    usage: number;
    volume: number;
}

const chartHeight = 450;
const childChartHeight = 410;

const ParentChart = ({ data, onDrillDown, setIsChildChartDisplayed }: { data: DataPoint[], onDrillDown: (date: string) => void, setIsChildChartDisplayed: (value: boolean) => void }) => {
    const theme = useTheme();

    const transformedData = data.map(item => ({
        collectionDate: item.date,
        totalUsage: item.totalUsage,
        totalVolume: item.totalVolume,
    }));

    const lineChartParams = {
        series: [
            {
                id: 'totalUsage',
                datakey: 'totalUsage',
                label: 'Usage',
                data: transformedData.map(item => item.totalUsage),
            },
            {
                id: 'totalVolume',
                datakey: 'totalVolume',
                label: 'Volume',
                data: transformedData.map(item => item.totalVolume),
            }
        ],
        xAxis: [{
            data: transformedData.map(item => item.collectionDate),
            id: 'axis1',
            dataKey: 'collectionDate',
            scaleType: "point",
            label: "Collected Date",
            tickLabelStyle: {
                angle: -25,
                textAnchor: 'end',
                fontSize: 10,
            },
            labelStyle: { transform: "translateY(30px)" },
            tickPlacement: 'middle', tickLabelPlacement: 'middle',
        } as AxisConfig<'point', string, ChartsXAxisProps>],
        height: chartHeight,
        margin: {
            left: 60,
            right: 10,
            top: 20,
            bottom: 80,
        },
        colors: theme.palette.distinctLightPalette
    };

    return (
        <Box width="100%">
            <LineChart
                {...lineChartParams}
                onAxisClick={(event, d) => {
                    if (d && d.axisValue) {
                        setIsChildChartDisplayed(true);
                        onDrillDown(String(d.axisValue));
                    } else {
                        console.error('collectionDate not found in data point');
                    }
                }}
            />
        </Box>
    );
};

const ChildChart = ({ date, data }: { date: string, data: DetailedDataPoint[] }) => {
    const theme = useTheme();
    const detailedLineChartsParams = {
        series: [
            {
                id: 'usage',
                datakey: 'usage',
                label: 'Usage',
                data: data.map(item => item.usage)
            },
            {
                id: 'volume',
                datakey: 'volume',
                label: 'Volume',
                data: data.map(item => item.volume)
            }
        ],
        xAxis: [{
            data: data.map(item => item.time),
            id: 'axis2',
            dataKey: 'time',
            scaleType: "point",
            label: "Collected Time on " + date,
        } as AxisConfig<'point', string, ChartsXAxisProps>],
        height: childChartHeight,
        colors: theme.palette.distinctLightPalette
    };

    return (
        <Box width="100%">
            <LineChart {...detailedLineChartsParams} />
        </Box>
    );
};

const OverallHealthMetrics: React.FC = () => {
    const theme = useTheme();
    const [collectionTypeList, setCollectionTypeList] = useState<any[]>([]);
    const [selectedCollectionType, setSelectedCollectionType] = useState<any>(null);
    const [fromDate, setSelectedFromDate] = useState<Dayjs>(dayjs().subtract(1, 'month'));
    const [toDate, setSelectedToDate] = useState<Dayjs | null>(dayjs());
    const [loading, setLoading] = useState<boolean>(false);
    const [dataFetched, setDataFetched] = useState<boolean>(false);
    const [responseData, setResponseData] = useState<DataPoint[]>([]);
    const [viewStack, setViewStack] = useState<string[]>([]);
    const [isChildChartDisplayed, setIsChildChartDisplayed] = useState(false);
    const { showSnackbar } = useSnackbar();

    useEffect(() => {
        // Fetch protocols for filtering
        const fetchProtocols = async () => {
            try {
                const response = await axios.get('/api/alarms/protocols');
                setCollectionTypeList(response.data.protocols.map((protocol: string) => ({
                    id: protocol,
                    name: protocol,
                })));
            } catch (error) {
                showSnackbar('Error fetching protocols!');
                console.error('Error fetching protocols', error);
            }
        };
        fetchProtocols();
    }, []);

    const handleCollectionTypeChange = (event: any, value: any) => {
        setSelectedCollectionType(value);
    };

    const handleReset = () => {
        setSelectedCollectionType(null);
        setSelectedFromDate(dayjs().subtract(1, 'month'));
        setSelectedToDate(dayjs());
        setResponseData([]);
        setViewStack([]);
        setIsChildChartDisplayed(false);
        setDataFetched(false);
    };

    const handleFetchClick = async () => {
        setLoading(true);
        setResponseData([]);
        const formattedFromDate = dayjs(fromDate).format('YYYY-MM-DD');
        const formattedToDate = dayjs(toDate).format('YYYY-MM-DD');

        try {
            const response = await axios.get('/api/alarms/scatter-plot-data', {
                params: {
                    protocol: selectedCollectionType?.id,
                    fromDate: formattedFromDate,
                    toDate: formattedToDate,
                }
            });

            if (response.data.scatter_plot_data.length > 0) {
                const transformedData = response.data.scatter_plot_data.map((item: any) => ({
                    date: item.date,
                    totalUsage: item.totalUsage,
                    totalVolume: item.totalVolume,
                    drillDownList: item.detailedData || [],
                }));

                setResponseData(transformedData);
                setDataFetched(true);
            } else {
                showSnackbar("No Data Found!");
            }
        } catch (error) {
            showSnackbar("Error While fetching the Data from the Server");
            console.error('Error fetching data', error);
        } finally {
            setLoading(false);
        }
    };

    const handleDrillDown = (date: string) => {
        setViewStack([...viewStack, date]);
    };

    const handleBreadcrumbClick = (index: number) => {
        setViewStack(viewStack.slice(0, index + 1));
    };

    const currentView = viewStack[viewStack.length - 1];
    const currentData = responseData.find(item => item.date === currentView)?.drillDownList || [];

    const isButtonDisabled = () => {
        return !selectedCollectionType || !fromDate || !toDate;
    };

    return (
        <Box sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            boxSizing: 'border-box',
        }}>
            <Grid container spacing={4} alignItems="flex-end">
                <Grid item xs={12} sm={6} md>
                    <Autocomplete
                        value={selectedCollectionType}
                        onChange={handleCollectionTypeChange}
                        loading={loading}
                        disablePortal
                        options={collectionTypeList}
                        getOptionLabel={(option) => option.name}
                        renderInput={(params: any) => <TextField {...params} label="Collection Type" placeholder="Collection Type" />}
                    />
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="Start Date"
                            sx={{ width: '100%', height: '100%' }}
                            value={fromDate}
                            onChange={(newValue: Dayjs | null) => {
                                setSelectedFromDate(newValue || dayjs());
                                if (newValue && toDate && newValue.isAfter(toDate)) {
                                    setSelectedToDate(null);
                                }
                            }}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6} md>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="End Date"
                            sx={{ width: '100%', height: '100%' }}
                            value={toDate}
                            minDate={fromDate}
                            onChange={(newValue) => setSelectedToDate(newValue)}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={2} sm={2} md={2} sx={{ display: 'flex' }}>
                    <Button variant="contained" onClick={handleReset} color="primary" sx={{ marginRight: 2 }}>Reset</Button>
                    <LoadingButton onClick={handleFetchClick} loading={loading} loadingIndicator="Fetching…" variant="contained"
                        disabled={isButtonDisabled()}>
                        <span>Fetch</span>
                    </LoadingButton>
                </Grid>
            </Grid>

            {dataFetched && !loading && (
                <Box sx={{ mt: 4, width: '100%', borderRadius: 2, border: '1px solid #e0e0e0', bgcolor: 'white' }}>

                    {isChildChartDisplayed && responseData.length > 0 && (
                        <Breadcrumbs aria-label="breadcrumb" separator={<NavigateNextIcon fontSize="small" />} sx={{ padding: '1%' }}>
                            <Link underline="hover" sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer', '&:hover': { textDecoration: 'underline !important', color: '#1976d2 !important' } }} color="primary" onClick={() => { setViewStack([]); setIsChildChartDisplayed(false); }} >
                                <HomeIcon sx={{ mr: 0.4 }} fontSize="inherit" />
                                Home
                            </Link>
                            {viewStack.map((view, index) => (
                                <Link
                                    key={view}
                                    color="inherit"
                                    sx={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
                                    underline="none"
                                    onClick={() => handleBreadcrumbClick(index)}
                                >
                                    {view}
                                </Link>
                            ))}
                        </Breadcrumbs>
                    )}

                    <Box mt={1} sx={{ width: '100%' }}>
                        {responseData.length > 0 ? (
                            <>
                                {currentView ? (
                                    <ChildChart date={currentView} data={currentData} />
                                ) : (
                                    <ParentChart data={responseData} onDrillDown={handleDrillDown} setIsChildChartDisplayed={setIsChildChartDisplayed} />
                                )}
                            </>
                        ) : (
                            <LineChart
                                height={chartHeight}
                                xAxis={[{ data: [], scaleType: 'point', }]}
                                yAxis={[{ min: 0, max: 10 }]}
                                series={[]}
                            />
                        )}
                    </Box>
                </Box>
            )}
        </Box>
    );
}

export default OverallHealthMetrics;


---

Key Changes:

1. API Integrations:

Protocol list fetched via /api/alarms/protocols.

Data fetched via /api/alarms/scatter-plot-data with protocol, fromDate, and toDate parameters.



2. Preserved Frontend Grid Layout:

No changes made to the grid or component structure.



3. Dynamic Data Transformation:

Transforms API responses to fit the ParentChart and ChildChart components.



4. Error Handling:

Snackbar notifications for API errors.




Let me know if additional functionality or changes are required!

