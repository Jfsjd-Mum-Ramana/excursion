Certainly! Below is the full implementation of the code classes with the necessary fixes and improvements for handling the NumberFormatException and properly sanitizing power and energy data.

1. NexusData.java

package com.verizon.ucs.model;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NexusData {

    private static final Logger log = LoggerFactory.getLogger(NexusData.class);

    private String firmware;
    private String deviceName;
    private String deviceType;
    private String van;
    private String vbn;
    private String vcn;
    private String vab;
    private String vbc;
    private String vca;
    private String ia;
    private String ib;
    private String ic;
    private String freq;
    private String pf;
    private String watt;
    private String wattHr;

    private String serial;
    private String mac;

    // Getters and Setters for all fields...

    /**
     * Parses the power string and returns a valid double value, or 0.0 if invalid.
     */
    public double getPower() {
        return parseValue(watt);
    }

    /**
     * Parses the energy string and returns a valid double value, or 0.0 if invalid.
     */
    public double getEnergy() {
        return parseValue(wattHr);
    }

    /**
     * Utility method to parse a string as a double, handling invalid inputs.
     * 
     * @param value The string value to parse
     * @return The parsed double value or 0.0 if invalid
     */
    private double parseValue(String value) {
        if (value == null || value.isEmpty()) {
            log.error("Invalid value: null or empty string.");
            return 0.0;
        }

        try {
            // Remove non-numeric characters (except for the decimal point)
            String cleaned = value.replaceAll("[^0-9.]", "").trim();
            if (cleaned.isEmpty()) {
                throw new NumberFormatException("No valid numeric data found in: " + value);
            }

            return Double.parseDouble(cleaned);
        } catch (NumberFormatException e) {
            // Log the error and return 0.0 if parsing fails
            log.error("Failed to parse value: " + value, e);
            return 0.0;
        }
    }

    @Override
    public String toString() {
        return "NexusData [firmware=" + firmware + ", deviceName=" + deviceName + ", deviceType=" + deviceType
                + ", van=" + van + ", vbn=" + vbn + ", vcn=" + vcn + ", vab=" + vab + ", vbc=" + vbc + ", vca=" + vca
                + ", ia=" + ia + ", ib=" + ib + ", ic=" + ic + ", freq=" + freq + ", pf=" + pf + ", watt=" + watt
                + ", wattHr=" + wattHr + ", serial=" + serial + ", mac=" + mac + "]";
    }

    // Getters and setters for each field

    public String getFirmware() {
        return firmware;
    }

    public void setFirmware(String firmware) {
        this.firmware = firmware;
    }

    public String getDeviceName() {
        return deviceName;
    }

    public void setDeviceName(String deviceName) {
        this.deviceName = deviceName;
    }

    public String getDeviceType() {
        return deviceType;
    }

    public void setDeviceType(String deviceType) {
        this.deviceType = deviceType;
    }

    public String getVan() {
        return van;
    }

    public void setVan(String van) {
        this.van = van;
    }

    public String getVbn() {
        return vbn;
    }

    public void setVbn(String vbn) {
        this.vbn = vbn;
    }

    public String getVcn() {
        return vcn;
    }

    public void setVcn(String vcn) {
        this.vcn = vcn;
    }

    public String getVab() {
        return vab;
    }

    public void setVab(String vab) {
        this.vab = vab;
    }

    public String getVbc() {
        return vbc;
    }

    public void setVbc(String vbc) {
        this.vbc = vbc;
    }

    public String getVca() {
        return vca;
    }

    public void setVca(String vca) {
        this.vca = vca;
    }

    public String getIa() {
        return ia;
    }

    public void setIa(String ia) {
        this.ia = ia;
    }

    public String getIb() {
        return ib;
    }

    public void setIb(String ib) {
        this.ib = ib;
    }

    public String getIc() {
        return ic;
    }

    public void setIc(String ic) {
        this.ic = ic;
    }

    public String getFreq() {
        return freq;
    }

    public void setFreq(String freq) {
        this.freq = freq;
    }

    public String getPf() {
        return pf;
    }

    public void setPf(String pf) {
        this.pf = pf;
    }

    public String getWatt() {
        return watt;
    }

    public void setWatt(String watt) {
        this.watt = watt;
    }

    public String getWattHr() {
        return wattHr;
    }

    public void setWattHr(String wattHr) {
        this.wattHr = wattHr;
    }

    public String getSerial() {
        return serial;
    }

    public void setSerial(String serial) {
        this.serial = serial;
    }

    public String getMac() {
        return mac;
    }

    public void setMac(String mac) {
        this.mac = mac;
    }
}

2. NexusService.java

package com.verizon.ucs.service;

import com.verizon.ucs.model.NexusData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NexusService {

    private static final Logger log = LoggerFactory.getLogger(NexusService.class);

    public void getNexusData(NexusData nexusData) {
        try {
            // Safely get power and energy data
            double power = nexusData.getPower();
            double energy = nexusData.getEnergy();

            log.info("Normalized Power Data: Power = " + power + " kW, Energy = " + energy + " kWh");

            // Further processing if needed...
        } catch (Exception e) {
            log.error("Error while processing Nexus data for device: " + nexusData.getDeviceName(), e);
        }
    }
}

3. NexusScheduler.java

package com.verizon.ucs.scheduler;

import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.service.NexusService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class NexusScheduler {

    private static final Logger log = LoggerFactory.getLogger(NexusScheduler.class);

    private final NexusService nexusService;

    public NexusScheduler() {
        this.nexusService = new NexusService();
    }

    public void scheduleTask(NexusData deviceData) {
        try {
            log.info("Processing device: " + deviceData.getDeviceName());

            // Call the service to get and process Nexus data
            nexusService.getNexusData(deviceData);
        } catch (Exception e) {
            log.error("Exception while processing device: " + deviceData.getDeviceName(), e);
        }
    }
}

Explanation:

1. NexusData.java:

Contains the fields for device data (watt, wattHr, etc.), along with methods to safely parse watt (power) and wattHr (energy) fields as double values.

Uses regular expressions to clean up non-numeric characters before parsing.

If the parsing fails, the method logs the error and returns a default value of 0.0.



2. NexusService.java:

Contains logic to fetch normalized power and energy data using getPower() and getEnergy() methods from NexusData.

Logs normalized data and handles any potential errors.



3. NexusScheduler.java:

Calls the NexusService to process device data.

Handles scheduling of tasks and logs any exceptions during processing.




Error Handling:

When the watt or wattHr values contain invalid strings (e.g., "227.82 k" or "COMM ERROR"), the error is logged, and the method safely returns a 0.0 value.


Logging:

The error logs will display the invalid values along with the device name to help in identifying issues with specific devices.


This full implementation should resolve the NumberFormatException issues and ensure that the power and energy data are processed safely even when encountering invalid values.

