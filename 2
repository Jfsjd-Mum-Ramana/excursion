I understand now that you're asking for a detailed implementation of **three specific APIs** based on your previous request: 1) Fetch Scatter Plot Data, 2) Filter Data by Protocol, and 3) Get Available Protocols.

Let's go through each API step by step, focusing on the backend service and controller logic. We'll be using **Spring Boot** with **GraphQL** to handle the requests.

### 1. **API to Fetch Scatter Plot Data**
   This API will fetch data based on the given protocol and data type.

### 2. **API to Filter Data by Protocol**
   This API will return filtered data based on the selected protocol.

### 3. **API to Get Available Protocols**
   This API will return a list of available protocols.

### Let's start by writing the detailed code for these three APIs:

---

### **Controller (`UCSPController`)**

```java
package com.verizon.ucs.restapi.controllers;

import com.verizon.ucs.restapi.model.ScatterPlotData;
import com.verizon.ucs.restapi.service.UCSPService;
import graphql.GraphQLException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.List;

@Controller
public class UCSPController {

    @Autowired
    private UCSPService uCSPService;

    // API to get scatter plot data based on protocol and data type
    @QueryMapping(value = "scatterPlotData")
    public List<ScatterPlotData> getScatterPlotData(@Argument String protocol, @Argument String dataType) {
        try {
            return uCSPService.getScatterPlotData(protocol, dataType);
        } catch (Exception e) {
            throw new GraphQLException("Error fetching scatter plot data", e);
        }
    }

    // API to filter data by protocol
    @QueryMapping(value = "filterByProtocol")
    public List<ScatterPlotData> getDataByProtocol(@Argument String protocol) {
        try {
            return uCSPService.filterDataByProtocol(protocol);
        } catch (Exception e) {
            throw new GraphQLException("Error fetching data by protocol", e);
        }
    }

    // API to get available protocols
    @QueryMapping(value = "availableProtocols")
    public List<String> getAvailableProtocols() {
        try {
            return uCSPService.getAvailableProtocols();
        } catch (Exception e) {
            throw new GraphQLException("Error fetching available protocols", e);
        }
    }
}
```

---

### **Service (`UCSPService`)**

In the service class, we'll define methods to handle the business logic for the three APIs.

```java
package com.verizon.ucs.restapi.service;

import com.verizon.ucs.restapi.model.ScatterPlotData;
import com.verizon.ucs.restapi.repository.UCSPRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UCSPService {

    @Autowired
    private UCSPRepository uCSPRepository;

    // Fetch scatter plot data based on protocol and data type
    public List<ScatterPlotData> getScatterPlotData(String protocol, String dataType) {
        return uCSPRepository.fetchScatterPlotData(protocol, dataType);
    }

    // Filter data by protocol
    public List<ScatterPlotData> filterDataByProtocol(String protocol) {
        return uCSPRepository.filterDataByProtocol(protocol);
    }

    // Get list of available protocols
    public List<String> getAvailableProtocols() {
        return uCSPRepository.fetchAvailableProtocols();
    }
}
```

---

### **Repository (`UCSPRepository`)**

The repository will interact with the database to fetch data using custom queries.

```java
package com.verizon.ucs.restapi.repository;

import com.verizon.ucs.restapi.model.ScatterPlotData;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface UCSPRepository extends JpaRepository<ScatterPlotData, Long> {

    // Query to fetch scatter plot data based on protocol and data type
    @Query("SELECT new com.verizon.ucs.restapi.model.ScatterPlotData(s.collectionName, s.date, s.value) " +
           "FROM ScatterPlotData s WHERE s.protocol = :protocol AND s.dataType = :dataType")
    List<ScatterPlotData> fetchScatterPlotData(String protocol, String dataType);

    // Query to filter data by protocol
    @Query("SELECT new com.verizon.ucs.restapi.model.ScatterPlotData(s.collectionName, s.date, s.value) " +
           "FROM ScatterPlotData s WHERE s.protocol = :protocol")
    List<ScatterPlotData> filterDataByProtocol(String protocol);

    // Query to fetch all available protocols
    @Query("SELECT DISTINCT s.protocol FROM ScatterPlotData s")
    List<String> fetchAvailableProtocols();
}
```

---

### **Model (`ScatterPlotData`)**

We need a model that represents the data structure for the scatter plot.

```java
package com.verizon.ucs.restapi.model;

import javax.persistence.Entity;
import javax.persistence.Id;
import java.time.LocalDateTime;

@Entity
public class ScatterPlotData {

    @Id
    private Long id;
    private String collectionName;
    private LocalDateTime date;
    private String protocol;
    private String dataType;
    private Long value;

    // Constructor
    public ScatterPlotData(String collectionName, LocalDateTime date, Long value) {
        this.collectionName = collectionName;
        this.date = date;
        this.value = value;
    }

    // Getters and Setters
    public String getCollectionName() {
        return collectionName;
    }

    public void setCollectionName(String collectionName) {
        this.collectionName = collectionName;
    }

    public LocalDateTime getDate() {
        return date;
    }

    public void setDate(LocalDateTime date) {
        this.date = date;
    }

    public Long getValue() {
        return value;
    }

    public void setValue(Long value) {
        this.value = value;
    }

    public String getProtocol() {
        return protocol;
    }

    public void setProtocol(String protocol) {
        this.protocol = protocol;
    }

    public String getDataType() {
        return dataType;
    }

    public void setDataType(String dataType) {
        this.dataType = dataType;
    }
}
```

---

### **Detailed Breakdown of the Code**:

#### **1. `UCSPController`**
- **scatterPlotData**: This query will fetch scatter plot data based on the provided protocol and data type.
- **filterByProtocol**: This query will return filtered data based on the selected protocol.
- **availableProtocols**: This query will return a list of all available protocols from the database.

#### **2. `UCSPService`**
- **getScatterPlotData**: Calls the repository method to fetch data based on protocol and data type.
- **filterDataByProtocol**: Filters data by the protocol.
- **getAvailableProtocols**: Fetches a list of all protocols from the database.

#### **3. `UCSPRepository`**
- **fetchScatterPlotData**: Retrieves scatter plot data from the database based on protocol and data type.
- **filterDataByProtocol**: Fetches filtered data by protocol.
- **fetchAvailableProtocols**: Fetches the distinct protocols present in the database.

---

### **Database Table Example (`scatter_plot_data`)**

The repository methods assume that there is a table called `scatter_plot_data` in the database with the following structure:

| Column        | Data Type   | Description                    |
|---------------|-------------|--------------------------------|
| `id`          | `BIGINT`    | Primary Key                    |
| `collectionName` | `VARCHAR` | Name of the collection         |
| `date`        | `TIMESTAMP` | Date when the data was recorded|
| `protocol`    | `VARCHAR`   | Protocol (e.g., SNMP, WSS)     |
| `dataType`    | `VARCHAR`   | Data type (e.g., number_of_msgs, size_of_msgs) |
| `value`       | `BIGINT`    | The value for the scatter plot |

---

### **Testing the APIs**:
To test the APIs, you can use a GraphQL client like Postman or GraphiQL to query the following:

1. **Fetch Scatter Plot Data**:
   ```graphql
   query {
     scatterPlotData(protocol: "SNMP", dataType: "number_of_msgs") {
       collectionName
       date
       value
     }
   }
   ```

2. **Filter Data by Protocol**:
   ```graphql
   query {
     filterByProtocol(protocol: "SNMP") {
       collectionName
       date
       value
     }
   }
   ```

3. **Get Available Protocols**:
   ```graphql
   query {
     availableProtocols
   }
   ```

---

This structure provides a robust backend with clear separation between the controller, service, and repository layers. It also gives flexibility to fetch scatter plot data, filter by protocol, and retrieve available protocols.


Certainly! Below is the **GraphQL schema** that aligns with the API endpoints you described for fetching scatter plot data, filtering data by protocol, and getting available protocols.

### **GraphQL Schema (`schema.graphqls`)**

```graphql
# Query type defines the available queries to retrieve data
type Query {

  # Fetch scatter plot data based on protocol and data type
  scatterPlotData(protocol: String!, dataType: String!): [ScatterPlotData!]!

  # Filter data based on the selected protocol
  filterByProtocol(protocol: String!): [ScatterPlotData!]!

  # Get available protocols
  availableProtocols: [String!]!
}

# Type that represents the scatter plot data returned in queries
type ScatterPlotData {
  collectionName: String!
  date: String!
  value: Long!
}

```

### **Explanation of the GraphQL Schema**:

1. **Query Type**:
    - **scatterPlotData**: Fetches scatter plot data based on the provided `protocol` and `dataType`. It returns a list of `ScatterPlotData` objects.
    - **filterByProtocol**: Filters the data by `protocol` (e.g., SNMP) and returns the filtered list of `ScatterPlotData` objects.
    - **availableProtocols**: Returns a list of available protocols (e.g., SNMP, WSS, gRPC, TL1).

2. **ScatterPlotData Type**:
    - Represents the data for each scatter plot point.
    - **collectionName**: The name of the collection.
    - **date**: The date of the data point.
    - **value**: The numeric value associated with the data point (e.g., number of messages or size of messages).

### **Schema Details**:

- The `Query` type defines the top-level queries that can be executed to interact with the GraphQL API.
- The `scatterPlotData` query expects two arguments: `protocol` (e.g., SNMP) and `dataType` (e.g., number_of_msgs or size_of_msgs).
- The `filterByProtocol` query accepts a `protocol` argument and returns all relevant data filtered by that protocol.
- The `availableProtocols` query returns all unique protocols that can be used for filtering the data.

### **Sample GraphQL Query**:

To fetch scatter plot data based on a protocol and data type:

```graphql
query {
  scatterPlotData(protocol: "SNMP", dataType: "number_of_msgs") {
    collectionName
    date
    value
  }
}
```

To filter data by protocol:

```graphql
query {
  filterByProtocol(protocol: "SNMP") {
    collectionName
    date
    value
  }
}
```

To get the available protocols:

```graphql
query {
  availableProtocols
}
```

### **How to Use the GraphQL Schema in Spring Boot**:

1. **Add GraphQL Dependencies**:
   In your `pom.xml` (for Maven) or `build.gradle` (for Gradle), include the necessary dependencies for Spring Boot with GraphQL support.

   **Maven**:
   ```xml
   <dependency>
       <groupId>com.graphql-java</groupId>
       <artifactId>graphql-java</artifactId>
       <version>17.3</version>
   </dependency>
   <dependency>
       <groupId>com.graphql-java</groupId>
       <artifactId>spring-boot-starter-graphql</artifactId>
       <version>3.2.0</version>
   </dependency>
   ```

   **Gradle**:
   ```gradle
   implementation 'com.graphql-java:spring-boot-starter-graphql:3.2.0'
   ```

2. **Place the Schema**:
   Place the schema file (`schema.graphqls`) in the `src/main/resources` folder.

3. **Spring Boot Configuration**:
   Spring Boot with the `spring-boot-starter-graphql` starter automatically handles the GraphQL endpoints, and you can query them using the `/graphql` endpoint.

By following this structure, you can interact with your GraphQL API to retrieve the desired data and perform the required operations for your scatter plot visualization.