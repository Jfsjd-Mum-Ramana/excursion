// Import necessary types if required
export const GET_COLLECTION_TYPES_QUERY = `
query {
    availableAlarmCollectionTypes {
        typeId
        type
    }
}
`;

export const GET_ALARM_METRICS_QUERY = `
query($collectionType: String!, $fromDate: String!, $toDate: String!) {
    alarmMetrics(alarmMetricsRequest: {
        collectionType: $collectionType,
        fromDate: $fromDate,
        toDate: $toDate
    }) {
        date
        totalSizeOfFilesBytes
        totalNumberOfFiles
        alarmMetricsDrillDownList {
            time
            sizeOfFilesBytes
            numberOfFiles
        }
    }
}
`;

export const GET_DETAILED_METRICS_QUERY = `
query($date: String!, $collectionType: String!) {
    alarmMetricsDrillDown(date: $date, collectionType: $collectionType) {
        time
        sizeOfFilesBytes
        numberOfFiles
    }
}
`;


DrillDown} setIsChildChartDisplayed={setIsChildChartDisplayed} /> )} </Box> )}

{/* Breadcrumbs */}
        {viewStack.length > 0 && (
            <Box mt={2}>
                <Breadcrumbs separator={<NavigateNextIcon fontSize="small" />}>
                    <Link color="inherit" onClick={() => handleBreadcrumbClick(-1)}>
                        <HomeIcon fontSize="small" />
                    </Link>
                    {viewStack.map((view, index) => (
                        <Link
                            key={index}
                            color={index === viewStack.length - 1 ? "textPrimary" : "inherit"}
                            onClick={() => handleBreadcrumbClick(index)}
                        >
                            {view}
                        </Link>
                    ))}
                </Breadcrumbs>
            </Box>
        )}
    </Box>
);

};

export default OverallHealthMetrics;

### Explanation of Inserted APIs:

1. **Fetch Collection Types API**:
   - GraphQL query for fetching available collection types.
   - The result is populated into the dropdown using `Autocomplete`.

2. **Fetch Metrics API**:
   - Retrieves metrics for the selected collection type and date range.
   - The data is formatted to populate both the parent and child charts.

3. **Drill Down**:
   - The `onAxisClick` event in `ParentChart` triggers a drill-down to display child chart data.

4. **Breadcrumbs Navigation**:
   - Breadcrumbs allow navigating back to parent chart views.

This code ensures the provided APIs are seamlessly integrated into the component. It maintains functionality for filters, chart visualization, and navigation between views.



Here's the updated OverallHealthMetrics component with the required APIs integrated. Each API is inserted into the relevant sections of the code. The APIs are used to fetch data for collection types, metrics, and detailed data points.

Updated Code:

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import { LineChart } from '@mui/x-charts/LineChart';
import { AxisConfig, ChartsXAxisProps } from '@mui/x-charts';
import { Box, Grid, TextField, Autocomplete, Button, Breadcrumbs, Link, Typography } from '@mui/material';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import dayjs, { Dayjs } from 'dayjs';
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { useTheme } from "@mui/material/styles";
import { useSnackbar } from '../../utils/SnackbarContext';
import NavigateNextIcon from '@mui/icons-material/NavigateNext';
import HomeIcon from '@mui/icons-material/Home';
import LoadingButton from "@mui/lab/LoadingButton";

interface DataPoint {
    date: string;
    totalUsage: number;
    totalVolume: number;
    drillDownList: DetailedDataPoint[];
}

interface DetailedDataPoint {
    time: string;
    usage: number;
    volume: number;
}

const chartHeight = 450;
const childChartHeight = 410;

const ParentChart = ({ data, onDrillDown, setIsChildChartDisplayed }: { data: DataPoint[], onDrillDown: (date: string) => void, setIsChildChartDisplayed: (value: boolean) => void }) => {
    const theme = useTheme();

    const transformedData = data.map(item => ({
        collectionDate: item.date,
        totalUsage: item.totalUsage,
        totalVolume: item.totalVolume,
    }));

    const lineChartParams = {
        series: [
            {
                id: 'totalUsage',
                datakey: 'totalUsage',
                label: 'Usage',
                data: transformedData.map(item => item.totalUsage),
            },
            {
                id: 'totalVolume',
                datakey: 'totalVolume',
                label: 'Volume',
                data: transformedData.map(item => item.totalVolume),
            }
        ],
        xAxis: [{
            data: transformedData.map(item => item.collectionDate),
            id: 'axis1',
            dataKey: 'collectionDate',
            scaleType: "point",
            label: "Collected Date",
            tickLabelStyle: {
                angle: -25,
                textAnchor: 'end',
                fontSize: 10,
            },
            labelStyle: { transform: "translateY(30px)" },
            tickPlacement: 'middle', tickLabelPlacement: 'middle',
        } as AxisConfig<'point', string, ChartsXAxisProps>],
        height: chartHeight,
        margin: {
            left: 60,
            right: 10,
            top: 20,
            bottom: 80,
        },
        colors: theme.palette.distinctLightPalette
    };

    return (
        <Box width="100%">
            <LineChart
                {...lineChartParams}
                onAxisClick={(event, d) => {
                    if (d && d.axisValue) {
                        setIsChildChartDisplayed(true);
                        onDrillDown(String(d.axisValue));
                    } else {
                        console.error('collectionDate not found in data point');
                    }
                }}
            />
        </Box>
    );
};

const ChildChart = ({ date, data }: { date: string, data: DetailedDataPoint[] }) => {
    const theme = useTheme();
    const detailedLineChartsParams = {
        series: [
            {
                id: 'usage',
                datakey: 'usage',
                label: 'Usage',
                data: data.map(item => item.usage)
            },
            {
                id: 'volume',
                datakey: 'volume',
                label: 'Volume',
                data: data.map(item => item.volume)
            }
        ],
        xAxis: [{
            data: data.map(item => item.time),
            id: 'axis2',
            dataKey: 'time',
            scaleType: "point",
            label: "Collected Time on " + date,
        } as AxisConfig<'point', string, ChartsXAxisProps>],
        height: childChartHeight,
        colors: theme.palette.distinctLightPalette
    };

    return (
        <Box width="100%">
            <LineChart {...detailedLineChartsParams} />
        </Box>
    );
};

const OverallHealthMetrics: React.FC = () => {
    const theme = useTheme();
    const [collectionTypeList, setCollectionTypeList] = useState<any[]>([]);
    const [selectedCollectionType, setSelectedCollectionType] = useState<any>(null);
    const [fromDate, setSelectedFromDate] = useState<Dayjs>(dayjs().subtract(1, 'month'));
    const [toDate, setSelectedToDate] = useState<Dayjs | null>(dayjs());
    const [loading, setLoading] = useState<boolean>(false);
    const [dataFetched, setDataFetched] = useState<boolean>(false);
    const [responseData, setResponseData] = useState<DataPoint[]>([]);
    const [viewStack, setViewStack] = useState<string[]>([]);
    const [isChildChartDisplayed, setIsChildChartDisplayed] = useState(false);
    const { showSnackbar } = useSnackbar();

    useEffect(() => {
        // Fetch available collection types
        const fetchCollectionTypes = async () => {
            try {
                const { data } = await axios.post('/api/graphql', {
                    query: `
                        query {
                            availableAlarmCollectionTypes {
                                typeId
                                type
                            }
                        }
                    `
                });
                setCollectionTypeList(data.data.availableAlarmCollectionTypes || []);
            } catch (error) {
                showSnackbar('Error fetching collection types!');
                console.error('Error fetching collection types', error);
            }
        };
        fetchCollectionTypes();
    }, []);

    const handleFetchClick = async () => {
        setLoading(true);
        const formattedFromDate = dayjs(fromDate).format('YYYY-MM-DD');
        const formattedToDate = dayjs(toDate).format('YYYY-MM-DD');

        try {
            const { data } = await axios.post('/api/graphql', {
                query: `
                    query {
                        alarmMetrics(alarmMetricsRequest: {
                            collectionType: "${selectedCollectionType?.type}",
                            fromDate: "${formattedFromDate}",
                            toDate: "${formattedToDate}"
                        }) {
                            date
                            totalSizeOfFilesBytes
                            totalNumberOfFiles
                            alarmMetricsDrillDownList {
                                time
                                sizeOfFilesBytes
                                numberOfFiles
                            }
                        }
                    }
                `
            });

            const metrics = data.data.alarmMetrics.map((metric: any) => ({
                date: metric.date,
                totalUsage: metric.totalNumberOfFiles,
                totalVolume: metric.totalSizeOfFilesBytes,
                drillDownList: metric.alarmMetricsDrillDownList.map((item: any) => ({
                    time: item.time,
                    usage: item.numberOfFiles,
                    volume: item.sizeOfFilesBytes,
                })),
            }));

            setResponseData(metrics);
            setDataFetched(true);
        } catch (error) {
            showSnackbar("Error While fetching the Data from the Server");
            console.error('Error fetching data', error);
        } finally {
            setLoading(false);
        }
    };

    const handleDrillDown = (date: string) => {
        setViewStack([...viewStack, date]);
    };

    const handleBreadcrumbClick = (index: number) => {
        setViewStack(viewStack.slice(0, index + 1));
    };

    const currentView = viewStack[viewStack.length - 1];
    const currentData = responseData.find(item => item.date === currentView)?.drillDownList || [];

    const isButtonDisabled = () => !selectedCollectionType || !fromDate || !toDate;

    return (
        <Box>
            {/* Filters */}
            <Grid container spacing={4}>
                <Grid item xs={12} sm={6}>
                    <Autocomplete
                        value={selectedCollectionType}
                        onChange={(event, value) => setSelectedCollectionType(value)}
                        options={collectionTypeList}
                        getOptionLabel={(option) => option.type}
                        renderInput={(params) => <TextField {...params} label="Collection Type" />}
                    />
                </Grid>
                <Grid item xs={12} sm={6}>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="Start Date"
                            value={fromDate}
                            onChange={(newValue) => setSelectedFromDate(newValue || dayjs())}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12} sm={6}>
                    <LocalizationProvider dateAdapter={AdapterDayjs}>
                        <DatePicker
                            label="End Date"
                            value={toDate}
                            onChange={(newValue) => setSelectedToDate(newValue)}
                        />
                    </LocalizationProvider>
                </Grid>
                <Grid item xs={12}>
                    <LoadingButton
                        loading={loading}
                        disabled={isButtonDisabled()}
                        onClick={handleFetchClick}
                    >
                        Fetch
                    </LoadingButton>
                </Grid>
            </Grid>

            {/* Charts */}
            {dataFetched && (
                <Box mt={4}>
                    {isChildChartDisplayed ? (
                        <ChildChart date={currentView} data={currentData} />
                    ) : (
                        <ParentChart data={responseData} onDrillDown={handle

