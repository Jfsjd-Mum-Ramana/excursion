package com.verizon.ucs.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.service.NexusService;

@RestController
@RequestMapping("/api/nexus")
public class PSCController {

    private static final Logger logger = LoggerFactory.getLogger(PSCController.class);

    @Autowired
    private NexusService service;

    @GetMapping("/data/{deviceIP}/{deviceType}")
    public ResponseEntity<Object> getNexusData(@PathVariable String deviceIP, @PathVariable String deviceType) {
        try {
            DeviceInfo info = new DeviceInfo();
            info.setDeviceIP(deviceIP);
            info.setModel("Nexus " + deviceType);  // Ensure proper model name

            Object data = service.processDevice(info);
            if (data == null) {
                return ResponseEntity.status(404).body("Device not found or unsupported.");
            }
            return ResponseEntity.ok(data);
        } catch (Exception e) {
            logger.error("Exception at /data/{}/{}", deviceIP, deviceType, e);
            return ResponseEntity.status(500).body("Internal Server Error");
        }
    }
}




package com.verizon.ucs.service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;
import java.util.function.Function;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.Nexus1500Parser;

@Service
public class NexusService {
    private static final Logger logger = LoggerFactory.getLogger(NexusService.class);

    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;

    @Autowired
    private PulsarPublisherService pulsarPublisherService;

    @Autowired
    private NormaliseReactorService normaliseReactorService;

    public Object processDevice(DeviceInfo device) throws Exception {
        String deviceType = extractDeviceType(device.getModel());
        Function<String, ?> parser = getParser(deviceType);

        if (parser == null) {
            logger.info("Unsupported device type: {}", deviceType);
            return null;
        }

        String response;
        try {
            response = config.isUseSampleData() ? readSampleData(deviceType) : fetchDataFromDevice(deviceType, device.getDeviceIP());
        } catch (Exception e) {
            logger.error("Device {} is unreachable: {}", device.getDeviceIP(), e.getMessage());

            // **Send LOV notification only for Nexus 1450**
            if ("1450".equals(deviceType)) {
                sendLovNotification(device.getDeviceIP());
            }
            return null;
        }

        Object data = parser.apply(response);
        logger.info("NexusData:: {}", data);

        // Normalize and Publish data to VMB
        normaliseReactorService.handleAndPublishData(data, device.getDeviceIP());

        return data;
    }

    private void sendLovNotification(String deviceIP) {
        String lovMessage = String.format("{\"event\": \"LOV\", \"device\": \"%s\", \"status\": \"unreachable\"}", deviceIP);
        try {
            pulsarPublisherService.publishMessage(lovMessage);
            logger.info("LOV notification sent for device {}", deviceIP);
        } catch (Exception e) {
            logger.error("Failed to send LOV notification: {}", e.getMessage());
        }
    }

    private String extractDeviceType(String model) {
        return model.replace("Nexus ", "").trim();
    }

    private Function<String, ?> getParser(String deviceType) {
        return switch (deviceType) {
            case "1250" -> response -> new Nexus1250Parser().parse(response);
            case "1450" -> response -> new Nexus1450Parser().parse(response);
            case "1500" -> response -> new Nexus1500Parser().parse(response);
            default -> null;
        };
    }

    private String readSampleData(String deviceType) throws Exception {
        String filePath = config.getSampleDataPaths().get(deviceType);
        if (filePath == null || filePath.isEmpty()) {
            throw new IllegalArgumentException("Sample data path not found for device type: " + deviceType);
        }
        return new String(Files.readAllBytes(Paths.get(filePath)));
    }

    private String fetchDataFromDevice(String deviceType, String deviceIP) throws Exception {
        return retryTemplate.execute(context -> {
            String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", deviceIP);
            logger.info("Fetching data from {} at IP: {}", deviceType, deviceIP);

            return switch (deviceType) {
                case "1250", "1500" -> restTemplate.getForObject(url, String.class);
                case "1450" -> restTemplate.postForObject(url, getHttpEntity(), String.class);
                default -> throw new IllegalArgumentException("Unsupported device type: " + deviceType);
            };
        });
    }

    private HttpEntity<String> getHttpEntity() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(createRequestPayload(Constants.REQUEST_BODY_1450), headers);
    }

    private String createRequestPayload(String[] chans) {
        try {
            return new ObjectMapper().writeValueAsString(Map.of("chans", chans));
        } catch (JsonProcessingException e) {
            logger.error("Error creating JSON request payload", e);
            return null;
        }
    }
}