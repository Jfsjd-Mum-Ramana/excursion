package com.verizon.ucs.service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;

import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.NexusParser;

@Service
public class NexusService {
    private static final Logger logger = LoggerFactory.getLogger(NexusService.class);

    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;

    @Autowired
    private NormaliseReactorService normaliseReactorService;

    @Autowired
    private PulsarPublisherService pulsarPublisherService;

    public NexusData getNexusData(DeviceInfo device) {
        try {
            String response;

            // Read from file if sample data is enabled
            if (config.isUseSampleData()) {
                response = readSampleData(device);
            } else {
                response = fetchDataFromDevice(device);
            }

            // Parse the response based on device type
            NexusParser parser = getParser(device.getModel());
            NexusData data = parser.parse(response);

            // Validate and publish data
            validateData(data);
            publishData(data, device.getDeviceIP());

        } catch (Exception e) {
            logger.error("Failed to process device {}: {}", device.getDeviceIP(), e.getMessage());
            if ("Nexus 1450".equals(device.getModel())) {
                sendLovNotification(device.getDeviceIP());
            }
        }
        return null;
    }
    private String readSampleData(DeviceInfo device) throws Exception {
        String deviceType = device.getModel().replace("Nexus ", "").trim();
        String filePath = config.getSampleDataPaths().get(deviceType);
        return new String(Files.readAllBytes(Paths.get(filePath)));
    }
    private void publishData(NexusData data, String deviceIp) throws Exception {
        String jsonData = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(data);
        pulsarPublisherService.publishMessage(jsonData);
        logger.info("Published data for device: {}", deviceIp);
    }

    private String fetchDataFromDevice(DeviceInfo device) throws Exception {
        String deviceType = device.getModel().replace("Nexus ", "").trim();
        String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", device.getDeviceIP());

        return retryTemplate.execute(context -> restTemplate.getForObject(url, String.class));
    }

    private HttpEntity<String> getHttpEntity() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(createRequestPayload(Constants.REQUEST_BODY_1450), headers);
    }

    private String createRequestPayload(String[] chans) {
        try {
            return new ObjectMapper().writeValueAsString(Map.of("chans", chans));
        } catch (Exception e) {
            logger.error("Error creating JSON request payload", e);
            return null;
        }
    }

    private NexusParser getParser(String deviceType) {
        return switch (deviceType) {
            case "1250" -> new Nexus1250Parser();
            case "1450" -> new Nexus1450Parser();
            case "1500" -> new Nexus1250Parser();
            default -> throw new IllegalArgumentException("Unsupported device type: " + deviceType);
        };
    }

    private void validateData(NexusData data) throws Exception {
        if (data == null || data.getDeviceName() == null || data.getDeviceName().trim().isEmpty()) {
            throw new Exception("Invalid Nexus data: missing device name");
        }
    }

    private void sendLovNotification(String deviceIP) {
        String lovMessage = String.format("{\"event\": \"LOV\", \"device\": \"%s\", \"status\": \"unreachable\"}", deviceIP);
        try {
            pulsarPublisherService.publishMessage(lovMessage);
            logger.info("LOV notification sent for device {}", deviceIP);
        } catch (Exception e) {
            logger.error("Failed to send LOV notification: {}", e.getMessage());
        }
    }
}


package com.verizon.ucs.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.verizon.ucs.config.VMBProperties;
import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;

@Service

public class NormaliseReactorService {

	private static final Logger logger = LoggerFactory.getLogger(NormaliseReactorService.class);

	@Autowired
	private PulsarPublisherService pulsarPublisherService;

	@Autowired
	private VMBProperties vmbProperties;

	public void handleAndPublishData(NexusData data, String deviceIp) throws Exception {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
		String timestamp = dateFormat.format(new Date());

		ObjectMapper objectMapper = new ObjectMapper();
		ObjectNode ucgRawDataNode = (ObjectNode) objectMapper.valueToTree(data);

		Iterator<Map.Entry<String, JsonNode>> fields = ucgRawDataNode.fields();
		while (fields.hasNext()) {
			Map.Entry<String, JsonNode> field = fields.next();
			if (field.getValue().isTextual()) {
				ucgRawDataNode.put(field.getKey(), field.getValue().asText().trim());
			}
		}

		String ucgRawData = objectMapper.writeValueAsString(ucgRawDataNode);
		logger.info("UCGRAW JSON DATA: {}", ucgRawData);

		Map<String, Object> ucgData = Map.of(
				"ucgTimestamp", timestamp,
				"ucgSource", deviceIp,
				"ucgRawData", ucgRawData,
				"ucgDeviceName", data.getDeviceName().trim(),
				"ucgType", "LIVE",
				"ucgTopic", vmbProperties.getTopicName()
		);

		String ucgDataJsonString = objectMapper.writeValueAsString(ucgData);
		logger.info("UCG JSON DATA: {}", ucgDataJsonString);
		pulsarPublisherService.publishMessage(ucgDataJsonString);
	}
}


Here this is the service and normalizereactor service classes just implement the code to use the two services and parse the models 
