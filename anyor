Scheduler Creation:

A scheduler must be created to trigger the stored procedure once a week at midnight UTC.
Stored Procedure (STP):

Create a single stored procedure to delete records from the hpov_s2im_devices_audit and hpov_s2im_transactions tables.
Ensure the stored procedure is optimized for performance and handles potential errors gracefully.
Execution Timing:

The stored procedure should be executed by the scheduler once a week at midnight UTC.
Testing and Validation:

Test the stored procedure to ensure it correctly deletes the records from both tables.
Validate that the scheduler triggers the stored procedure at the specified time.
Document the implementation and testing process, including any issues found and resolved.


Create a scheduler and it should run every day midnight (UTC) to call STP .
Develop a single stored procedure (STP) to delete records from the hpov_s2im_devices_audit and hpov_s2im_transactions tables.
Configure the STP to delete the records once a week .


transaction_id                               |server_id|is_updated_host|collected_time     |   --> Column values for hpov_s2im_transactions


operation|update_timestamp   |userid          |ip_address    |host_name                             |    --> Columns values for hpov_s2im_devices_audit


package com.verizon.ucs.service;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;
import com.verizon.ucs.model.ApiResponse;
import com.verizon.ucs.model.DeviceDTO;
import com.verizon.ucs.model.ServerDTO;
import com.verizon.ucs.model.TransactionDTO;
import com.verizon.ucs.properties.DbProperties;
import com.verizon.ucs.properties.MSRedisProperties;
import com.verizon.ucs.properties.ServerProperties;
import com.verizon.ucs.util.RestTemplateCustomizer;

@Component
public class ServerTransactionService {
	private static final Logger logger = LoggerFactory.getLogger(ServerTransactionService.class);

	@Autowired
	RestTemplateCustomizer restTemplateCustomizer;
	
	@Autowired
	private DbProperties databaseConfig;
	
	@Autowired
	private MSRedisProperties redisProperties;
	
	@Autowired
	private ServerProperties serverProperties;
	
	public void processServerTransactions() throws JsonProcessingException {
        List<ServerDTO> serverList = getServerListFromDatabase();
        List<TransactionDTO> transactions = generateTransactions(serverList);
        storeTransactionsInDatabase(transactions);

        List<DeviceDTO> devices = getHostListFromDatabase();
        String hostFileContent = generateHostFileContent(devices);

        updateHostFileOnServers(hostFileContent, transactions, serverList);
    }

    private List<ServerDTO> getServerListFromDatabase() {
        ApiResponse apiResponse = restTemplateCustomizer.getServerListFromDatabase(databaseConfig.getServerStpName(), "dummy");
        if (apiResponse.getResponseCode() == 200 && apiResponse.getData() != null) {
            return (List<ServerDTO>) apiResponse.getData();
        } else {
            logger.error("Failed to fetch server list from database: {}", apiResponse.getResponseMessage());
            return Collections.emptyList();
        }
    }

    private List<TransactionDTO> generateTransactions(List<ServerDTO> serverList) {
        List<TransactionDTO> transactions = new ArrayList<>();
        String formattedCollectedTime = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Timestamp(new Date().getTime()));

        for (ServerDTO server : serverList) {
            String threadName = Thread.currentThread().getName();
            String transactionId = generateTransactionId(redisProperties.getPodName());
            transactions.add(new TransactionDTO(transactionId, server.getServer_id(), false, formattedCollectedTime, server.getServer_ip()));
        }

        return transactions;
    }
	private String generateTransactionId(String podName) {
		return podName + "-" + UUID.randomUUID().toString().substring(0,6);
	}

    private void storeTransactionsInDatabase(List<TransactionDTO> transactions) {
        ApiResponse apiResponse = restTemplateCustomizer.storeTransactionsInDatabase(transactions, "insert");
        logger.info("Inserted transactions: {}", apiResponse.getResponseMessage());
    }

    private List<DeviceDTO> getHostListFromDatabase() {
        ApiResponse dbApiResponse = restTemplateCustomizer.getHostListFromDB(databaseConfig.getDeviceStpName(), "device");
        if (dbApiResponse.getResponseCode() == 200 && dbApiResponse.getData() != null) {
            return (List<DeviceDTO>) dbApiResponse.getData();
        } else {
            logger.error("Failed to fetch data from database: {}", dbApiResponse.getResponseMessage());
            return Collections.emptyList();
        }
    }

    private String generateHostFileContent(List<DeviceDTO> devices) {
        StringBuilder content = new StringBuilder();
        for (DeviceDTO device : devices) {
            content.append(device.getIpAddress()).append(" ").append(device.getHostName()).append("\n");
        }
        return content.toString();
    }

    private void updateHostFileOnServers(String content, List<TransactionDTO> transactions, List<ServerDTO> serverList) {
        Map<String, Boolean> serverPublishStatus = new HashMap<>();

        for (ServerDTO server : serverList) {
            boolean success = writeHostFileToServer(content, server);
            serverPublishStatus.put(server.getServer_ip(), success);

            if (success) {
                for (TransactionDTO transaction : transactions) {
                    if (transaction.getServerIP().equals(server.getServer_ip())) {
                        transaction.setUpdatedHost(true);
                        transaction.setCollectedTime(new Timestamp(System.currentTimeMillis()).toString());
                    }
                }
            }
        }

        // Update the transaction status in the database once
        restTemplateCustomizer.updateTransactionStatusInDatabase(transactions);
    }

    private boolean writeHostFileToServer(String content, ServerDTO server) {
        JSch jsch = new JSch();
        Session session = null;
        ChannelSftp channelSftp = null;

        try {
            // Load the private key as an InputStream
            Resource resource = new ClassPathResource(serverProperties.getSshPrivateKey());
            InputStream inputStream = resource.getInputStream();

            // Convert InputStream to byte array
            byte[] privateKeyBytes = inputStream.readAllBytes();

            // Add the private key to JSch
            jsch.addIdentity(serverProperties.getSshPrivateKey(), privateKeyBytes, null, serverProperties.getSshPassPhrase().getBytes());

            logger.info("sshUsername: {}, sshPassword: {}, sshHost: {}, sshPort: {}",
            		serverProperties.getSshUserName(),serverProperties.getSshPassPhrase(),
            		server.getServer_ip(),serverProperties.getSshPort());

            String sshHost = server.getServer_ip(); // Use the server_name as the IP address
            session = jsch.getSession(serverProperties.getSshUserName(), sshHost, serverProperties.getSshPort());
            session.setConfig("StrictHostKeyChecking", "no");
            session.connect();

            System.out.println("Connected to the server!");

            // Open an SFTP channel
            channelSftp = (ChannelSftp) session.openChannel("sftp");
            channelSftp.connect();

            logger.info("Writing host file content to " + serverProperties.getSshHostPath() + " on server: " + sshHost);
            // Write the content directly to the remote file
            try (OutputStream outputStream = channelSftp.put(serverProperties.getSshHostPath())) {
                outputStream.write(content.getBytes());
            }

            channelSftp.disconnect();
            session.disconnect();
            logger.info("Host file content written to " +  serverProperties.getSshHostPath() + " on server: " + sshHost);

            return true;
        } catch (JSchException | SftpException | IOException e) {
        	logger.error("Error While Writing File to Server{}", e);
            return false;
        } finally {
            if (channelSftp != null && channelSftp.isConnected()) {
                channelSftp.disconnect();
            }
            if (session != null && session.isConnected()) {
                session.disconnect();
                System.out.println("Disconnected from the server.");
            }
        }
    }
}


package com.verizon.ucs.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.sql.Timestamp;


public class TransactionDTO {
	@JsonProperty("transaction_id")
    private String transactionId;
	@JsonProperty("server_id")
    private int serverId;
	
    private String serverIP;
    
    @JsonProperty("is_updated_host")
    private boolean isUpdatedHost;
    
    @JsonProperty("collected_time")
    private String collectedTime;

    public TransactionDTO(String transactionId, int serverId, boolean isUpdatedHost, String collectedTime, String serverIP) {
        this.transactionId = transactionId;
        this.serverId = serverId;
        this.isUpdatedHost = isUpdatedHost;
        this.collectedTime = collectedTime;
        this.serverIP = serverIP;
    }

    public String getTransactionId() {
        return transactionId;
    }

    public void setTransactionId(String transactionId) {
        this.transactionId = transactionId;
    }

    public int getServerId() {
        return serverId;
    }

    public void setServerId(int serverId) {
        this.serverId = serverId;
    }
    

	public String getCollectedTime() {
		return collectedTime;
	}

	public void setCollectedTime(String collectedTime) {
		this.collectedTime = collectedTime;
	}

	public String getServerIP() {
		return serverIP;
	}

	public void setServerIP(String serverIP) {
		this.serverIP = serverIP;
	}

	public boolean isUpdatedHost() {
		return isUpdatedHost;
	}

	public void setUpdatedHost(boolean isUpdatedHost) {
		this.isUpdatedHost = isUpdatedHost;
	}

	@Override
	public String toString() {
		return "TransactionDTO [transactionId=" + transactionId + ", serverId=" + serverId + ", serverIP="
				+ serverIP + ", isUpdatedHost=" + isUpdatedHost + ", collectedTime=" + collectedTime + "]";
	}

	

}

package com.verizon.ucs.model;

/***
 * DTO to send large data, its used to load the data to db.
 */
import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.verizon.ucs.properties.DbProperties;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;



import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class DataWrapperDTO {

	private String stpName;	
	private String[] parameterList;	
	private String data;	
	
	public String getStpName() {
		return stpName;
	}
	public void setStpName(String stpName) {
		this.stpName = stpName;
	}
	
	public String[] getParameterList() {
		return parameterList;
	}
	public void setParameterList(String[] parameterList) {
		this.parameterList = parameterList;
	}
	public String getData() {
		return data;
	}
	public void setData(String data) {
		this.data = data;
	}
	
	
	
	
}
