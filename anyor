Below is the fully implemented code incorporating the requested changes:

NexusService now calls NormaliseReactorService to normalize and publish data.

LOV (LPV) notifications are sent if a Nexus 1450 device is unreachable.

A consumer service listens for published messages and logs them.



---

1. Updated NexusService

This service processes the device, normalizes the data, publishes it, and handles LOV notifications.

package com.verizon.ucs.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.model.NexusData1500;
import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.function.Function;

@Service
public class NexusService {
    private static final Logger logger = LoggerFactory.getLogger(NexusService.class);

    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;

    @Autowired
    private NormaliseReactorService normaliseReactorService;

    @Autowired
    private PulsarPublisherService pulsarPublisherService;

    public Object processDevice(DeviceInfo device) throws Exception {
        String deviceType = device.getModel().replace("Nexus ", "");
        Function<String, ?> parser = getParser(deviceType);

        if (parser != null) {
            Object data = getNexusData(device, parser);

            // Normalize and publish the data
            if (data instanceof NexusData1500) {
                normaliseReactorService.handleAndPublishData((NexusData1500) data, device.getDeviceIP());
            }

            return data;
        } else {
            logger.info("Unsupported device type: {}", deviceType);
            return null;
        }
    }

    private String fetchDataFromDevice(String deviceType, String deviceIP) throws Exception {
        return retryTemplate.execute(context -> {
            String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", deviceIP);
            logger.info("Fetching Nexus {} data from: {}", deviceType, url);

            try {
                if (deviceType.equals(Constants.DEVICE_TYPE_1450)) {
                    return restTemplate.postForObject(url, null, String.class);
                } else if (deviceType.equals(Constants.DEVICE_TYPE_1500)) {
                    return restTemplate.getForObject(url, String.class);
                } else {
                    throw new IllegalArgumentException("Unsupported device type: " + deviceType);
                }
            } catch (Exception e) {
                logger.error("Device {} is unreachable. Sending LOV notification...", deviceIP);
                sendLOVNotification(deviceIP, deviceType);
                throw e;
            }
        });
    }

    private void sendLOVNotification(String deviceIP, String deviceType) {
        Map<String, Object> lovNotification = Map.of(
                "deviceIP", deviceIP,
                "deviceType", deviceType,
                "status", "UNREACHABLE",
                "timestamp", new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(new Date())
        );

        try {
            String message = new ObjectMapper().writeValueAsString(lovNotification);
            pulsarPublisherService.publishMessage(message);
            logger.info("LOV notification sent: {}", message);
        } catch (JsonProcessingException e) {
            logger.error("Failed to send LOV notification", e);
        }
    }
}


---

2. Updated NormaliseReactorService

This service normalizes Nexus data and publishes it.

package com.verizon.ucs.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.verizon.ucs.config.VMBProperties;
import com.verizon.ucs.model.NexusData1500;
import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;

@Service
public class NormaliseReactorService {

    private static final Logger logger = LoggerFactory.getLogger(NormaliseReactorService.class);

    @Autowired
    private PulsarPublisherService pulsarPublisherService;

    @Autowired
    private VMBProperties vmbProperties;

    public void handleAndPublishData(NexusData1500 data, String deviceIp) throws Exception {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
        String timestamp = dateFormat.format(new Date());

        // Convert NexusData to JSON and trim spaces from all string values
        ObjectMapper objectMapper = new ObjectMapper();
        ObjectNode ucgRawDataNode = (ObjectNode) objectMapper.valueToTree(data);
        Iterator<Map.Entry<String, JsonNode>> fields = ucgRawDataNode.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> field = fields.next();
            if (field.getValue().isTextual()) {
                ucgRawDataNode.put(field.getKey(), field.getValue().asText().trim());
            }
        }

        String ucgRawData = objectMapper.writeValueAsString(ucgRawDataNode);
        logger.info("UCGRAW JSON DATA: {}", ucgRawData);

        Map<String, Object> ucgData = Map.of(
                "ucgTimestamp", timestamp,
                "ucgSource", deviceIp,
                "ucgRawData", ucgRawData,
                "ucgDeviceName", data.getDeviceType().trim(),
                "ucgType", "LIVE",
                "ucgTopic", vmbProperties.getTopicName()
        );

        String ucgDataJsonString = objectMapper.writeValueAsString(ucgData);
        logger.info("UCG JSON DATA: {}", ucgDataJsonString);
        pulsarPublisherService.publishMessage(ucgDataJsonString);
    }
}


---

3. Consumer Service (NexusConsumerService)

This service listens for published messages.

package com.verizon.ucs.service;

import com.verizon.ucs.service.pulsar.PulsarSubscriberService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import jakarta.annotation.PostConstruct;

@Service
public class NexusConsumerService {
    private static final Logger logger = LoggerFactory.getLogger(NexusConsumerService.class);

    @Autowired
    private PulsarSubscriberService pulsarSubscriberService;

    @PostConstruct
    public void init() {
        pulsarSubscriberService.subscribe("NexusDataTopic", this::processMessage);
    }

    private void processMessage(String message) {
        logger.info("Received Nexus Data: {}", message);
    }
}


---

Summary of Implementation

NexusService

Fetches data.

Normalizes it via NormaliseReactorService.

Publishes it using PulsarPublisherService.

Sends an LOV notification if the device is unreachable.


NormaliseReactorService

Normalizes Nexus 1500 data.

Publishes it to VMB.


NexusConsumerService

Listens for published messages and logs them.




---

Next Steps

Make sure your Pulsar broker is running.

Verify the VMBProperties config for correct topic names.

Check the logs to confirm data processing and publishing.


Would you like any enhancements, such as adding retries for publishing failures?

