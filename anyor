Documentation for MCP and Trap Trends Graph in Overall Health Metrics Dashboard

1. Introduction

This documentation covers the requirements and steps for implementing the MCP (Metrics Collection Protocol) and Trap trends graph in the Overall Health Metrics dashboard. It includes UI implementations, database structure, data sources, and API requirements to visualize a scatter plot that dynamically updates based on the selected data type and protocol.


---

2. Technical Requirements

UI Components:

Scatter Plot Visualization: The primary visualization is a scatter plot that dynamically updates based on user selections.

Color Coding for Different Protocols: Different protocols should be color-coded for easy identification.

Dynamic Updates Based on Data Type Selection: The scatter plot should update when the user selects a different data type or protocol from dropdowns or other controls.


Database Structure:

Tables and Relationships: The database must store metrics for different protocols and data types.

Schema Changes Required: Schema adjustments are necessary to support various protocols (SNMP, WSS, gRPC, TL1, syslog) and their data types.


Data Sources:

Identification and Integration: Data will be collected from SNMP performance metrics, WSS (WebSocket), gRPC, TL1 (Transaction Language 1), syslog, etc.

Data Collection, Processing, and Storage: This data will need to be collected through various protocols, processed, and stored for use in the scatter plot.


API Requirements:

Endpoints: The system requires REST API endpoints to fetch data for the scatter plot.

Request/Response Formats: APIs should return data in a format that is consumable by the front-end, such as JSON.

Dynamic Updates: The APIs should allow dynamic data updates based on data type selection, supporting continuous and real-time updates.



---

3. Tasks Breakdown

Analyze UI Implementations

UI Components and Interactions:

Scatter Plot: This plot will display metrics as points with x and y values. The x axis will represent timestamps, while the y axis will show metric values (e.g., performance, trap counts).

Color Coding: Each protocol (SNMP, WSS, gRPC, etc.) will be represented with a distinct color to differentiate them visually.

Dynamic Updates: The scatter plot should update dynamically when a user selects a different protocol or data type from dropdown menus. This can be achieved using React state and API calls.


Example UI Code (React/TypeScript):

import React, { useState, useEffect } from "react";
import { Scatter } from "react-chartjs-2";

const ScatterPlot: React.FC = () => {
  const [protocols, setProtocols] = useState([]);
  const [selectedProtocol, setSelectedProtocol] = useState<number>(1);
  const [dataTypes, setDataTypes] = useState([]);
  const [selectedDataType, setSelectedDataType] = useState<number>(1);
  const [metricsData, setMetricsData] = useState([]);

  useEffect(() => {
    fetch("/api/protocols").then(res => res.json()).then(setProtocols);
    fetch("/api/data-types").then(res => res.json()).then(setDataTypes);
  }, []);

  useEffect(() => {
    fetch(`/api/metrics?protocolId=${selectedProtocol}&dataTypeId=${selectedDataType}`)
      .then(res => res.json())
      .then(setMetricsData);
  }, [selectedProtocol, selectedDataType]);

  return (
    <div>
      <h3>Select Protocol</h3>
      <select onChange={(e) => setSelectedProtocol(Number(e.target.value))}>
        {protocols.map((protocol) => (
          <option key={protocol.id} value={protocol.id}>{protocol.name}</option>
        ))}
      </select>
      
      <h3>Select Data Type</h3>
      <select onChange={(e) => setSelectedDataType(Number(e.target.value))}>
        {dataTypes.map((dataType) => (
          <option key={dataType.id} value={dataType.id}>{dataType.name}</option>
        ))}
      </select>

      <Scatter
        data={{
          datasets: [{
            label: "Metrics Data",
            data: metricsData.map((item) => ({
              x: new Date(item.timestamp).getTime(),
              y: item.metric_value,
            })),
            backgroundColor: "rgba(54, 162, 235, 0.5)", // Example color
          }],
        }}
      />
    </div>
  );
};

export default ScatterPlot;


---

Analyze Database Structure

Required Tables:

Protocols Table: Stores information about different protocols (SNMP, gRPC, syslog, etc.).

Data Types Table: Stores data types (e.g., metric_value, trap_count).

Metrics Table: Stores the actual metric data for each protocol and data type, including a timestamp, metric value, and related protocol/data type IDs.


Example Schema:

-- Protocols Table
CREATE TABLE protocols (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- Data Types Table
CREATE TABLE data_types (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- Metrics Table
CREATE TABLE metrics (
    id SERIAL PRIMARY KEY,
    protocol_id INT NOT NULL REFERENCES protocols(id),
    data_type_id INT NOT NULL REFERENCES data_types(id),
    timestamp TIMESTAMP NOT NULL,
    metric_value FLOAT NOT NULL
);


---

Analyze Data Sources

Data Source Identification:

1. SNMP: Collect performance data using SNMP polls.


2. WSS (WebSocket): Real-time data collection for performance metrics.


3. gRPC: Use gRPC calls to fetch real-time metrics.


4. TL1 (Transaction Language 1): TL1 trap data collection from network devices.


5. Syslog: Collect trap messages and system logs.



Collection, Processing, and Storage:

Data Collection: Implement SNMP, WebSocket, and other protocols to collect raw data.

Data Processing: Transform collected data into a standard format for storage in the database.

Data Storage: Store processed data in the database using the schema defined above.



---

Analyze API Requirements

Required Endpoints:

1. GET /api/protocols - Fetches a list of available protocols.


2. GET /api/data-types - Fetches a list of available data types.


3. GET /api/metrics - Fetches metrics data based on protocol and data type selection.



API Request/Response Formats:

GET /api/protocols:


[
  { "id": 1, "name": "SNMP" },
  { "id": 2, "name": "gRPC" },
  { "id": 3, "name": "syslog" }
]

GET /api/data-types:


[
  { "id": 1, "name": "metric_value" },
  { "id": 2, "name": "trap_count" }
]

GET /api/metrics?protocolId=1&dataTypeId=2:


[
  { "timestamp": "2024-11-18T12:00:00", "metric_value": 75 },
  { "timestamp": "2024-11-18T12:05:00", "metric_value": 80 }
]


---

Create Database Tables

As shown in the earlier section, the following SQL script will create the necessary tables:

-- Create Protocols Table
CREATE TABLE protocols (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- Create Data Types Table
CREATE TABLE data_types (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- Create Metrics Table
CREATE TABLE metrics (
    id SERIAL PRIMARY KEY,
    protocol_id INT NOT NULL REFERENCES protocols(id),
    data_type_id INT NOT NULL REFERENCES data_types(id),
    timestamp TIMESTAMP NOT NULL,
    metric_value FLOAT NOT NULL
);


---

Populate Tables with Dummy Data

To test the system, we can insert some sample data:

-- Insert Sample Protocols
INSERT INTO protocols (name) VALUES ('SNMP'), ('gRPC'), ('syslog');

-- Insert Sample Data Types
INSERT INTO data_types (name) VALUES ('metric_value'), ('trap_count');

-- Insert Sample Metrics
INSERT INTO metrics (protocol_id, data_type_id, timestamp, metric_value) 
VALUES 
    (1, 1, '2024-11-18T12:00:00', 75),
    (1, 1, '2024-11-18T12:05:00', 80),
    (2, 2, '2024-11-18T12:10:00', 5);


---

4. Conclusion

This document outlines the requirements and steps to implement the MCP and Trap trends graph. The following key components were covered:

1. UI Implementation: Design and implementation of the scatter plot with dynamic updates based on protocol and data type selection.


2. Database Structure: Required tables and relationships to store protocol and data type information.


3. Data Sources: Identification of data sources and the approach for collecting and storing the data.


4. API Requirements: Endpoints to fetch and return data to the front-end in real-time.


5. Database Tables and Dummy Data: SQL scripts for creating the database schema and populating with sample



