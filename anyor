Got it! Here’s the updated implementation with all configurable values moved to application.yml.


---

1. application.yml (Configuration File)

nexus:
  useSampleData: false
  sampleDataPaths:
    "1250": "src/main/resources/sample/nexus_1250.json"
    "1450": "src/main/resources/sample/nexus_1450.json"
    "1500": "src/main/resources/sample/nexus_1500.json"

  apiEndpoints:
    "1250": "http://{siteIP}/nexus1250/data"
    "1450": "http://{siteIP}/nexus1450/data"
    "1500": "http://{siteIP}/nexus1500/data"

vmb:
  serviceUrl: ${VMB_SERVICE_URL:pulsar+ssl://vmb-aws-us-east-1-nonprod.verizon.com:6651}
  topicName: ${VMB_TOPIC_NAME:persistent://enmv/psc-alarm/nexus-meter-lov}
  partitionCount: ${VMB_PARTITION_COUNT:16}
  tlsCertFile: ${VMB_TLS_CERT_FILE:src/main/resources/ssl/vmb-cert.pem}
  tlsKeyFile: ${VMB_TLS_KEY_FILE:src/main/resources/ssl/vmb-key.pem}
  tlsTrustCertsFile: ${VMB_TRUST_CERTS_FILE:src/main/resources/ssl/vmb-ca.pem}


---

2. NexusConfig.java (Configuration Class)

package com.verizon.ucs.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.Map;

@Configuration
@ConfigurationProperties(prefix = "nexus")
public class NexusConfig {
    private boolean useSampleData;
    private Map<String, String> sampleDataPaths;
    private Map<String, String> apiEndpoints;

    public boolean isUseSampleData() {
        return useSampleData;
    }

    public void setUseSampleData(boolean useSampleData) {
        this.useSampleData = useSampleData;
    }

    public Map<String, String> getSampleDataPaths() {
        return sampleDataPaths;
    }

    public void setSampleDataPaths(Map<String, String> sampleDataPaths) {
        this.sampleDataPaths = sampleDataPaths;
    }

    public Map<String, String> getApiEndpoints() {
        return apiEndpoints;
    }

    public void setApiEndpoints(Map<String, String> apiEndpoints) {
        this.apiEndpoints = apiEndpoints;
    }
}


---

3. VmbConfig.java (VMB Configuration Class)

package com.verizon.ucs.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "vmb")
public class VmbConfig {
    private String serviceUrl;
    private String topicName;
    private int partitionCount;
    private String tlsCertFile;
    private String tlsKeyFile;
    private String tlsTrustCertsFile;

    public String getServiceUrl() {
        return serviceUrl;
    }

    public void setServiceUrl(String serviceUrl) {
        this.serviceUrl = serviceUrl;
    }

    public String getTopicName() {
        return topicName;
    }

    public void setTopicName(String topicName) {
        this.topicName = topicName;
    }

    public int getPartitionCount() {
        return partitionCount;
    }

    public void setPartitionCount(int partitionCount) {
        this.partitionCount = partitionCount;
    }

    public String getTlsCertFile() {
        return tlsCertFile;
    }

    public void setTlsCertFile(String tlsCertFile) {
        this.tlsCertFile = tlsCertFile;
    }

    public String getTlsKeyFile() {
        return tlsKeyFile;
    }

    public void setTlsKeyFile(String tlsKeyFile) {
        this.tlsKeyFile = tlsKeyFile;
    }

    public String getTlsTrustCertsFile() {
        return tlsTrustCertsFile;
    }

    public void setTlsTrustCertsFile(String tlsTrustCertsFile) {
        this.tlsTrustCertsFile = tlsTrustCertsFile;
    }
}


---

4. PulsarConfig.java (Pulsar Client Configuration Using YAML Values)

package com.verizon.ucs.config;

import org.apache.pulsar.client.api.PulsarClient;
import org.apache.pulsar.client.api.PulsarClientException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class PulsarConfig {

    @Autowired
    private VmbConfig vmbConfig;

    @Bean
    public PulsarClient pulsarClient() throws PulsarClientException {
        return PulsarClient.builder()
                .serviceUrl(vmbConfig.getServiceUrl())
                .build();
    }
}


---

5. VmbPublisher.java (Publishing to VMB Using YAML Configurations)

package com.verizon.ucs.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.VmbConfig;
import com.verizon.ucs.model.PowerData;
import org.apache.pulsar.client.api.Producer;
import org.apache.pulsar.client.api.PulsarClient;
import org.apache.pulsar.client.api.PulsarClientException;
import org.apache.pulsar.client.api.Schema;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class VmbPublisher {
    private static final Logger logger = LoggerFactory.getLogger(VmbPublisher.class);

    @Autowired
    private PulsarClient pulsarClient;

    @Autowired
    private VmbConfig vmbConfig;

    private final ObjectMapper objectMapper = new ObjectMapper();

    public void publish(PowerData powerData) {
        try (Producer<String> producer = pulsarClient.newProducer(Schema.STRING)
                .topic(vmbConfig.getTopicName())
                .create()) {

            String message = objectMapper.writeValueAsString(powerData);
            producer.send(message);
            logger.info("Successfully published power data: {}", message);
            
        } catch (PulsarClientException | JsonProcessingException e) {
            logger.error("Failed to publish power data to VMB", e);
        }
    }
}


---

6. NexusService.java (Updated to Use YAML Configurations)

package com.verizon.ucs.service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.model.PowerData;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.NexusParser;

@Service
public class NexusService {
    private static final Logger logger = LoggerFactory.getLogger(NexusService.class);

    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;

    @Autowired
    private VmbPublisher vmbPublisher;

    public NexusData getNexusData(DeviceInfo device) throws Exception {
        String response;
        String deviceType = device.getModel().replace("Nexus ", "");

        if (config.isUseSampleData()) {
            response = new String(Files.readAllBytes(Paths.get(config.getSampleDataPaths().get(deviceType))));
        } else {
            response = fetchDataFromDevice(deviceType, device.getDeviceIP());
        }

        NexusParser parser = getParser(deviceType);
        NexusData data = parser.parse(response);
        logger.info("NexusData Retrieved: {}", data);

        PowerData powerData = normalizePowerData(data);
        vmbPublisher.publish(powerData);

        return data;
    }

    private String fetchDataFromDevice(String deviceType, String deviceIP) throws Exception {
        return retryTemplate.execute(context -> {
            String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", deviceIP);
            return restTemplate.getForObject(url, String.class);
        });
    }

    private NexusParser getParser(String deviceType) {
        switch (deviceType) {
            case "1250":
                return new Nexus1250Parser();
            case "1450":
                return new Nexus1450Parser();
            case "1500":
                return new Nexus1250Parser();
            default:
                throw new IllegalArgumentException("Unsupported device type: " + deviceType);
        }
    }

    private PowerData normalizePowerData(NexusData data) {
        return new PowerData(data.getDeviceName(), data.getPowerKW(), data.getEnergyKWh(), Instant.now());
    }
}


---

✅ Final Summary

No hardcoded values—everything is configurable via YAML.

VMB URL, topic, and security configs are injected from application.yml.

Retry logic, normalization, and publishing are intact.


Let me know if you need further refinements!

