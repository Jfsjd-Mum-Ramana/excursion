API to Fetch Collection Types

Endpoint: /api/collection-types
Method: GET
Description: Fetches all collection types from the ucsp_collection_type table.

Now please make sure to create the above api by using above models here the details:

package com.verizon.ucs.restapi.controllers;

import com.verizon.ucs.restapi.dto.AlarmMetricsRequest;
import com.verizon.ucs.restapi.dto.ApiRequest;
import com.verizon.ucs.restapi.dto.TrendsRequest;
import com.verizon.ucs.restapi.model.*;

import com.verizon.ucs.restapi.service.UCSPService;
import graphql.GraphQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.SchemaMapping;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestParam;

import java.time.LocalDateTime;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Controller interface for UCS Portal Application with JPA
 */
@Controller
public class UCSPController {
    private static final Logger logger = LoggerFactory.getLogger(UCSPController.class);

    @Autowired
    private UCSPService uCSPService;



    @QueryMapping(value = "searchDevices")
    public List<Device> getFilteredDevices(@Argument ApiRequest apiRequest) {
        return uCSPService.searchDevices(apiRequest);
    }

    @QueryMapping(value = "allDevices")
    public List<Device> getAllDevices() {
        return uCSPService.getAllDevices();
    }

    @SchemaMapping(typeName = "Query", value = "uniqueModels")
    public List<String> getUniqueModels() {
        return uCSPService.getUniqueValues().get("models");
    }

    @QueryMapping(value = "uniqueVendors")
    public List<String> getUniqueVendors() {
        return uCSPService.getUniqueValues().get("vendors");
    }

    @QueryMapping(value = "dailyTrends")
    public List<TrendsDTO> getTrends(@Argument TrendsRequest trendsRequest) {
        try {
        	 Map<String, TrendsDTO> trendsDataMap = uCSPService.getDailyTrends(trendsRequest);
             return trendsDataMap.values().stream()
            		  .sorted(Comparator.comparing(TrendsDTO::getDate))
            		 .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching data", e);
            throw new GraphQLException("Database error: Unable to fetch data");
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }

    @QueryMapping
    public List<String> uniqueNetworks() {
        return uCSPService.getUniqueValues().get("networks");
    }

    @QueryMapping(value = "uniqueUCSPProjects")
    public List<UcspProject> getUniqueProjects() {
        List<UcspProject> ucgProjects = uCSPService.getUniqueProjects();
        return ucgProjects;
    }

    @QueryMapping(value = "uniqueUCGSources")
    public List<String> getUniqueUCGSources() {
        List<String> ucgSources = uCSPService.getUniqueUCGSources();
        return ucgSources;
    }

    @QueryMapping(value = "uniqueUCGSourcesByProject")
    public List<UcspProject> getUniqueUCGSourcesByProject(@Argument Long projectId) {
        try {
            return uCSPService.getUniqueUCGSourcesByProject(projectId);
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching UCG Sources", e);
            throw new GraphQLException("Database error: Unable to fetch UCG Sources for project ID: " + projectId);
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }
    
    @QueryMapping
    public List<String> uniqueNetworksByProtocol() {
        return uCSPService.uniqueNetworksByProtocol().get("snmp");
    }
    
    @QueryMapping
    public List<String> uniqueDevicesByNetwork(@Argument String network) {
        return uCSPService.uniqueDevicesByNetwork(network);
    }
    
    @QueryMapping(value = "avgNetworkByCoverage")
    public List<AvgNetworkCoverageDTO> avgNetworkByCoverage(@Argument String network,
            @Argument String fromDate, @Argument String toDate, @Argument String device) {
        try {
            Map<String, AvgNetworkCoverageDTO> detailedData = uCSPService.avgNetworkByCoverage(network, fromDate, toDate, device);
            return detailedData.values().stream()
                    .map(dto -> {
                        dto.setTotalCoverage(Double.parseDouble(dto.getFormattedTotalCoverage()));
                        return dto;
                    })
                    .sorted(Comparator.comparing(AvgNetworkCoverageDTO::getDate))
                    .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching network coverage", e);
            throw new GraphQLException("Database error: Unable to fetch network coverage for network: " + network);
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }

    @QueryMapping
    public List<UCSPAlarmInventory> filterInventoryByProtocol(@Argument String protocol) {
        return uCSPService.filterInventoryByProtocol(protocol);
    }

    // Query to get available protocols
    @QueryMapping
    public List<String> availableProtocols() {
        return uCSPService.getAvailableProtocols();
    }


    // Query to get scatter plot data by protocol

    @QueryMapping(value = "alarmMetrics")
    public List<AlarmMetricsDTO> getAlarmMetric(@Argument AlarmMetricsRequest alarmMetricstrendsRequest) {
        try {
            Map<String, AlarmMetricsDTO> alarmMetricsDataMap = uCSPService.getAlarmMetrics(alarmMetricstrendsRequest);
            return alarmMetricsDataMap.values().stream()
                    .sorted(Comparator.comparing(AlarmMetricsDTO::getDate))
                    .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching data", e);
            throw new GraphQLException("Database error: Unable to fetch data");
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }
//    @QueryMapping
//    public List<ScatterPlotData> getScatterPlotDataByProtocol(@Argument String protocol) {
//        return uCSPService.getScatterPlotDataByProtocol(protocol);
//    }
}

Thisis the controller class already I have created the API plss implement service and repository 

use reference this repository:
package com.verizon.ucs.restapi.repository;

import com.verizon.ucs.restapi.model.Trends;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Date;
import java.util.List;
import java.util.Map;


public interface UCSPTrendsRepository extends JpaRepository<Trends, Long> {

//    @Query("SELECT t FROM Trends t WHERE t.ucgSourceID = ?1 AND t.collectionDate BETWEEN ?2 AND ?3")
//    List<Trends> findDailyTrends( int ucgSourceId,  Date fromDate,  Date toDate);
	
	  @Query(nativeQuery = true, value = "SELECT CAST(collection_timestamp AS DATE) as date, TO_CHAR(collection_timestamp, 'HH24:MI') as time, " +
	            "SUM(size_of_files_bytes) as sizeOfFilesBytes, SUM(number_of_files) as numberOfFiles " +
	            "FROM ucsp_trends_raw " +
	            "WHERE ucg_source_id = :ucgSourceId AND CAST(collection_timestamp AS DATE) BETWEEN :fromDate AND :toDate " +
	            "GROUP BY CAST(collection_timestamp AS DATE), TO_CHAR(collection_timestamp, 'HH24:MI') " +
	            "ORDER BY CAST(collection_timestamp AS DATE), TO_CHAR(collection_timestamp, 'HH24:MI')")
	    List<Map<String, Object>> findDailyTrends(@Param("ucgSourceId") int ucgSourceId, @Param("fromDate") Date fromDate, @Param("toDate") Date toDate);

}

Service reference:
public Map<String, TrendsDTO> getDailyTrends(TrendsRequest params) throws ParseException {
	    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	    List<Map<String, Object>> results = uCSPTrendsRepository.findDailyTrends(params.getUcgSourceID(), params.getFromDate(), params.getToDate());

	    Map<String, TrendsDTO> trendsData = new HashMap<>();

	    for (Map<String, Object> result : results) {
	        String date = dateFormat.format(result.get("date"));
	        String time = (String) result.get("time");
	        double sizeOfFilesBytes = ((Number) result.get("sizeOfFilesBytes")).doubleValue();
	        int numberOfFiles = ((Number) result.get("numberOfFiles")).intValue();

	        TrendsDrillDownData trendsDataPoint = new TrendsDrillDownData(time, sizeOfFilesBytes, numberOfFiles);

	        trendsData
	            .computeIfAbsent(date, k -> new TrendsDTO(date))
	            .addTrendsData(trendsDataPoint);
	    }

	    logger.debug("trendsData {}", trendsData);
	    return trendsData;
	}
