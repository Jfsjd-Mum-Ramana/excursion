package com.verizon.ucs.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.util.Map;

@Configuration
@ConfigurationProperties(prefix = "nexus")
public class NexusConfig {
    private Map<String, String> apiEndpoints;
    private String credentials;
    private boolean useSampleData;
    private Map<String, String> sampleDataPaths;

    // Getters and Setters

    public Map<String, String> getApiEndpoints() {
        return apiEndpoints;
    }

    public void setApiEndpoints(Map<String, String> apiEndpoints) {
        this.apiEndpoints = apiEndpoints;
    }

    public String getCredentials() {
        return credentials;
    }

    public void setCredentials(String credentials) {
        this.credentials = credentials;
    }

    public boolean isUseSampleData() {
        return useSampleData;
    }

    public void setUseSampleData(boolean useSampleData) {
        this.useSampleData = useSampleData;
    }

    public Map<String, String> getSampleDataPaths() {
        return sampleDataPaths;
    }

    public void setSampleDataPaths(Map<String, String> sampleDataPaths) {
        this.sampleDataPaths = sampleDataPaths;
    }
}



package com.verizon.ucs.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.retry.annotation.EnableRetry;
import org.springframework.retry.backoff.FixedBackOffPolicy;
import org.springframework.retry.policy.SimpleRetryPolicy;
import org.springframework.retry.support.RetryTemplate;

@Configuration
@EnableRetry
public class RetryConfig {

    @Bean
    public RetryTemplate retryTemplate() {
        RetryTemplate retryTemplate = new RetryTemplate();

        // Configure retry policy
        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();
        retryPolicy.setMaxAttempts(3);

        // Configure backoff policy
        FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy();
        backOffPolicy.setBackOffPeriod(2000); // 2 seconds

        retryTemplate.setRetryPolicy(retryPolicy);
        retryTemplate.setBackOffPolicy(backOffPolicy);

        return retryTemplate;
    }
}


package com.verizon.ucs.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "vmb")
public class VMBProperties {
    private String serviceUrl;
    //private boolean compressionEnabled;

    private String topicName;

    private String tlsCertFile;
    private String tlsKeyFile;
    private String tlsTrustCertsFile;

    public String getServiceUrl() {
        return serviceUrl;
    }

    public void setServiceUrl(String serviceUrl) {
        this.serviceUrl = serviceUrl;
    }
/* 
    public boolean isCompressionEnabled() {
        return compressionEnabled;
    }

    public void setCompressionEnabled(boolean compressionEnabled) {
        this.compressionEnabled = compressionEnabled;
    } */

    public String getTlsCertFile() {
        return tlsCertFile;
    }

    public void setTlsCertFile(String tlsCertFile) {
        this.tlsCertFile = tlsCertFile;
    }

    public String getTlsKeyFile() {
        return tlsKeyFile;
    }

    public void setTlsKeyFile(String tlsKeyFile) {
        this.tlsKeyFile = tlsKeyFile;
    }

    public String getTlsTrustCertsFile() {
        return tlsTrustCertsFile;
    }

    public void setTlsTrustCertsFile(String tlsTrustCertsFile) {
        this.tlsTrustCertsFile = tlsTrustCertsFile;
    }

    public String getTopicName() {
        return topicName;
    }

    public void setTopicName(String topicName) {
        this.topicName = topicName;
    }

    @Override
    public String toString() {
        return "VMBProperties [serviceUrl=" + serviceUrl +  ", topicName="
                + topicName + ", tlsCertFile=" + tlsCertFile + ", tlsKeyFile=" + tlsKeyFile + ", tlsTrustCertsFile="
                + tlsTrustCertsFile + "]";
    }

}


package com.verizon.ucs.scheduler;

import java.io.IOException;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.service.DBService;
import com.verizon.ucs.service.NexusService;

@Component
public class NexusScheduler {
	private static final Logger logger = LoggerFactory.getLogger(NexusScheduler.class);
	private final ExecutorService executorService = Executors.newFixedThreadPool(3);
	
    @Autowired
    private DBService dBService;
    
    @Autowired
    private NexusService nexusService;

    @Scheduled(fixedRate = 900000)
    //@Scheduled(cron = "${scheduler.cron}", zone = "${scheduler.zone}")
    public void scheduleTask() {
        List<DeviceInfo> devices;
        try {
            // Fetch device details from the database
            devices = dBService.fetchDeviceDetails();
            logger.info("devices from DB::  {}", devices);
            
            // Process each device separately
            for (DeviceInfo device : devices) {
                executorService.submit(() -> {
                    try {
                        nexusService.getNexusData(device);
                    } catch (Exception e) {
                        logger.info("Exception while processing device: {} , {}",device,e);
                    }
                });
            }
        } catch (IOException e) {
            logger.info("Exception while processing devices: {}",e);
        }
    }
}

package com.verizon.ucs.service.pulsar;

import com.verizon.ucs.config.VMBProperties;
import com.verizon.ucs.scheduler.NexusScheduler;
import org.apache.pulsar.client.api.ClientBuilder;
import org.apache.pulsar.client.api.Producer;
import org.apache.pulsar.client.api.PulsarClient;
import org.apache.pulsar.client.api.PulsarClientException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

@Service
@EnableConfigurationProperties({ VMBProperties.class })
public class PulsarPublisherService {
    private static final Logger logger = LoggerFactory.getLogger(NexusScheduler.class);

    @Autowired
    private VMBProperties properties;

    public void publishMessage(String message) throws PulsarClientException {
        logger.info("In Publisher !!! {}", properties);

        Map<String, String> authParams = new HashMap<>();
        authParams.put("tlsCertFile", properties.getTlsCertFile());
        authParams.put("tlsKeyFile", properties.getTlsKeyFile());

        ClientBuilder builder = PulsarClient.builder();
        PulsarClient pulsarClient = (PulsarClient) builder.serviceUrl(properties.getServiceUrl())
                .tlsTrustCertsFilePath(properties.getTlsTrustCertsFile()).allowTlsInsecureConnection(true)
                .authentication("org.apache.pulsar.client.impl.auth.AuthenticationTls", authParams).enableTls(true)
                .build();
        /*
         * PulsarClient client = PulsarClient.builder()
         * .serviceUrl(properties.getServiceUrl())
         * .tlsTrustCertsFilePath(properties.getTlsTrustCertsFile())
         * .authentication(new AuthenticationTls(properties.getTlsCertFile(),
         * properties.getTlsKeyFile()))
         * .build();
         */

        /*
         * PulsarClient pulsarClient =
         * PulsarClientFactory.getPulsarClient(properties.getServiceUrl(),properties.
         * getTlsTrustCertsFile(),
         * properties.getTlsKeyFile(),properties.getTlsCertFile());
         * producer = pulsarClient.newProducer().topic(topicName)
         * .messageRouter(new
         * PartitionMessageRouter(numberOfPartition)).batchingMaxMessages(
         * batchingMaxMessages).batchingMaxBytes(batchingMaxBytes).blockIfQueueFull(
         * false).maxPendingMessages(maxPendingMessage).
         * maxPendingMessagesAcrossPartitions(maxPendingMessageAcrossParition).create();
         * this.throwableFunction = publishAsyncExceptionHandler();
         */

        Producer<byte[]> producer = (Producer<byte[]>) pulsarClient.newProducer()
                .topic(properties.getTopicName())
                .create();

        producer.send(message.getBytes());
        logger.info("Published Message !!! " + message.getBytes());

        producer.close();
        pulsarClient.close();
    }
}

package com.verizon.ucs.service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.RetryContext;
import org.springframework.retry.RetryListener;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.NexusParser;

import static org.springframework.boot.availability.AvailabilityChangeEvent.publish;

@Service
public class NexusService {
	private static final Logger logger = LoggerFactory.getLogger(NexusService.class);
    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;
    @Autowired
    private NormaliseReactorService normaliseReactorService;

    public NexusData getNexusData(DeviceInfo device) throws Exception {
        String response;
        String deviceType = device.getModel().replace("Nexus ", "").trim();

        if (config.isUseSampleData()) {
            response = new String(Files.readAllBytes(Paths.get(config.getSampleDataPaths().get(deviceType))));
        } else {
            response = fetchDataFromDevice(deviceType, device.getDeviceIP());
        }

        NexusParser parser = getParser(deviceType);
        NexusData data = parser.parse(response);
        validateData(data);

        logger.info("Publishing data for device: {}", device.getDeviceIP());
        normaliseReactorService.handleAndPublishData(data, device.getDeviceIP());
        return data;
    }

    private String fetchDataFromDevice(String deviceType,String deviceIP) throws Exception {
        return retryTemplate.execute(context -> {
        	
        	String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", deviceIP);
        	
        	 switch (deviceType) {
             case "1250":
            	 return restTemplate.getForObject(url, String.class);
             case "1450":
            	 return restTemplate.postForObject(url, getHttpEntity(), String.class);
             case "1500":
            	 return restTemplate.getForObject(url, String.class);
             default:
                 throw new IllegalArgumentException("Unsupported device type: " + deviceType);
         }
            
        });
    }
    private HttpEntity<String> getHttpEntity() {
    	HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<String> entity = new HttpEntity<>(createRequestPayload(Constants.REQUEST_BODY_1450), headers);
        return entity;
    }
    private String createRequestPayload(String[] chans) {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> payloadMap = Map.of("chans", chans);
        try {
            return mapper.writeValueAsString(payloadMap);
        } catch (JsonProcessingException e) {
            logger.error("Error creating JSON request payload", e);
            return null;
        }
    }

    private NexusParser getParser(String deviceType) {
        switch (deviceType) {
            case "1250":
                return new Nexus1250Parser();
            case "1450":
                return new Nexus1450Parser();
            case "1500":
                return new Nexus1250Parser();
            default:
                throw new IllegalArgumentException("Unsupported device type: " + deviceType);
        }
    }

    private void validateData(NexusData data) throws Exception {
    	if(data !=null && data.getDeviceName()!=null) {
    		return;
    	}
    }
}

package com.verizon.ucs.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.verizon.ucs.config.VMBProperties;
import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.service.pulsar.PulsarPublisherService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.stereotype.Service;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;

@Service

public class NormaliseReactorService {

	private static final Logger logger = LoggerFactory.getLogger(NormaliseReactorService.class);

	@Autowired
	private PulsarPublisherService pulsarPublisherService;

	@Autowired
	private VMBProperties vmbProperties;

	public void handleAndPublishData(NexusData data, String deviceIp) throws Exception {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
		String timestamp = dateFormat.format(new Date());

		ObjectMapper objectMapper = new ObjectMapper();
		ObjectNode ucgRawDataNode = (ObjectNode) objectMapper.valueToTree(data);

		Iterator<Map.Entry<String, JsonNode>> fields = ucgRawDataNode.fields();
		while (fields.hasNext()) {
			Map.Entry<String, JsonNode> field = fields.next();
			if (field.getValue().isTextual()) {
				ucgRawDataNode.put(field.getKey(), field.getValue().asText().trim());
			}
		}

		String ucgRawData = objectMapper.writeValueAsString(ucgRawDataNode);
		logger.info("UCGRAW JSON DATA: {}", ucgRawData);

		Map<String, Object> ucgData = Map.of(
				"ucgTimestamp", timestamp,
				"ucgSource", deviceIp,
				"ucgRawData", ucgRawData,
				"ucgDeviceName", data.getDeviceName().trim(),
				"ucgType", "LIVE",
				"ucgTopic", vmbProperties.getTopicName()
		);

		String ucgDataJsonString = objectMapper.writeValueAsString(ucgData);
		logger.info("UCG JSON DATA: {}", ucgDataJsonString);
		pulsarPublisherService.publishMessage(ucgDataJsonString);
	}
}


The above project showing error while accessing the log file please resolve the error and also I need to accept this acceptance creteria please develop the code 

yaml file

nexus:
  api-endpoints:
    1250: http://{siteIP}/poll_data.xml
    1450: http://{siteIP}/api/dm/data
    1500: http://{siteIP}/I/pdata.xml
  credentials: your-credentials
  use-sample-data: false
  sample-data-paths: 
   1250: src/main/resources/samples/10.219.32.76_nexus_1250.xml
   1450: src/main/resources/samples/nexus_1450.json
   1500: src/main/resources/samples/10.193.40.75_nexus1500.xml

scheduler:
   cron: 0 */15 * * * *
   zone: UTC

db:
  dbCallUrl: ${DB_URL:https://ucs-api-np-bbg1-idn.vzwnet.com/papi/api/call}
  stpName: eclipse.get_avl_stream_devices_fvo_1psc_test1

vmb:
  #serviceUrl: ${VMB_SERVICE_URL:pulsar+ssl://vmb-aws-us-west-2-nonprod.verizon.com:6651}
  serviceUrl: ${VMB_SERVICE_URL:pulsar+ssl://vmb-aws-us-east-1-nonprod.verizon.com:6651}
  partitionCount: ${VMB_PARTITION_COUNT:16}
  topicName: ${TOPIC_NAME:persistent://enmv/psc/nexus-meter}
  tlsCertFile: ${VMB_TLS_CERT_FILE:src/main/resources/vmb-ple-certs/enmv.cert.pem}
  tlsKeyFile: ${VMB_TLS_KEY_FILE:src/main/resources/vmb-ple-certs/enmv.key-pk8.pem}
  tlsTrustCertsFile: ${VMB_TRUST_CERTS_FILE:src/main/resources/vmb-ple-certs/ca.cert.pem}


 Given a Nexus 1450 device is unreachable, when UCS requests data, send an lov notification to vmb
RK-1: VMB instability may affect data publishing.
AS-1: VMB topic is configured and available.
*Technical Specifications*:

{"apiEndPoints":"\"UCS internal API endpoint for VMB publishing.\"","requestPayloadStructure":"\"Normalized power data (kW, kWh, etc.), timestamp.\"","responsePayloadStructure":"\"Success/failure status. HTTP status codes (200, 500).\"","authentication":"\"Secure communication between UCS and VMB.\"","errorHandling":"\"Error codes for publishing failures. Retry mechanism.\"","versioningInformation":"\"v1.0\"","performanceRequirementCriteria":"\"Publishing within 15 seconds\"","backwardCompatibility":"\"Yes\"","businessRules":"\"Data normalization rules.\"","loggingAndMonitoring":"\"Logs for successful/failed publishing attempts.\"","securityConsiderations":"\"Secure communication channel.\"","complianceRegulations":"\"N/A\"","documentationImpact":"\"Update documentation on VMB topic and data format.\""}


Please resolve this errors also
2025-02-02 19:52:00,183 UTC] [INFO ] pool-2-thread-2 com.verizon.ucs.scheduler.NexusScheduler - Exception while processing device: DeviceData [deviceName=Duff Dr - C-Tie, deviceIP=10.219.32.76, pollerCluster=null, model=Nexus 1250, frequency=null] , {}
java.lang.ClassCastException: class org.apache.pulsar.client.impl.PulsarClientImpl cannot be cast to class org.apache.pulsar.client.api.PulsarClient (org.apache.pulsar.client.impl.PulsarClientImpl and org.apache.pulsar.client.api.PulsarClient are in unnamed module of loader 'app')
	at com.verizon.ucs.service.pulsar.PulsarPublisherService.publishMessage(PulsarPublisherService.java:37)
	at com.verizon.ucs.service.NormaliseReactorService.handleAndPublishData(NormaliseReactorService.java:61)
	at com.verizon.ucs.service.NexusService.getNexusData(NexusService.java:61)
	at com.verizon.ucs.scheduler.NexusScheduler.lambda$scheduleTask$0(NexusScheduler.java:42)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)

http://localhost:8080/api/nexus/data/1500 ---> while accesig this host showing internal server error
