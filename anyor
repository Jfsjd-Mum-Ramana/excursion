package com.verizon.ucs.restapi.service;

import com.verizon.ucs.restapi.dto.AlarmMetricsRequest;
import com.verizon.ucs.restapi.dto.ApiRequest;
import com.verizon.ucs.restapi.dto.TrendsRequest;
import com.verizon.ucs.restapi.model.*;
import com.verizon.ucs.restapi.repository.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class UCSPService {

	private static final Logger logger = LoggerFactory.getLogger(UCSPService.class);

	@Autowired
	private UCSPRepository uCSPRepository;

	@Autowired
	private UCSPTrendsRepository uCSPTrendsRepository;

	@Autowired
	private UCSPProjectsRepository ucspProjectsRepository;

	@Autowired
	private UCSPAlarmInventoryRepository alarmInventoryRepository;

	@Autowired
	private UCSPAlarmMetricsRepository alarmMetricsRepository;

	public List<UcspProject> getUniqueUCGSourcesByProject(Long projectId) {
		try {
			List<UcspProject> ucgSources = ucspProjectsRepository.findDistinctUCGSourcesByProject(projectId);
			if (ucgSources == null || ucgSources.isEmpty()) {
				throw new RuntimeException("No UCG Sources found for the given project ID: " + projectId);
			}
			return ucgSources;
		} catch (Exception e) {
			logger.error("Error in service method getUniqueUCGSourcesByProject", e);
			throw e;
		}
	}

	public List<Device> searchDevices(ApiRequest params) {
		if (params.getDeviceName() != null && !params.getDeviceName().isEmpty()) {
			return uCSPRepository.findByDeviceNameIgnoreCase(params.getDeviceName());
		}
		if (params.getLoopback() != null && !params.getLoopback().isEmpty()) {
			return uCSPRepository.findByLoopbackIgnoreCase(params.getLoopback());
		}
		if (params.getNetwork() != null && !params.getNetwork().isEmpty()) {
			return uCSPRepository.findByNetworkIgnoreCase(params.getNetwork());
		}
		if (params.getVendor() != null && !params.getVendor().isEmpty()) {
			return uCSPRepository.findByVendorIgnoreCase(params.getVendor());
		}
		if (params.getModel() != null && !params.getModel().isEmpty()) {
			return uCSPRepository.findByModelIgnoreCase(params.getModel());
		}
		return null;
	}

	public Map<String, TrendsDTO> getDailyTrends(TrendsRequest params) throws ParseException {
	    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	    List<Map<String, Object>> results = uCSPTrendsRepository.findDailyTrends(params.getUcgSourceID(), params.getFromDate(), params.getToDate());

	    Map<String, TrendsDTO> trendsData = new HashMap<>();

	    for (Map<String, Object> result : results) {
	        String date = dateFormat.format(result.get("date"));
	        String time = (String) result.get("time");
	        double sizeOfFilesBytes = ((Number) result.get("sizeOfFilesBytes")).doubleValue();
	        int numberOfFiles = ((Number) result.get("numberOfFiles")).intValue();

	        TrendsDrillDownData trendsDataPoint = new TrendsDrillDownData(time, sizeOfFilesBytes, numberOfFiles);

	        trendsData
	            .computeIfAbsent(date, k -> new TrendsDTO(date))
	            .addTrendsData(trendsDataPoint);
	    }

	    logger.debug("trendsData {}", trendsData);
	    return trendsData;
	}


	public Map<String, List<String>> getUniqueValues() {
		Map<String, List<String>> uniqueValues = new HashMap<>();
		uniqueValues.put("models", uCSPRepository.findDistinctModels());
		uniqueValues.put("vendors", uCSPRepository.findDistinctVendors());
		uniqueValues.put("networks", uCSPRepository.findDistinctNetworks());
		return uniqueValues;
	}
	public List<String> getUniqueUCGSources(){
		return uCSPRepository.findDistinctUCGSources();
	}
	public List<Device> getAllDevices() {
		return uCSPRepository.findAll();
	}

	public List<UcspProject> getUniqueProjects() {
		return ucspProjectsRepository.findUniqueProjects();
	}
	public Map<String, List<String>> uniqueNetworksByProtocol() {
		Map<String, List<String>> uniqueValues = new HashMap<>();
		uniqueValues.put("snmp", uCSPRepository.uniqueNetworksBySNMPprotocol());
		return uniqueValues;
	}
	
	public List<String> uniqueDevicesByNetwork(String network) {
		return uCSPRepository.getUniqueDevicesByNetwork(network);
	}
	
	public Map<String, AvgNetworkCoverageDTO> avgNetworkByCoverage(String networkName,String fromDate,String toDate,String device) throws ParseException {
        Map<String, AvgNetworkCoverageDTO> detailedData = new HashMap<>();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");

        List<Map<String, Object>> results = uCSPRepository.avgNetworkByCoverage(networkName,dateFormat.parse(fromDate),dateFormat.parse(toDate),device);

        for (Map<String, Object> result : results) {
            String date = dateFormat.format(result.get("date"));
            String time = (String) result.get("time");
            double sumOfCoverage = ((Number) result.get("sumOfCoverage")).doubleValue();

            AvgNetworkCovDrillDownData coverageData = new AvgNetworkCovDrillDownData(time, sumOfCoverage);

            detailedData
                .computeIfAbsent(date, k -> new AvgNetworkCoverageDTO(date))
                .addCoverageData(coverageData);
            /*detaileddata
                .computeifabsent(date, k -> new avgnetworkcoveragedto(date, 0.0, new arraylist<>()))
                .getCoveragedatalist().add(coveragedata);
            detaileddata.get(date).setTotalcoverage(detaileddata.get(date).getTotalcoverage() + sumofcoverage);
            */
        }
        logger.debug("detailedData {}",detailedData);
        return detailedData;
    }

//	public List<ScatterPlotData> getScatterPlotDataByProtocol(String protocol) {
//		logger.debug("Received request to fetch scatter plot data for protocol: " + protocol);
//		List<ScatterPlotData> scatterPlotData = alarmMetricsRepository.findScatterPlotDataByProtocol(protocol);
//		logger.debug("Returning scatter plot data: " + scatterPlotData);
//		return scatterPlotData;
//	}

	public Map<String, AlarmMetricsDTO> getAlarmMetrics(AlarmMetricsRequest params) throws ParseException {
		SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		List<Map<String, Object>> results = alarmMetricsRepository.findMetricsByCollectionTypeAndDateRange(params.getCollectionType(), params.getFromDate(), params.getToDate());
//		List<Map<String, Object>> results = null;
		Map<String, AlarmMetricsDTO> alarmMetricsData = new HashMap<>();

		for (Map<String, Object> result : results) {
			String date = dateFormat.format(result.get("date"));
			String time = (String) result.get("time");
			double sizeOfFilesBytes = ((Number) result.get("sizeOfFilesBytes")).doubleValue();
			int numberOfFiles = ((Number) result.get("numberOfFiles")).intValue();

			AlarmMetricsDrillDownData alarmMetricsDataPoint = new AlarmMetricsDrillDownData(time, sizeOfFilesBytes, numberOfFiles);

			alarmMetricsData
					.computeIfAbsent(date, k -> new AlarmMetricsDTO(date))
					.addTrendsData(alarmMetricsDataPoint);
		}

		logger.debug("trendsData {}", alarmMetricsData);
		return alarmMetricsData;
	}

	// Fetch metrics by protocol
	// Fetch inventory data by protocol
	public List<UCSPAlarmInventory> filterInventoryByProtocol(String protocol) {
		logger.info("Fetching inventory data for protocol: " + protocol);
		return alarmInventoryRepository.findByUcgSourceDataWithLogging(protocol);
	}

	// Fetch available protocols
	public List<String> getAvailableProtocols() {
		logger.info("Fetching available protocols");
		return alarmInventoryRepository.findDistinctProtocols();
	}


}



package com.verizon.ucs.restapi.repository;

import com.verizon.ucs.restapi.model.UCSPAlarmMetrics;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Date;
import java.util.List;
import java.util.Map;

@Repository
public interface UCSPAlarmMetricsRepository extends JpaRepository<UCSPAlarmMetrics, Long> {
    Logger logger = LoggerFactory.getLogger(UCSPAlarmMetricsRepository.class);
    // Query to get scatter plot data by protocol (aggregation based on protocol)
//    @Query(nativeQuery = true, value = "SELECT c.collection_name AS collectionName, " +
//            "TO_CHAR(m.last_updated, 'YYYY-MM-DD') AS date, " +
//            "m.size_of_msgs AS value " +
//            "FROM ucsp_alarm_inventory c " +
//            "JOIN ucsp_alarm_metrics m ON c.collection_name = m.collection_name " +
//            "WHERE c.ucg_source = :protocol")
//    List<ScatterPlotData> findScatterPlotDataByProtocol(@Param("protocol") String protocol);
//    default  List<ScatterPlotData> findScatterPlotDataWithLogging(String protocol) {
//        logger.info("Executing query for protocol: " +protocol) ;
//        List<ScatterPlotData> result = findScatterPlotDataByProtocol(protocol);
//        logger.info("Query result: " +result);
//        return result;
//    }


    @Query("SELECT am FROM UCSPAlarmMetrics am " +
            "JOIN am.collectionID ai " +
            "JOIN ai.collectionType ct " +
            "WHERE ct = :collectionType " +
            "AND am.collectionDate BETWEEN :fromDate AND :toDate")
    List<Map<String, Object>> findMetricsByCollectionTypeAndDateRange(
            @Param("collectionType") String collectionType,
            @Param("fromDate") Date fromDate,
            @Param("toDate") Date toDate
    );



}


package com.verizon.ucs.restapi.repository;

import com.verizon.ucs.restapi.model.UCSPAlarmInventory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.ArrayList;
import java.util.List;

@Repository
public interface UCSPAlarmInventoryRepository extends JpaRepository<UCSPAlarmInventory, Long> {

    Logger logger = LoggerFactory.getLogger(UCSPAlarmInventoryRepository.class);

    List<UCSPAlarmInventory> findByProtocol(@Param("protocol") String protocol);

    default List<UCSPAlarmInventory> findByUcgSourceDataWithLogging(String protocol) {
        logger.info("Executing query for protocol: " + protocol);
        List<UCSPAlarmInventory> result = new ArrayList<>();
        try {
            result = findByProtocol(protocol);
        } catch (Exception ex) {
            logger.error("Exception occured :" + ex);
        }
        logger.info("Query result: " + result);
        return result;
    }

    // Query to fetch distinct protocols
    @Query("SELECT DISTINCT u.ucgSource FROM UCSPAlarmInventory u")
    List<String> findDistinctProtocols();

}


package com.verizon.ucs.restapi.controllers;

import com.verizon.ucs.restapi.dto.AlarmMetricsRequest;
import com.verizon.ucs.restapi.dto.ApiRequest;
import com.verizon.ucs.restapi.dto.TrendsRequest;
import com.verizon.ucs.restapi.model.*;

import com.verizon.ucs.restapi.service.UCSPService;
import graphql.GraphQLException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.SchemaMapping;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestParam;

import java.time.LocalDateTime;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Controller interface for UCS Portal Application with JPA
 */
@Controller
public class UCSPController {
    private static final Logger logger = LoggerFactory.getLogger(UCSPController.class);

    @Autowired
    private UCSPService uCSPService;



    @QueryMapping(value = "searchDevices")
    public List<Device> getFilteredDevices(@Argument ApiRequest apiRequest) {
        return uCSPService.searchDevices(apiRequest);
    }

    @QueryMapping(value = "allDevices")
    public List<Device> getAllDevices() {
        return uCSPService.getAllDevices();
    }

    @SchemaMapping(typeName = "Query", value = "uniqueModels")
    public List<String> getUniqueModels() {
        return uCSPService.getUniqueValues().get("models");
    }

    @QueryMapping(value = "uniqueVendors")
    public List<String> getUniqueVendors() {
        return uCSPService.getUniqueValues().get("vendors");
    }

    @QueryMapping(value = "dailyTrends")
    public List<TrendsDTO> getTrends(@Argument TrendsRequest trendsRequest) {
        try {
        	 Map<String, TrendsDTO> trendsDataMap = uCSPService.getDailyTrends(trendsRequest);
             return trendsDataMap.values().stream()
            		  .sorted(Comparator.comparing(TrendsDTO::getDate))
            		 .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching data", e);
            throw new GraphQLException("Database error: Unable to fetch data");
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }

    @QueryMapping
    public List<String> uniqueNetworks() {
        return uCSPService.getUniqueValues().get("networks");
    }

    @QueryMapping(value = "uniqueUCSPProjects")
    public List<UcspProject> getUniqueProjects() {
        List<UcspProject> ucgProjects = uCSPService.getUniqueProjects();
        return ucgProjects;
    }

    @QueryMapping(value = "uniqueUCGSources")
    public List<String> getUniqueUCGSources() {
        List<String> ucgSources = uCSPService.getUniqueUCGSources();
        return ucgSources;
    }

    @QueryMapping(value = "uniqueUCGSourcesByProject")
    public List<UcspProject> getUniqueUCGSourcesByProject(@Argument Long projectId) {
        try {
            return uCSPService.getUniqueUCGSourcesByProject(projectId);
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching UCG Sources", e);
            throw new GraphQLException("Database error: Unable to fetch UCG Sources for project ID: " + projectId);
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }
    
    @QueryMapping
    public List<String> uniqueNetworksByProtocol() {
        return uCSPService.uniqueNetworksByProtocol().get("snmp");
    }
    
    @QueryMapping
    public List<String> uniqueDevicesByNetwork(@Argument String network) {
        return uCSPService.uniqueDevicesByNetwork(network);
    }
    
    @QueryMapping(value = "avgNetworkByCoverage")
    public List<AvgNetworkCoverageDTO> avgNetworkByCoverage(@Argument String network,
            @Argument String fromDate, @Argument String toDate, @Argument String device) {
        try {
            Map<String, AvgNetworkCoverageDTO> detailedData = uCSPService.avgNetworkByCoverage(network, fromDate, toDate, device);
            return detailedData.values().stream()
                    .map(dto -> {
                        dto.setTotalCoverage(Double.parseDouble(dto.getFormattedTotalCoverage()));
                        return dto;
                    })
                    .sorted(Comparator.comparing(AvgNetworkCoverageDTO::getDate))
                    .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching network coverage", e);
            throw new GraphQLException("Database error: Unable to fetch network coverage for network: " + network);
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }

    @QueryMapping
    public List<UCSPAlarmInventory> filterInventoryByProtocol(@Argument String protocol) {
        return uCSPService.filterInventoryByProtocol(protocol);
    }

    // Query to get available protocols
    @QueryMapping
    public List<String> availableProtocols() {
        return uCSPService.getAvailableProtocols();
    }


    // Query to get scatter plot data by protocol

    @QueryMapping(value = "alarmMetrics")
    public List<AlarmMetricsDTO> getAlarmMetric(@Argument AlarmMetricsRequest alarmMetricstrendsRequest) {
        try {
            Map<String, AlarmMetricsDTO> alarmMetricsDataMap = uCSPService.getAlarmMetrics(alarmMetricstrendsRequest);
            return alarmMetricsDataMap.values().stream()
                    .sorted(Comparator.comparing(AlarmMetricsDTO::getDate))
                    .collect(Collectors.toList());
        } catch (DataAccessException e) {
            logger.error("Database error occurred while fetching data", e);
            throw new GraphQLException("Database error: Unable to fetch data");
        } catch (RuntimeException e) {
            logger.error("Runtime error occurred", e);
            throw new GraphQLException("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Unexpected error occurred", e);
            throw new GraphQLException("Unexpected error: " + e.getMessage());
        }
    }
//    @QueryMapping
//    public List<ScatterPlotData> getScatterPlotDataByProtocol(@Argument String protocol) {
//        return uCSPService.getScatterPlotDataByProtocol(protocol);
//    }
}


package com.verizon.ucs.restapi.model;

import javax.persistence.*;
import java.util.List;

@Entity
@Table(name = "ucsp_collection_type")
public class UCSPCollectionType {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "type_id")
    private int typeId;

    @Column(name = "type", unique = true, nullable = false)
    private String type;


    // Getters and Setters
    public int getTypeId() {
        return typeId;
    }

    public void setTypeId(int typeId) {
        this.typeId = typeId;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

}


package com.verizon.ucs.restapi.model;

import javax.persistence.*;
import java.sql.Timestamp;

@Entity
@Table(name = "ucsp_alarm_metrics")
public class UCSPAlarmMetrics {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private int id;

    @Column(name = "collection_id")
    private int collectionID; // Foreign Key to ucsp_alarm_inventory

    @Column(name = "collection_date")
    private Timestamp collectionDate;

    @Column(name = "number_of_msgs")
    private long numberOfMsgs;

    @Column(name = "size_of_msgs")
    private long sizeOfMsgs;

    // Getters and Setters
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getCollection() {
        return collectionID;
    }

    public void setCollection(int collection) {
        this.collectionID = collection;
    }

    public Timestamp getCollectionDate() {
        return collectionDate;
    }

    public void setCollectionDate(Timestamp collectionDate) {
        this.collectionDate = collectionDate;
    }

    public long getNumberOfMsgs() {
        return numberOfMsgs;
    }

    public void setNumberOfMsgs(long numberOfMsgs) {
        this.numberOfMsgs = numberOfMsgs;
    }

    public long getSizeOfMsgs() {
        return sizeOfMsgs;
    }

    public void setSizeOfMsgs(long sizeOfMsgs) {
        this.sizeOfMsgs = sizeOfMsgs;
    }
}


package com.verizon.ucs.restapi.model;

import javax.persistence.*;
import java.net.InetAddress;
import java.sql.Timestamp;

@Entity
@Table(name = "ucsp_alarm_inventory_new")
public class UCSPAlarmInventory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private int id;

    @Column(name = "collection_type_id")
    private int collectionType; // Foreign Key to ucsp_collection_type

    @Column(name = "device_name", unique = true, nullable = false)
    private String deviceName;

    @Column(name = "device_ip", unique = true, nullable = false)
    private InetAddress deviceIp;

    @Column(name = "model")
    private String model;

    @Column(name = "vendor")
    private String vendor;

    @Column(name = "routerType")
    private String routerType;

    @Column(name = "status")
    private String status;

    @Column(name = "loopback")
    private String loopback;

    @Column(name = "network")
    private String network;

    @Column(name = "pollerCluster")
    private String pollerCluster;

    @Column(name = "pollerInterval")
    private String pollerInterval;

    @Column(name = "lastUpdate")
    private Timestamp lastUpdate;

    @Column(name = "physIp")
    private InetAddress physIp;

    // Getters and Setters
    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getCollectionType() {
        return collectionType;
    }

    public void setCollectionType(int collectionType) {
        this.collectionType = collectionType;
    }

    public String getDeviceName() {
        return deviceName;
    }

    public void setDeviceName(String deviceName) {
        this.deviceName = deviceName;
    }

    public InetAddress getDeviceIp() {
        return deviceIp;
    }

    public void setDeviceIp(InetAddress deviceIp) {
        this.deviceIp = deviceIp;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public String getVendor() {
        return vendor;
    }

    public void setVendor(String vendor) {
        this.vendor = vendor;
    }

    public String getRouterType() {
        return routerType;
    }

    public void setRouterType(String routerType) {
        this.routerType = routerType;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getLoopback() {
        return loopback;
    }

    public void setLoopback(String loopback) {
        this.loopback = loopback;
    }

    public String getNetwork() {
        return network;
    }

    public void setNetwork(String network) {
        this.network = network;
    }

    public String getPollerCluster() {
        return pollerCluster;
    }

    public void setPollerCluster(String pollerCluster) {
        this.pollerCluster = pollerCluster;
    }

    public String getPollerInterval() {
        return pollerInterval;
    }

    public void setPollerInterval(String pollerInterval) {
        this.pollerInterval = pollerInterval;
    }

    public Timestamp getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(Timestamp lastUpdate) {
        this.lastUpdate = lastUpdate;
    }

    public InetAddress getPhysIp() {
        return physIp;
    }

    public void setPhysIp(InetAddress physIp) {
        this.physIp = physIp;
    }
}


For the above code showing this erro please try to resolve this error

[2024-12-13 18:31:36,943 UTC] [ERROR] main com.verizon.ucs.restapi.RestApi - Exception occurred and stopping restapi service - org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'UCSPController': Unsatisfied dependency expressed through field 'uCSPService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'UCSPService': Unsatisfied dependency expressed through field 'alarmInventoryRepository'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'UCSPAlarmInventoryRepository' defined in com.verizon.ucs.restapi.repository.UCSPAlarmInventoryRepository defined in @EnableJpaRepositories declared on JpaRepositoriesRegistrar.EnableJpaRepositoriesConfiguration: Invocation of init method failed; nested exception is org.springframework.data.repository.query.QueryCreationException: Could not create query for public abstract java.util.List com.verizon.ucs.restapi.repository.UCSPAlarmInventoryRepository.findByProtocol(java.lang.String); Reason: Failed to create query for method public abstract java.util.List com.verizon.ucs.restapi.repository.UCSPAlarmInventoryRepository.findByProtocol(java.lang.String)! No property 'protocol' found for type 'UCSPAlarmInventory'; nested exception is java.lang.IllegalArgumentException: Failed to create query for method public abstract java.util.List com.verizon.ucs.restapi.repository.UCSPAlarmInventoryRepository.findByProtocol(java.lang.String)! No property 'protocol' found for type 'UCSPAlarmInventory'
