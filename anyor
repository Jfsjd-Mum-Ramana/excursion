package com.verizon.ucs.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.Nexus1500Parser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;
import java.util.function.Function;

@Service
public class NexusService {
    
    private static final Logger logger = LoggerFactory.getLogger(NexusService.class);

    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;

    @Autowired
    private PulsarPublisherService pulsarPublisherService; // For sending LOV notifications

    public Object processDevice(DeviceInfo device) throws Exception {
        String deviceType = device.getModel().replace("Nexus ", "");
        Function<String, ?> parser = getParser(deviceType);

        if (parser != null) {
            Object data = getNexusData(device, parser);

            // If Nexus 1450 device is unreachable, send LOV notification
            if (Constants.DEVICE_TYPE_1450.equals(deviceType)) {
                sendLovNotification(device.getDeviceIP());
            }
            
            return data;
        } else {
            logger.info("Unsupported device type: {}", deviceType);
            return null;
        }
    }

    private Function<String, ?> getParser(String deviceType) {
        switch (deviceType) {
            case Constants.DEVICE_TYPE_1250:
                return response -> new Nexus1250Parser().parse(response);
            case Constants.DEVICE_TYPE_1450:
                return response -> new Nexus1450Parser().parse(response);
            case Constants.DEVICE_TYPE_1500:
                return response -> new Nexus1500Parser().parse(response);
            default:
                return null;
        }
    }

    public <T> T getNexusData(DeviceInfo device, Function<String, T> parser) throws Exception {
        String response = fetchDataFromDevice(device.getModel(), device.getDeviceIP());
        return parser.apply(response);
    }

    private String fetchDataFromDevice(String deviceType, String deviceIP) throws Exception {
        return retryTemplate.execute(context -> {
            try {
                String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", deviceIP);
                switch (deviceType) {
                    case Constants.DEVICE_TYPE_1250:
                        return restTemplate.getForObject(url, String.class);
                    case Constants.DEVICE_TYPE_1450:
                        return restTemplate.postForObject(url, getHttpEntity(), String.class);
                    case Constants.DEVICE_TYPE_1500:
                        return restTemplate.getForObject(url, String.class);
                    default:
                        throw new IllegalArgumentException("Unsupported device type: " + deviceType);
                }
            } catch (Exception e) {
                if (Constants.DEVICE_TYPE_1450.equals(deviceType)) {
                    logger.error("Nexus 1450 device unreachable, sending LOV notification to VMB", e);
                    sendLovNotification(deviceIP);
                }
                throw e;
            }
        });
    }

    private HttpEntity<String> getHttpEntity() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(createRequestPayload(Constants.REQUEST_BODY_1450), headers);
    }

    private String createRequestPayload(String[] chans) {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> payloadMap = Map.of("chans", chans);
        try {
            return mapper.writeValueAsString(payloadMap);
        } catch (JsonProcessingException e) {
            logger.error("Error creating JSON request payload", e);
            return null;
        }
    }

    // Method to send LOV (Loss of Visibility) notification to Pulsar/VMB
    private void sendLovNotification(String deviceIp) {
        Map<String, Object> lovNotification = Map.of(
            "timestamp", System.currentTimeMillis(),
            "deviceIp", deviceIp,
            "status", "LOV",
            "message", "Nexus 1450 device is unreachable"
        );

        try {
            String payload = new ObjectMapper().writeValueAsString(lovNotification);
            pulsarPublisherService.publishMessage(payload);  // Assuming a method for publishing
            logger.info("LOV notification sent for Nexus 1450: {}", deviceIp);
        } catch (Exception e) {
            logger.error("Failed to send LOV notification", e);
        }
    }
}