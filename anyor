package com.verizon.ucs.service;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.retry.RetryCallback;
import org.springframework.retry.RetryContext;
import org.springframework.retry.RetryListener;
import org.springframework.retry.support.RetryTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.ucs.config.Constants;
import com.verizon.ucs.config.NexusConfig;
import com.verizon.ucs.model.DeviceInfo;
import com.verizon.ucs.model.NexusData;
import com.verizon.ucs.parser.Nexus1250Parser;
import com.verizon.ucs.parser.Nexus1450Parser;
import com.verizon.ucs.parser.NexusParser;

@Service
public class NexusService {
	private static final Logger logger = LoggerFactory.getLogger(NexusService.class);
    @Autowired
    private NexusConfig config;

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private RetryTemplate retryTemplate;
    
  
    public NexusData getNexusData(DeviceInfo device) throws Exception {
        String response;
        String deviceType = device.getModel().replace("Nexus ", "");
        
        if (config.isUseSampleData()) {
            response = new String(Files.readAllBytes(Paths.get(config.getSampleDataPaths().get(deviceType))));
        } else {
            response = fetchDataFromDevice(deviceType,device.getDeviceIP());
        }

        NexusParser parser = getParser(deviceType);
        NexusData data = parser.parse(response);
        logger.info("NexusData::  {}", data);
        //validateData(data);
        //yourservice.publish(data,"kk");
        return data;
    }

    private String fetchDataFromDevice(String deviceType,String deviceIP) throws Exception {
        return retryTemplate.execute(context -> {
        	
        	String url = config.getApiEndpoints().get(deviceType).replace("{siteIP}", deviceIP);
        	
        	 switch (deviceType) {
             case "1250":
            	 return restTemplate.getForObject(url, String.class);
             case "1450":
            	 return restTemplate.postForObject(url, getHttpEntity(), String.class);
             case "1500":
            	 return restTemplate.getForObject(url, String.class);
             default:
                 throw new IllegalArgumentException("Unsupported device type: " + deviceType);
         }
            
        });
    }
    private HttpEntity<String> getHttpEntity() {
    	HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<String> entity = new HttpEntity<>(createRequestPayload(Constants.REQUEST_BODY_1450), headers);
        return entity;
    }
    private String createRequestPayload(String[] chans) {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> payloadMap = Map.of("chans", chans);
        try {
            return mapper.writeValueAsString(payloadMap);
        } catch (JsonProcessingException e) {
            logger.error("Error creating JSON request payload", e);
            return null;
        }
    }

    private NexusParser getParser(String deviceType) {
        switch (deviceType) {
            case "1250":
                return new Nexus1250Parser();
            case "1450":
                return new Nexus1450Parser();
            case "1500":
                return new Nexus1250Parser();
            default:
                throw new IllegalArgumentException("Unsupported device type: " + deviceType);
        }
    }

    private void validateData(NexusData data) throws Exception {
    	if(data !=null && data.getDeviceName()!=null) {
    		return;
    	}
    }
}


vmb:
  #serviceUrl: ${VMB_SERVICE_URL:pulsar+ssl://vmb-aws-us-west-2-nonprod.verizon.com:6651}
  serviceUrl: ${VMB_SERVICE_URL:pulsar+ssl://vmb-aws-us-east-1-nonprod.verizon.com:6651}
  partitionCount: ${VMB_PARTITION_COUNT:16}
  topicName: ${TOPIC_NAME:persistent://enmv/psc-alarm/nexus-meter-lov}
  tlsCertFile: ${VMB_TLS_CERT_FILE:src/main/resources/ssl/vmb-ple-certs/enmv.cert.pem}
  tlsKeyFile: ${VMB_TLS_KEY_FILE:src/main/resources/ssl/vmb-ple-certs/enmv.key-pk8.pem}
  tlsTrustCertsFile: ${VMB_TRUST_CERTS_FILE:src/main/resources/ssl/vmb-ple-certs/ca.cert.pem}

For the above code plss provide this requirements develop here they are 

As a UCS developer, I want to normalize the power data retrieved from the Nexus 15xx model and publish it to the VMB so that 1PSC can consume the data in a consistent format.
RK-1: VMB instability may affect data publishing.
AS-1: VMB topic is configured and available.
*Technical Specifications*:

{"apiEndPoints":"\"UCS internal API endpoint for VMB publishing.\"","requestPayloadStructure":"\"Normalized power data (kW, kWh, etc.), timestamp.\"","responsePayloadStructure":"\"Success/failure status. HTTP status codes (200, 500).\"","authentication":"\"Secure communication between UCS and VMB.\"","errorHandling":"\"Error codes for publishing failures. Retry mechanism.\"","versioningInformation":"\"v1.0\"","performanceRequirementCriteria":"\"Publishing within 15 seconds\"","backwardCompatibility":"\"Yes\"","businessRules":"\"Data normalization rules.\"","loggingAndMonitoring":"\"Logs for successful/failed publishing attempts.\"","securityConsiderations":"\"Secure communication channel.\"","complianceRegulations":"\"N/A\"","documentationImpact":"\"Update documentation on VMB topic and data format.\""}

AC-1: Given normalized Nexus data, when UCS publishes, then data is sent to the correct VMB topic wit

these are the requirements plss give me all the requirements and code
